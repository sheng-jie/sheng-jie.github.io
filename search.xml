<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>五分钟快速搭建Serverless免费邮件服务</title>
    <url>/post/build-your-first-serverless-free-email-service-with-azure-function/</url>
    <content><![CDATA[<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-508cd8bd0a9c2fe7.png" alt=""></p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>本文将带你快速基于 Azure Function 和 SendGrid 构建一个免费的Serverless（无服务器）的邮件发送服务，让你感受下Serverless的强大之处。</p>
<p>该服务可以<strong>每月免费发送2,5000封</strong>，这是完全白嫖啊，感兴趣的，赶紧动起你的小手爪，噼里啪啦搞起来呀。</p>
<h1 id="2-创建-SendGrid-账号"><a href="#2-创建-SendGrid-账号" class="headerlink" title="2. 创建 SendGrid 账号"></a>2. 创建 SendGrid 账号</h1><p><em>你要有一个Azure账号，没有的话，花几分钟自行注册一个就好。(我的账号注册在香港区域)</em></p>
<p>咱们先来创建一个<strong>SendGrid Accounts</strong>，如下图所示。点击SendGrid Accounts后，再点击创建SendGrid account。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-48afba14c71a05c2.png" alt="SendGrid Accounts"></p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-83453108dc39e87f.png" alt="Create SendGrid Account"></p>
<p>填写完毕后，点击Review+Create，稍等片刻，提示部署成功，那么恭喜你，可以接着往下玩耍了。如果部署失败，可能会因为SendGrid屏蔽了某些区域的账号创建，就只能重新注册个Azure账号玩耍了。</p>
<p>紧接着，前往刚刚创建的SendGrid Account，点击Manage会跳转至SendGrid管理面板。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-8ff7849d28bd0cee.png" alt="SendGrid Account"></p>
<p>打开后，会要求你进去邮件验证，自行前往邮箱验证即可。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-cd231fc9c9e1a91c.png" alt="SendGrid Dashboard"></p>
<p>点击API Keys，然后点击Create API Key，填写API Key Name，选择 Full Access，点击Create&amp;View，记下生成的API Key，后面需要用到。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-19e799cbfe57546a.png" alt="创建ApiKey"></p>
<h1 id="3-创建第一个函数应用"><a href="#3-创建第一个函数应用" class="headerlink" title="3. 创建第一个函数应用"></a>3. 创建第一个函数应用</h1><p>回到Azure控制台，然后搜索<strong>函数应用</strong>。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-0baff2aa7153f3e3.png" alt="搜索函数应用"></p>
<p>打开后点击添加，按以下图示进行创建。其中务必选择以代码发布，承载的操作系统选择Windows。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-8ca4cc1a0e8c637f.png" alt="Create Azure Function"></p>
<p>创建成功后，转到资源，如下图所示：</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-c725525dd929a9a5.png" alt="Azure Function"></p>
<p>依次点击函数，添加，选择HTTP trigger模板，填写函数名称，然后指定身份验证级别。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-965ad86a3747bae3.png" alt="Create HTTP trigger"></p>
<p>点击创建，创建成功后，跳转到函数页面，点击获取函数URL，粘贴URL到浏览器就可以访问到你创建的第一个函数应用。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-182870212f9d7667.png" alt="First Httptrigger Function"></p>
<p>点击代码+测试，就可以看到模板代码，如下图所示：</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-0207fff5a0b8b049.png" alt="Httptrigger 模板代码"></p>
<p>从截图来看，这个和C#的语法并无太大差别，官方称为C#脚本。</p>
<p>紧接着替换<code>run.csx</code>为以下代码并点击保存：</p>
<p>紧接着替换<code>run.csx</code>为以下代码并点击保存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;run.csx</span><br><span class="line">#r &quot;Newtonsoft.Json&quot;</span><br><span class="line">#r &quot;SendGrid&quot;</span><br><span class="line"></span><br><span class="line">using System.Net;</span><br><span class="line">using Microsoft.Azure.WebJobs.Host;</span><br><span class="line">using SendGrid.Helpers.Mail;</span><br><span class="line">using Microsoft.Extensions.Primitives;</span><br><span class="line">using Newtonsoft.Json;</span><br><span class="line"></span><br><span class="line">public static SendGridMessage Run(Email req, ILogger log)</span><br><span class="line">&#123;</span><br><span class="line">    var reqStr &#x3D; JsonConvert.SerializeObject(req);</span><br><span class="line">    log.LogInformation(reqStr);</span><br><span class="line"></span><br><span class="line">    var message &#x3D; new SendGridMessage();</span><br><span class="line">    message.AddTo(req.To);</span><br><span class="line">    message.AddContent(&quot;text&#x2F;html&quot;, req.Body);</span><br><span class="line">    message.SetFrom(new EmailAddress(req.From));</span><br><span class="line">    message.SetSubject(req.Subject);</span><br><span class="line">    return message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Email</span><br><span class="line">&#123;</span><br><span class="line">    public string To &#123; get; set; &#125;</span><br><span class="line">    public string From &#123; get; set; &#125;</span><br><span class="line">    public string Subject &#123; get; set; &#125;</span><br><span class="line">    public string Body &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改<code>function.json</code>中的配置如下，并保存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;bindings&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;authLevel&quot;: &quot;function&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;req&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;httpTrigger&quot;,</span><br><span class="line">      &quot;direction&quot;: &quot;in&quot;,</span><br><span class="line">      &quot;methods&quot;: [</span><br><span class="line">        &quot;get&quot;,</span><br><span class="line">        &quot;post&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;sendGrid&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;$return&quot;,</span><br><span class="line">      &quot;direction&quot;: &quot;out&quot;,</span><br><span class="line">      &quot;apiKey&quot;: &quot;SendGridAPIKeyAsAppSetting&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意观察配置项中需要指定<code>apiKey</code>，就是我们上面创建SendGrid Account 中对应的ApiKey。回到上面创建的Azure Function 应用服务，然后按下图添加上面发邮件函数需要的配置项，如下所示。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-2e75613d39c9277e.png" alt="添加配置项"></p>
<p>添加完毕后，再回到函数中就可以测试运行了，如下图所示：</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-8226414351eae530.png" alt=""></p>
<p>查收邮件，你将收到来自Azure Function &amp; SendGrid 的免费问候。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-cf4dc9e150c3c981.png" alt="查收邮件"></p>
<p>当然，也可以通过Postman自行验证：</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-f4f04ec45f023c3f.png" alt="Postman"></p>
<h1 id="4-最后"><a href="#4-最后" class="headerlink" title="4.最后"></a>4.最后</h1><p>通过以上的连环操作，相信你不仅成功薅了一把微软的羊毛，而且顺带对<strong>Serverless</strong>也有了一定的认知。</p>
<p>如果对Azure Function感兴趣的，不妨参考<a href="https://docs.microsoft.com/en-us/azure/azure-functions/" target="_blank" rel="noopener">官方文档</a>研究一番，相信你会发掘不少玩法，顺便再薅它几把羊毛，哈哈哈！</p>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>Serverless</tag>
      </tags>
  </entry>
  <entry>
    <title>eShopOnContainers 知多少[7]：Basket microservice</title>
    <url>/post/eshoponcontainers-basket-microservice-7/</url>
    <content><![CDATA[<p><img src="/images/eshoponcontainers-basket-microservice-7/2799767-e68642329ba6030a.png" alt="购物车界面"></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Basket microservice（购物车微服务）主要用于处理购物车的业务逻辑，包括：</p>
<ol>
<li>购物车商品的CRUD</li>
<li>订阅商品价格更新事件，进行购物车商品同步处理 </li>
<li>购物车结算事件发布</li>
<li>订阅订单成功创建事件，进行购物车的清空操作</li>
</ol>
<h1 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h1><p><img src="/images/eshoponcontainers-basket-microservice-7/2799767-f68552c8a7b5811b.png" alt="数据驱动/CRUD 微服务设计"></p>
<p>如上图所示，本微服务采用数据驱动的CRUD微服务架构，并使用Redis数据库进行持久化。<br>这种类型的服务在单个 ASP.NET Core Web API 项目中即可实现所有功能，该项目包括数据模型类、业务逻辑类及其数据访问类。其项目结构如下：<br><img src="/images/eshoponcontainers-basket-microservice-7/2799767-8225ec1545ea179e.png" alt=""></p>
<p>核心技术选型：</p>
<ol>
<li>ASP.NET Core Web API</li>
<li>Entity Framework Core</li>
<li>Redis </li>
<li>Swashbuckle（可选）</li>
<li>Autofac</li>
<li>Eventbus</li>
<li>Newtonsoft.Json<h1 id="实体建模和持久化"><a href="#实体建模和持久化" class="headerlink" title="实体建模和持久化"></a>实体建模和持久化</h1>该微服务的核心领域实体是购物车，其类图如下：<img src="/images/eshoponcontainers-basket-microservice-7/2799767-3b8c1bcfce3e88e7.png" alt=""></li>
</ol>
<p>其中<code>CustomerBasket</code>与<code>BasketItem</code>为一对多关系，使用仓储模式进行持久化。</p>
<ol>
<li>通过对<code>CustomerBasket</code>对象进行json格式的序列化和反序列化来完成在redis中的持久化和读取。</li>
<li>以单例模式注入redis连接<code>ConnectionMultiplexer</code>，该对象最终通过构造函数注入到<code>RedisBasketRepository</code>中。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">services.AddSingleton&lt;ConnectionMultiplexer&gt;(sp &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var settings &#x3D; sp.GetRequiredService&lt;IOptions&lt;BasketSettings&gt;&gt;().Value;</span><br><span class="line">    var configuration &#x3D; ConfigurationOptions.Parse(settings.ConnectionString, true);</span><br><span class="line"></span><br><span class="line">    configuration.ResolveDns &#x3D; true;</span><br><span class="line"></span><br><span class="line">    return ConnectionMultiplexer.Connect(configuration);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="事件的注册和消费"><a href="#事件的注册和消费" class="headerlink" title="事件的注册和消费"></a>事件的注册和消费</h1><p>在本服务中主要需要处理以下事件的发布和消费：</p>
<ol>
<li>事件发布：当用户点击购物车结算时，发布用户结算事件。</li>
<li>事件消费：订单创建成功后，进行购物车的清空</li>
<li>事件消费：商品价格更新后，进行购物车相关商品的价格同步</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void ConfigureEventBus(IApplicationBuilder app)</span><br><span class="line">&#123;</span><br><span class="line">    var eventBus &#x3D; app.ApplicationServices.GetRequiredService&lt;IEventBus&gt;();</span><br><span class="line"></span><br><span class="line">    eventBus.Subscribe&lt;ProductPriceChangedIntegrationEvent, ProductPriceChangedIntegrationEventHandler&gt;();</span><br><span class="line">    eventBus.Subscribe&lt;OrderStartedIntegrationEvent, OrderStartedIntegrationEventHandler&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上都是基于<strong>事件总线</strong>来达成。</p>
<h1 id="认证和授权"><a href="#认证和授权" class="headerlink" title="认证和授权"></a>认证和授权</h1><p>购物车管理界面是需要认证和授权。那自然需要与上游的<code>Identity Microservice</code>进行衔接。在启动类进行认证中间件的配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void ConfigureAuthService(IServiceCollection services)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; prevent from mapping &quot;sub&quot; claim to nameidentifier.</span><br><span class="line">    JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();</span><br><span class="line">    var identityUrl &#x3D; Configuration.GetValue&lt;string&gt;(&quot;IdentityUrl&quot;); </span><br><span class="line">        </span><br><span class="line">    services.AddAuthentication(options &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        options.DefaultAuthenticateScheme &#x3D; JwtBearerDefaults.AuthenticationScheme;</span><br><span class="line">        options.DefaultChallengeScheme &#x3D; JwtBearerDefaults.AuthenticationScheme;</span><br><span class="line">    &#125;).AddJwtBearer(options &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        options.Authority &#x3D; identityUrl;</span><br><span class="line">        options.RequireHttpsMetadata &#x3D; false;</span><br><span class="line">        options.Audience &#x3D; &quot;basket&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">protected virtual void ConfigureAuth(IApplicationBuilder app)</span><br><span class="line">&#123;</span><br><span class="line">    if (Configuration.GetValue&lt;bool&gt;(&quot;UseLoadTest&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        app.UseMiddleware&lt;ByPassAuthMiddleware&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    app.UseAuthentication();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="手动启用断路器"><a href="#手动启用断路器" class="headerlink" title="手动启用断路器"></a>手动启用断路器</h1><p>在该微服务中，定义了一个<strong>中断中间件</strong>：<code>FailingMiddleware</code>，通过访问<code>http://localhost:5103/failing</code>获取该中间件的启用状态，通过请求参数指定：即通过<code>http://localhost:5103/failing?enable</code>和<code>http://localhost:5103/failing?disable</code>来手动中断和恢复服务，来模拟断路，以便用于测试断路器模式。<br>开启断路后，当访问购物车页面时，<strong>Polly在重试指定次数依然无法访问服务时，就会抛出<code>BrokenCircuitException</code>异常</strong>，通过捕捉该异常告知用户稍后再试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CartController : Controller</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;…</span><br><span class="line">    public async Task&lt;IActionResult&gt; Index()</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;          </span><br><span class="line">            var user &#x3D; _appUserParser.Parse(HttpContext.User);</span><br><span class="line">            &#x2F;&#x2F;Http requests using the Typed Client (Service Agent)</span><br><span class="line">            var vm &#x3D; await _basketSvc.GetBasket(user);</span><br><span class="line">            return View(vm);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (BrokenCircuitException)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F; Catches error when Basket.api is in circuit-opened mode                 </span><br><span class="line">            HandleBrokenCircuitException();</span><br><span class="line">        &#125;</span><br><span class="line">        return View();</span><br><span class="line">    &#125;       </span><br><span class="line">    private void HandleBrokenCircuitException()</span><br><span class="line">    &#123;</span><br><span class="line">        TempData[&quot;BasketInoperativeMsg&quot;] &#x3D; &quot;Basket Service is inoperative, please try later on. (Business message due to Circuit-Breaker)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/eshoponcontainers-basket-microservice-7/2799767-f7c710c41e174f94.png" alt="提示购物车服务暂时不可用"></p>
<h1 id="注入过滤器"><a href="#注入过滤器" class="headerlink" title="注入过滤器"></a>注入过滤器</h1><p>在配置MVC服务时指定了两个过滤器：全局异常过滤器和模型验证过滤器。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Add framework services.</span><br><span class="line">services.AddMvc(options &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.Filters.Add(typeof(HttpGlobalExceptionFilter));</span><br><span class="line">    options.Filters.Add(typeof(ValidateModelStateFilter));</span><br><span class="line"></span><br><span class="line">&#125;).AddControllersAsServices();</span><br></pre></td></tr></table></figure>
<ol>
<li>全局异常过滤器是通过定义<code>BasketDomainException</code>异常和<code>HttpGlobalExceptionFilter</code>过滤器来实现的。</li>
<li>模型验证过滤器是通过继承<code>ActionFilterAttribute</code>特性实现的<code>ValidateModelStateFilter</code>来获取模型状态中的错误。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ValidateModelStateFilter : ActionFilterAttribute</span><br><span class="line">&#123;</span><br><span class="line">    public override void OnActionExecuting(ActionExecutingContext context)</span><br><span class="line">    &#123;</span><br><span class="line">        if (context.ModelState.IsValid)</span><br><span class="line">        &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var validationErrors &#x3D; context.ModelState</span><br><span class="line">            .Keys</span><br><span class="line">            .SelectMany(k &#x3D;&gt; context.ModelState[k].Errors)</span><br><span class="line">            .Select(e &#x3D;&gt; e.ErrorMessage)</span><br><span class="line">            .ToArray();</span><br><span class="line"></span><br><span class="line">        var json &#x3D; new JsonErrorResponse</span><br><span class="line">        &#123;</span><br><span class="line">            Messages &#x3D; validationErrors</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        context.Result &#x3D; new BadRequestObjectResult(json);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="SwaggerUI认证授权集成"><a href="#SwaggerUI认证授权集成" class="headerlink" title="SwaggerUI认证授权集成"></a>SwaggerUI认证授权集成</h1><p>因为默认启用了安全认证，所以为了方便在SwaggerUI界面进行测试，那么我们就必须为其集成认证授权。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">services.AddSwaggerGen(options &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.DescribeAllEnumsAsStrings();</span><br><span class="line">    options.SwaggerDoc(&quot;v1&quot;, new Info</span><br><span class="line">    &#123;</span><br><span class="line">        Title &#x3D; &quot;Basket HTTP API&quot;,</span><br><span class="line">        Version &#x3D; &quot;v1&quot;,</span><br><span class="line">        Description &#x3D; &quot;The Basket Service HTTP API&quot;,</span><br><span class="line">        TermsOfService &#x3D; &quot;Terms Of Service&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">    options.AddSecurityDefinition(&quot;oauth2&quot;, new OAuth2Scheme</span><br><span class="line">    &#123;</span><br><span class="line">        Type &#x3D; &quot;oauth2&quot;,</span><br><span class="line">        Flow &#x3D; &quot;implicit&quot;,</span><br><span class="line">        AuthorizationUrl &#x3D; $&quot;&#123;Configuration.GetValue&lt;string&gt;(&quot;IdentityUrlExternal&quot;)&#125;&#x2F;connect&#x2F;authorize&quot;,</span><br><span class="line">        TokenUrl &#x3D; $&quot;&#123;Configuration.GetValue&lt;string&gt;(&quot;IdentityUrlExternal&quot;)&#125;&#x2F;connect&#x2F;token&quot;,</span><br><span class="line">        Scopes &#x3D; new Dictionary&lt;string, string&gt;()</span><br><span class="line">        &#123;</span><br><span class="line">            &#123; &quot;basket&quot;, &quot;Basket API&quot; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    options.OperationFilter&lt;AuthorizeCheckOperationFilter&gt;();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其中有主要做了三件事：</p>
<ol>
<li>配置授权Url</li>
<li>配置TokenUrl</li>
<li>指定授权范围</li>
<li>注入授权检查过滤器<code>AuthorizeCheckOperationFilter</code>用于拦截需要授权的请求<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AuthorizeCheckOperationFilter : IOperationFilter</span><br><span class="line">&#123;</span><br><span class="line">    public void Apply(Operation operation, OperationFilterContext context)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; Check for authorize attribute</span><br><span class="line">        var hasAuthorize &#x3D; context.ApiDescription.ControllerAttributes().OfType&lt;AuthorizeAttribute&gt;().Any() ||</span><br><span class="line">                           context.ApiDescription.ActionAttributes().OfType&lt;AuthorizeAttribute&gt;().Any();</span><br><span class="line">        if (hasAuthorize)</span><br><span class="line">        &#123;</span><br><span class="line">            operation.Responses.Add(&quot;401&quot;, new Response &#123; Description &#x3D; &quot;Unauthorized&quot; &#125;);</span><br><span class="line">            operation.Responses.Add(&quot;403&quot;, new Response &#123; Description &#x3D; &quot;Forbidden&quot; &#125;);</span><br><span class="line">            operation.Security &#x3D; new List&lt;IDictionary&lt;string, IEnumerable&lt;string&gt;&gt;&gt;();</span><br><span class="line">            operation.Security.Add(new Dictionary&lt;string, IEnumerable&lt;string&gt;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                &#123; &quot;oauth2&quot;, new [] &#123; &quot;basketapi&quot; &#125; &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1>本服务较之前讲的Catalog microservice 而言，主要是多了一个认证和redis存储。</li>
</ol>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>eShopOnContainers</tag>
      </tags>
  </entry>
  <entry>
    <title>eShopOnContainers 知多少[4]：Catalog microservice</title>
    <url>/post/eshoponcontainers-catalog-microservice-4/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Catalog microservice（目录微服务）维护着所有产品信息，包括库存、价格。所以该微服务的核心业务为：</p>
<ol>
<li>产品信息的维护</li>
<li>库存的更新</li>
<li>价格的维护</li>
</ol>
<h1 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h1><p><img src="/images/eshoponcontainers-catalog-microservice-4/2799767-8ee92fc413d17822.png" alt="数据驱动/CRUD 微服务设计"></p>
<p>如上图所示，本微服务采用简单的数据驱动的CRUD微服务架构，来执行产品信息的创建、读取、更新和删除（CRUD）操作。<br>这种类型的服务在单个 ASP.NET Core Web API 项目中即可实现所有功能，该项目包括数据模型类、业务逻辑类及其数据访问类。其项目结构如下：<br><img src="/images/eshoponcontainers-catalog-microservice-4/2799767-2283cbfdcc9a7271.png" alt=""></p>
<p>核心技术选型：</p>
<ol>
<li>ASP.NET Core Web API</li>
<li>Entity Framework Core</li>
<li>SQL Server </li>
<li>Swashbuckle（可选）</li>
<li>Autofac</li>
<li>Eventbus</li>
<li>Polly<h1 id="实体建模"><a href="#实体建模" class="headerlink" title="实体建模"></a>实体建模</h1>该微服务的核心领域实体是商品，其类图如下：<img src="/images/eshoponcontainers-catalog-microservice-4/2799767-0ffd78f8c096b32d.png" alt=""></li>
</ol>
<p>对于实体这一块，有两个小知识点需要说明一下：</p>
<ol>
<li>进行数据库字段映射时，主键都使用了<code>ForSqlServerUseSequenceHiLo</code>指定使用<code>HI-LO</code>高低位序列进行主键生成。</li>
<li>在进行种子数据的预置时，使用了<code>Polly</code>开启了Retry机制。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Policy CreatePolicy( ILogger&lt;CatalogContextSeed&gt; logger, string prefix,int retries &#x3D; 3)</span><br><span class="line">&#123;</span><br><span class="line">    return Policy.Handle&lt;SqlException&gt;().</span><br><span class="line">        WaitAndRetryAsync(</span><br><span class="line">            retryCount: retries,</span><br><span class="line">            sleepDurationProvider: retry &#x3D;&gt; TimeSpan.FromSeconds(5),</span><br><span class="line">            onRetry: (exception, timeSpan, retry, ctx) &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                logger.LogTrace($&quot;[&#123;prefix&#125;] Exception &#123;exception.GetType().Name&#125; with message $&#123;exception.Message&#125; detected on attempt &#123;retry&#125; of &#123;retries&#125;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">&#125;</span><br><span class="line">public async Task SeedAsync(CatalogContext context,IHostingEnvironment env,IOptions&lt;CatalogSettings&gt; settings,ILogger&lt;CatalogContextSeed&gt; logger)</span><br><span class="line">&#123;</span><br><span class="line">    var policy &#x3D; CreatePolicy(logger, nameof(CatalogContextSeed));</span><br><span class="line"></span><br><span class="line">    await policy.ExecuteAsync(async () &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;...</span><br><span class="line">    &#125;);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用NoTracking提升查询速度<br>在<code>CatalogController</code>的构造方法中，明确指定以下代码来进行查询优化，这一点也是我们值得学习的地方。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">((DbContext)context).ChangeTracker.QueryTrackingBehavior &#x3D; QueryTrackingBehavior.NoTracking;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="数据库表结构"><a href="#数据库表结构" class="headerlink" title="数据库表结构"></a>数据库表结构</h1><p><img src="/images/eshoponcontainers-catalog-microservice-4/2799767-fda90fdfdbaec4bb.png" alt="CatalogDb"><br>你肯定会好奇为什么会多了一张<code>IntegrationEventLog</code>表，这里先按住不表。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>如果eShopOnContainers采用的是单体式应用架构而非微服务架构，那么以上业务逻辑的实现并不复杂，使用简单的CRUD再辅以ACID事务就能很好的完成业务需求。本文的介绍也就可以到此为止了。</p>
<p>然而将其抽取出来成为独立的基础微服务，那么我们要考虑的问题就多了。比如：</p>
<ol>
<li>修改产品价格时，需要同步更新购物车中保存的产品信息的价格。</li>
<li>下订单时，需要验证当前商品库存是否充足，进行锁库抢占，以避免库存不足导致的订单无效。</li>
</ol>
<p>而这一切我们都不能再享受单体应用中直接使用ACID事务的便利了。因为在微服务应用里，产品表和购物篮表被各自的微服务所占有。任何微服务不应该在自己的事务中包含其他微服务的表或存储，即使是直接查询也是不可以的。目录微服务不能直接更新购物篮表，因为购物篮表被购物篮微服务占有。要更新购物篮微服务，产品微服务应该使用基于异步通信，如集成事件（消息和基于事件的通信）来实现最终一致性。</p>
<p>那下一节我们就来详细阐述eShopOnContainers是如何通过事件机制完成最终一致性的。</p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>eShopOnContainers</tag>
      </tags>
  </entry>
  <entry>
    <title>eShopOnContainers 知多少[11]：服务间通信之gRPC</title>
    <url>/post/eshoponcontainers-communication-with-grpc-11/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近翻看最新3.0 eShopOncontainers源码，发现其在架构选型中补充了 gRPC 进行服务间通信。那就索性也写一篇，作为系列的补充。</p>
<h1 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h1><p>老规矩，先来理一下gRPC的基本概念。gRPC是Google开源的RPC框架，比肩dubbo、thrift、brpc。其优势在于：</p>
<ol>
<li>基于proto buffer：二进制协议，具有高性能的序列化机制。相较于JSON（文本协议）而言，首先从数据包上就有60%-80%的减小，其次其解包速度仅需要简单的数学运算完成，无需复杂的词法语法分析，具有8倍以上的性能提升。</li>
<li>支持数据流。</li>
<li>基于proto 文件：可以更方便的在客户端和服务端之间进行交互。</li>
<li>gRPC语言无关性： 所有服务都是使用原型文件定义的。这些文件基于protobuffer语言，并定义服务的接口。基于原型文件，可以为每种语言生成用于创建服务端和客户端的代码。其中protoc编译工具就支持将其生成C #代码。从.NET Core 3 中，gRPC在工具和框架中深度集成，开发者会有更好的开发体验。</li>
</ol>
<h1 id="gRPC-在-eShopOncontainers-的应用"><a href="#gRPC-在-eShopOncontainers-的应用" class="headerlink" title="gRPC 在 eShopOncontainers 的应用"></a>gRPC 在 eShopOncontainers 的应用</h1><p>首先来理一下eShopOncontainers 中服务间同步通信的技术选型，主要还是是基于HTTP/REST，gRPC作为补充。</p>
<p>在eShopOncontainers中Ordering API、Catalog API、Basket API微服务通过gRPC端点暴露服务。其中Mobile Shopping、Web Shopping BFFs使用gRPC客户端访问服务。以下以Ordering API gRPC 服务举例说明。</p>
<p>订单微服务中定义了一个gRPC服务，用于从购物车创建订单。</p>
<h2 id="服务端实现"><a href="#服务端实现" class="headerlink" title="服务端实现"></a>服务端实现</h2><p>proto文件定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">option csharp_namespace &#x3D; &quot;GrpcOrdering&quot;;</span><br><span class="line">package OrderingApi;</span><br><span class="line">service OrderingGrpc &#123;</span><br><span class="line">  rpc CreateOrderDraftFromBasketData(CreateOrderDraftCommand) returns (OrderDraftDTO) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">message CreateOrderDraftCommand &#123;</span><br><span class="line">  string buyerId &#x3D; 1;</span><br><span class="line">    repeated BasketItem items &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">message BasketItem &#123;</span><br><span class="line">    string id &#x3D; 1;</span><br><span class="line">    int32 productId &#x3D; 2;</span><br><span class="line">    string productName &#x3D; 3;</span><br><span class="line">    double unitPrice &#x3D; 4;</span><br><span class="line">    double oldUnitPrice &#x3D; 5;</span><br><span class="line">    int32 quantity &#x3D; 6;</span><br><span class="line">    string pictureUrl &#x3D; 7;</span><br><span class="line">&#125;</span><br><span class="line">message OrderDraftDTO &#123;</span><br><span class="line">    double total &#x3D; 1;</span><br><span class="line">    repeated OrderItemDTO orderItems &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">message OrderItemDTO &#123;</span><br><span class="line">    int32 productId &#x3D; 1;</span><br><span class="line">    string productName &#x3D; 2;</span><br><span class="line">    double unitPrice &#x3D; 3;</span><br><span class="line">    double discount &#x3D; 4;</span><br><span class="line">    int32 units &#x3D; 5;</span><br><span class="line">    string pictureUrl &#x3D; 6;</span><br><span class="line">&#125;</span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>
<p>服务实现，主要是借助Mediator充当CommandBus进行命令分发，具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace GrpcOrdering</span><br><span class="line">&#123;</span><br><span class="line">    public class OrderingService : OrderingGrpc.OrderingGrpcBase</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly IMediator _mediator;</span><br><span class="line">        private readonly ILogger&lt;OrderingService&gt; _logger;</span><br><span class="line"></span><br><span class="line">        public OrderingService(IMediator mediator, ILogger&lt;OrderingService&gt; logger)</span><br><span class="line">        &#123;</span><br><span class="line">            _mediator &#x3D; mediator;</span><br><span class="line">            _logger &#x3D; logger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public override async Task&lt;OrderDraftDTO&gt; CreateOrderDraftFromBasketData(CreateOrderDraftCommand createOrderDraftCommand, ServerCallContext context)</span><br><span class="line">        &#123;</span><br><span class="line">            _logger.LogInformation(&quot;Begin gRPC call from method &#123;Method&#125; for ordering get order draft &#123;CreateOrderDraftCommand&#125;&quot;, context.Method, createOrderDraftCommand);</span><br><span class="line">            _logger.LogTrace(</span><br><span class="line">                &quot;----- Sending command: &#123;CommandName&#125; - &#123;IdProperty&#125;: &#123;CommandId&#125; (&#123;@Command&#125;)&quot;,</span><br><span class="line">                createOrderDraftCommand.GetGenericTypeName(),</span><br><span class="line">                nameof(createOrderDraftCommand.BuyerId),</span><br><span class="line">                createOrderDraftCommand.BuyerId,</span><br><span class="line">                createOrderDraftCommand);</span><br><span class="line"></span><br><span class="line">            var command &#x3D; new AppCommand.CreateOrderDraftCommand(</span><br><span class="line">                            createOrderDraftCommand.BuyerId,</span><br><span class="line">                            this.MapBasketItems(createOrderDraftCommand.Items));</span><br><span class="line">            var data &#x3D; await _mediator.Send(command);</span><br><span class="line"></span><br><span class="line">            if (data !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                context.Status &#x3D; new Status(StatusCode.OK, $&quot; ordering get order draft &#123;createOrderDraftCommand&#125; do exist&quot;);</span><br><span class="line"></span><br><span class="line">                return this.MapResponse(data);</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                context.Status &#x3D; new Status(StatusCode.NotFound, $&quot; ordering get order draft &#123;createOrderDraftCommand&#125; do not exist&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return new OrderDraftDTO();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public OrderDraftDTO MapResponse(AppCommand.OrderDraftDTO order)</span><br><span class="line">        &#123;</span><br><span class="line">            var result &#x3D; new OrderDraftDTO()</span><br><span class="line">            &#123;</span><br><span class="line">                Total &#x3D; (double)order.Total,</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            order.OrderItems.ToList().ForEach(i &#x3D;&gt; result.OrderItems.Add(new OrderItemDTO()</span><br><span class="line">            &#123;</span><br><span class="line">                Discount &#x3D; (double)i.Discount,</span><br><span class="line">                PictureUrl &#x3D; i.PictureUrl,</span><br><span class="line">                ProductId &#x3D; i.ProductId,</span><br><span class="line">                ProductName &#x3D; i.ProductName,</span><br><span class="line">                UnitPrice &#x3D; (double)i.UnitPrice,</span><br><span class="line">                Units &#x3D; i.Units,</span><br><span class="line">            &#125;));</span><br><span class="line"></span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public IEnumerable&lt;ApiModels.BasketItem&gt; MapBasketItems(RepeatedField&lt;BasketItem&gt; items)</span><br><span class="line">        &#123;</span><br><span class="line">            return items.Select(x &#x3D;&gt; new ApiModels.BasketItem()</span><br><span class="line">            &#123;</span><br><span class="line">                Id &#x3D; x.Id,</span><br><span class="line">                ProductId &#x3D; x.ProductId,</span><br><span class="line">                ProductName &#x3D; x.ProductName,</span><br><span class="line">                UnitPrice &#x3D; (decimal)x.UnitPrice,</span><br><span class="line">                OldUnitPrice &#x3D; (decimal)x.OldUnitPrice,</span><br><span class="line">                Quantity &#x3D; x.Quantity,</span><br><span class="line">                PictureUrl &#x3D; x.PictureUrl,</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，服务端还要注册gRPC的请求处理管道：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.UseEndpoints(endpoints &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    endpoints.MapDefaultControllerRoute();</span><br><span class="line">    endpoints.MapControllers();</span><br><span class="line">    endpoints.MapGrpcService&lt;OrderingService&gt;();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h2><p>接下来看下客户端[web.bff.shopping]怎么消费的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class OrderingService : IOrderingService</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly UrlsConfig _urls;</span><br><span class="line">        private readonly ILogger&lt;OrderingService&gt; _logger;</span><br><span class="line">        public readonly HttpClient _httpClient;</span><br><span class="line"></span><br><span class="line">        public OrderingService(HttpClient httpClient, IOptions&lt;UrlsConfig&gt; config, ILogger&lt;OrderingService&gt; logger)</span><br><span class="line">        &#123;</span><br><span class="line">            _urls &#x3D; config.Value;</span><br><span class="line">            _httpClient &#x3D; httpClient;</span><br><span class="line">            _logger &#x3D; logger;</span><br><span class="line">        &#125;</span><br><span class="line">        public async Task&lt;OrderData&gt; GetOrderDraftAsync(BasketData basketData)</span><br><span class="line">        &#123;</span><br><span class="line">            return await GrpcCallerService.CallService(_urls.GrpcOrdering, async channel &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                var client &#x3D; new OrderingGrpc.OrderingGrpcClient(channel);</span><br><span class="line">                _logger.LogDebug(&quot; gRPC client created, basketData&#x3D;&#123;@basketData&#125;&quot;, basketData);</span><br><span class="line">                var command &#x3D; MapToOrderDraftCommand(basketData);</span><br><span class="line">                var response &#x3D; await client.CreateOrderDraftFromBasketDataAsync(command);</span><br><span class="line">                _logger.LogDebug(&quot; gRPC response: &#123;@response&#125;&quot;, response);</span><br><span class="line"></span><br><span class="line">                return MapToResponse(response, basketData);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        private OrderData MapToResponse(GrpcOrdering.OrderDraftDTO orderDraft, BasketData basketData)</span><br><span class="line">        &#123;</span><br><span class="line">            if (orderDraft &#x3D;&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">            var data &#x3D; new OrderData</span><br><span class="line">            &#123;</span><br><span class="line">                Buyer &#x3D; basketData.BuyerId,</span><br><span class="line">                Total &#x3D; (decimal)orderDraft.Total,</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            orderDraft.OrderItems.ToList().ForEach(o &#x3D;&gt; data.OrderItems.Add(new OrderItemData</span><br><span class="line">            &#123;</span><br><span class="line">                Discount &#x3D; (decimal)o.Discount,</span><br><span class="line">                PictureUrl &#x3D; o.PictureUrl,</span><br><span class="line">                ProductId &#x3D; o.ProductId,</span><br><span class="line">                ProductName &#x3D; o.ProductName,</span><br><span class="line">                UnitPrice &#x3D; (decimal)o.UnitPrice,</span><br><span class="line">                Units &#x3D; o.Units,</span><br><span class="line">            &#125;));</span><br><span class="line">            return data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private CreateOrderDraftCommand MapToOrderDraftCommand(BasketData basketData)</span><br><span class="line">        &#123;</span><br><span class="line">            var command &#x3D; new CreateOrderDraftCommand</span><br><span class="line">            &#123;</span><br><span class="line">                BuyerId &#x3D; basketData.BuyerId,</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            basketData.Items.ForEach(i &#x3D;&gt; command.Items.Add(new BasketItem</span><br><span class="line">            &#123;</span><br><span class="line">                Id &#x3D; i.Id,</span><br><span class="line">                OldUnitPrice &#x3D; (double)i.OldUnitPrice,</span><br><span class="line">                PictureUrl &#x3D; i.PictureUrl,</span><br><span class="line">                ProductId &#x3D; i.ProductId,</span><br><span class="line">                ProductName &#x3D; i.ProductName,</span><br><span class="line">                Quantity &#x3D; i.Quantity,</span><br><span class="line">                UnitPrice &#x3D; (double)i.UnitPrice,</span><br><span class="line">            &#125;));</span><br><span class="line"></span><br><span class="line">            return command;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>GrpcCallerService</code>是对gRPC Client的一层封装，主要是为了解决未启用TLS无法使用gRPC的问题。</p>
<h2 id="不启用TLS使用gRPC"><a href="#不启用TLS使用gRPC" class="headerlink" title="不启用TLS使用gRPC"></a>不启用TLS使用gRPC</h2><p>我们已经知道gRpc 是基于HTTP2.0 协议。然而，连接的建立，默认并不是一步到位直接基于HTTP2.0建立连接的。客户端是先基于HTTP1.1进行协议协商，协商成功后，确认服务端支持HTTP2.0后，才会建立HTT2.0连接，协议协商需要TLS的ALPN协议来实现。流程如下：<br><img src="/images/eshoponcontainers-communication-with-grpc-11/2799767-0f9c300f468bd458.png" alt="HTTP2.0 协议协商"></p>
<p>这意味着，默认情况下，您需要启用TLS协议才能完成HTTP2.0协议协商，进而才能使用gRPC。</p>
<p>然而，在微服务架构中，并不是所有服务都需要启用安全传输层协议，尤其是微服务间的内部调用。那么在微服务内部如何使用gRPC进行通信呢？</p>
<p><strong>客户端绕过协议协商，直连HTTP2.0（前提是：服务端必须支持HTTP2.0）</strong>。</p>
<p>服务端配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WebHost.CreateDefaultBuilder(args)</span><br><span class="line">    .ConfigureKestrel(options &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        options.Listen(IPAddress.Any, ports.httpPort, listenOptions &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            listenOptions.Protocols &#x3D; HttpProtocols.Http1AndHttp2; &#x2F;&#x2F;同时监听协议HTTP1，HTTP2</span><br><span class="line">        &#125;);</span><br><span class="line">        options.Listen(IPAddress.Any, ports.gRPCPort, listenOptions &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            listenOptions.Protocols &#x3D; HttpProtocols.Http2; &#x2F;&#x2F; gRPC端口仅监听HTTP2.0</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<p>客户端需要添加以下设置，这些设置只能在客户端开始时设置一次：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AppContext.SetSwitch(&quot;System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport&quot;, true);</span><br><span class="line">AppContext.SetSwitch(&quot;System.Net.Http.SocketsHttpHandler.Http2Support&quot;, true);</span><br></pre></td></tr></table></figure>
<p>知道了这些，再回过来看<code>GrpcCallerService</code>的实现，就一目了然了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class GrpcCallerService</span><br><span class="line">&#123;</span><br><span class="line">    public static async Task&lt;TResponse&gt; CallService&lt;TResponse&gt;(string urlGrpc, Func&lt;GrpcChannel, Task&lt;TResponse&gt;&gt; func)</span><br><span class="line">    &#123;</span><br><span class="line">        AppContext.SetSwitch(&quot;System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport&quot;, true);</span><br><span class="line">        AppContext.SetSwitch(&quot;System.Net.Http.SocketsHttpHandler.Http2Support&quot;, true);</span><br><span class="line"></span><br><span class="line">        var channel &#x3D; GrpcChannel.ForAddress(urlGrpc);</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">        using var httpClientHandler &#x3D; new HttpClientHandler</span><br><span class="line">        &#123;</span><br><span class="line">            ServerCertificateCustomValidationCallback &#x3D; (message, cert, chain, errors) &#x3D;&gt; &#123; return true; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        *&#x2F;</span><br><span class="line"></span><br><span class="line">        Log.Information(@&quot;Creating gRPC client base address urlGrpc &#x3D;&#123;@urlGrpc&#125;, </span><br><span class="line">                          BaseAddress&#x3D;&#123;@BaseAddress&#125; &quot;, urlGrpc, channel.Target);</span><br><span class="line"></span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            return await func(channel);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (RpcException e)</span><br><span class="line">        &#123;</span><br><span class="line">            Log.Error(&quot;Error calling via gRPC: &#123;Status&#125; - &#123;Message&#125;&quot;, e.Status, e.Message);</span><br><span class="line">            return default;</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            AppContext.SetSwitch(&quot;System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport&quot;, false);</span><br><span class="line">            AppContext.SetSwitch(&quot;System.Net.Http.SocketsHttpHandler.Http2Support&quot;, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static async Task CallService(string urlGrpc, Func&lt;GrpcChannel, Task&gt; func)</span><br><span class="line">    &#123;</span><br><span class="line">        AppContext.SetSwitch(&quot;System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport&quot;, true);</span><br><span class="line">        AppContext.SetSwitch(&quot;System.Net.Http.SocketsHttpHandler.Http2Support&quot;, true);</span><br><span class="line"></span><br><span class="line">        &#x2F;*</span><br><span class="line">        using var httpClientHandler &#x3D; new HttpClientHandler</span><br><span class="line">        &#123;</span><br><span class="line">            ServerCertificateCustomValidationCallback &#x3D; (message, cert, chain, errors) &#x3D;&gt; &#123; return true; &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        *&#x2F;</span><br><span class="line"></span><br><span class="line">        var channel &#x3D; GrpcChannel.ForAddress(urlGrpc);</span><br><span class="line"></span><br><span class="line">        Log.Debug(&quot;Creating gRPC client base address &#123;@httpClient.BaseAddress&#125; &quot;, channel.Target);</span><br><span class="line"></span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            await func(channel);</span><br><span class="line">        &#125;</span><br><span class="line">        catch (RpcException e)</span><br><span class="line">        &#123;</span><br><span class="line">            Log.Error(&quot;Error calling via gRPC: &#123;Status&#125; - &#123;Message&#125;&quot;, e.Status, e.Message);</span><br><span class="line">        &#125;</span><br><span class="line">        finally</span><br><span class="line">        &#123;</span><br><span class="line">            AppContext.SetSwitch(&quot;System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport&quot;, false);</span><br><span class="line">            AppContext.SetSwitch(&quot;System.Net.Http.SocketsHttpHandler.Http2Support&quot;, false);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本文简要介绍了 eShopOnContainers 如何通过集成 gRPC 来完善服务间同步通信机制，希望对你在对微服务进行RPC相关技术选型时有一定的启示和帮助。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="http://www.blogjava.net/yongboy/archive/2015/03/18/423570.html" target="_blank" rel="noopener">HTTP2.0笔记之连接建立</a></li>
<li><a href="https://github.com/dotnet-architecture/eShopOnContainers/wiki/gRPC" target="_blank" rel="noopener">eShopOnContainers/wiki/gRPC</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/index.html" target="_blank" rel="noopener">Google Protocol Buffer 的使用和原理</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>eShopOnContainers</tag>
      </tags>
  </entry>
  <entry>
    <title>eShopOnContainers 知多少[10]：部署到 K8S | AKS</title>
    <url>/post/eshoponcontainers-deploy-to-k8s-10/</url>
    <content><![CDATA[<p><img src="/images/eshoponcontainers-deploy-to-k8s-10/2799767-e4080255dfd1a8e3.png" alt=""></p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>断断续续，感觉这个系列又要半途而废了。趁着假期，赶紧再更一篇，介绍下如何将eShopOnContainers部署到K8S上，进而实现大家常说的微服务上云。</p>
<h1 id="2-先了解下-Helm"><a href="#2-先了解下-Helm" class="headerlink" title="2. 先了解下 Helm"></a>2. 先了解下 Helm</h1><p>读过我上篇文章<a href="https://www.jianshu.com/p/6d39e935e66f" target="_blank" rel="noopener">ASP.NET Core 借助 K8S 玩转容器编排</a>的同学，想必对K8S有了个大致了解。K8S引入了Pod、Service、ReplicationSet等概念，来简化容器的编排工作。然而，发布一个应用，依旧很繁琐，比如要定义Pod，要关心如何暴露Service，如何自动伸缩。更不用说一个包括多个模块（Web、DB）的的复杂应用了，想一想要维护一堆<code>yaml</code>文件，就很奔溃。为了解决这一个问题，Helm横空出世。<br>Helm 简单来说就像NuGet包管理器，通过NuGet包管理器，我们可以很容易的管理依赖，借助它可以很方便的查找、安装、卸载、升级、降级需要的包。只不过Helm管理的包，叫做Helm Chart。<br>Chart 的包定义结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ helm create mongodb</span><br><span class="line">$ tree mongodb</span><br><span class="line">mongodb</span><br><span class="line">├── Chart.yaml #Chart本身的版本和配置信息</span><br><span class="line">├── charts #依赖的chart</span><br><span class="line">├── templates #配置模板目录</span><br><span class="line">│   ├── NOTES.txt #helm提示信息</span><br><span class="line">│   ├── _helpers.tpl #用于修改kubernetes objcet配置的模板</span><br><span class="line">│   ├── deployment.yaml #kubernetes Deployment object</span><br><span class="line">│   └── service.yaml #kubernetes Serivce</span><br><span class="line">└── values.yaml #kubernetes object configuration</span><br></pre></td></tr></table></figure>
<p>对于Helm，还有两个基本概念：Repository和Release。Repository是Helm Chart的存储仓库，Release是指Chart的部署实例。</p>
<p>另外，Helm包括两个部分：Client（客户端）和Tiller（服务端）。客户端用于管理Chart，服务端用于管理Release。</p>
<p><img src="/images/eshoponcontainers-deploy-to-k8s-10/2799767-73142a628a0eb701.png" alt="Helm Architecture"></p>
<p>从上面这张图中我们可以看到Tiller通过API与Kubernetes进行交互，来完成Chart包的部署。</p>
<p>以上就是Helm的简单介绍，若需深入了解，请访问官网<a href="www.helm.sh">Helm</a>。</p>
<h1 id="3-使用Helm-Chart-部署-eShopOnContainers-到-K8S"><a href="#3-使用Helm-Chart-部署-eShopOnContainers-到-K8S" class="headerlink" title="3. 使用Helm Chart 部署 eShopOnContainers 到 K8S"></a>3. 使用Helm Chart 部署 eShopOnContainers 到 K8S</h1><p>下面就直接按照装官方文档<a href="[https://github.com/dotnet-architecture/eShopOnContainers/wiki/10.-Deploying-to-Kubernetes-(AKS-and-local)-using-Helm-Charts](https://github.com/dotnet-architecture/eShopOnContainers/wiki/10.-Deploying-to-Kubernetes-(AKS-and-local)-using-Helm-Charts)">Deploying-to-Kubernetes-(AKS-and-local)-using-Helm-Charts</a>进行实操。</p>
<h2 id="3-1-安装Helm"><a href="#3-1-安装Helm" class="headerlink" title="3.1. 安装Helm"></a>3.1. 安装Helm</h2><p>毫无疑问，我们首先得本地安装Helm，建议直接使用<code>Chocolatey</code>安装，命令如下</p>
<figure class="highlight plain"><figcaption><span>install kubernetes-helm```。</span></figcaption><table><tr><td class="code"><pre><span class="line">在K8S中提供了认证机制，以确保应用程序的安全访问。Tiller要想与K8S建立连接进行交互，就必须提前在K8S中创建一个ServiceAccount并分配给Tiller以完成基于角色的访问控制（RBAC）。</span><br></pre></td></tr></table></figure>
<h1 id="在k8s目录下执行以下命令，完成ServiceAccount的创建"><a href="#在k8s目录下执行以下命令，完成ServiceAccount的创建" class="headerlink" title="在k8s目录下执行以下命令，完成ServiceAccount的创建"></a>在k8s目录下执行以下命令，完成ServiceAccount的创建</h1><p>$ kubectl apply -f helm-rbac.yaml # 创建名为tiller的ServiceAccount</p>
<h1 id="安装Tiller（Helm服务端），并指定使用上面创建的ServiceAccount"><a href="#安装Tiller（Helm服务端），并指定使用上面创建的ServiceAccount" class="headerlink" title="安装Tiller（Helm服务端），并指定使用上面创建的ServiceAccount"></a>安装Tiller（Helm服务端），并指定使用上面创建的ServiceAccount</h1><p>$ helm init –service-account tiller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 3.2. 安装 Nginx ingress controller</span><br><span class="line">Ingress是用来暴露服务的，本质上和Service类似，但是一个Service只可以暴露一个服务，而一个Ingress可以暴露多个服务，Ingress可以根据请求的主机名和路径进行请求转发。但创建Ingress的前提是K8S必须已经有相应的Ingress Controller运行。然而，Dockers-For-Windows中默认并未提供Ingress Controller。我们可以在&#96;&#x2F;k8s&#96;目录下执行以下脚本，以安装&#96;Nginx ingress controller。</span><br></pre></td></tr></table></figure>
<p>$ .\deploy-ingress.ps1<br>$ .\deploy-ingress-dockerlocal.ps1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 3.3. 使用 Helm 部署 eShopOnContainers</span><br><span class="line">在项目&#96;k8s\Helm&#96;文件夹下，已经分别为eShopOnContainers的各个部分定义了相应的Chart，如下图所示。</span><br><span class="line">![Chart List](&#x2F;images&#x2F;eshoponcontainers-deploy-to-k8s-10&#x2F;2799767-33d157d074a86372.png)</span><br><span class="line"></span><br><span class="line">仅需执行&#96;.\deploy-all.ps1 -imageTag dev -useLocalk8s $true&#96;</span><br><span class="line">脚本，即可一键部署。等脚本执行完毕，可以执行&#96;helm list&#96;来查看所有的release。</span><br></pre></td></tr></table></figure>
<p>$ helm list<br>NAME                            REVISION        UPDATED                         STATUS          CHART                           APP VERSION     NAMESPACE<br>eshop-apigwmm                   1               Fri Apr  5 16:55:45 2019        DEPLOYED        apigwmm-0.1.0                   1.0             default<br>eshop-apigwms                   1               Fri Apr  5 16:55:46 2019        DEPLOYED        apigwms-0.1.0                   1.0             default<br>eshop-apigwwm                   1               Fri Apr  5 16:55:47 2019        DEPLOYED        apigwwm-0.1.0                   1.0             default<br>eshop-apigwws                   1               Fri Apr  5 16:55:48 2019        DEPLOYED        apigwws-0.1.0                   1.0             default<br>eshop-basket-api                1               Fri Apr  5 16:55:49 2019        DEPLOYED        basket-api-0.1.0                1.0             default<br>eshop-basket-data               1               Fri Apr  5 16:55:44 2019        DEPLOYED        basket-data-0.1.0               1.0             default<br>eshop-catalog-api               1               Fri Apr  5 16:55:50 2019        DEPLOYED        catalog-api-0.1.0               1.0             default<br>eshop-identity-api              1               Fri Apr  5 16:55:51 2019        DEPLOYED        identity-api-0.1.0              1.0             default<br>eshop-keystore-data             1               Fri Apr  5 16:55:43 2019        DEPLOYED        keystore-data-0.1.0             1.0             default<br>eshop-locations-api             1               Fri Apr  5 16:55:52 2019        DEPLOYED        locations-api-0.1.0             1.0             default<br>eshop-marketing-api             1               Fri Apr  5 16:55:53 2019        DEPLOYED        marketing-api-0.1.0             1.0             default<br>eshop-mobileshoppingagg         1               Fri Apr  5 16:55:54 2019        DEPLOYED        mobileshoppingagg-0.1.0         1.0             default<br>eshop-nosql-data                1               Fri Apr  5 16:55:42 2019        DEPLOYED        nosql-data-0.1.0                1.0             default<br>eshop-ordering-api              1               Fri Apr  5 16:55:55 2019        DEPLOYED        ordering-api-0.1.0              1.0             default<br>eshop-ordering-backgroundtasks  1               Fri Apr  5 16:55:56 2019        DEPLOYED        ordering-backgroundtasks-0.1.0  1.0             default<br>eshop-ordering-signalrhub       1               Fri Apr  5 16:55:57 2019        DEPLOYED        ordering-signalrhub-0.1.0       1.0             default<br>eshop-payment-api               1               Fri Apr  5 16:55:58 2019        DEPLOYED        payment-api-0.1.0               1.0             default<br>eshop-rabbitmq                  1               Fri Apr  5 16:55:42 2019        DEPLOYED        rabbitmq-0.1.0                  1.0             default<br>eshop-sql-data                  1               Fri Apr  5 16:55:41 2019        DEPLOYED        sql-data-0.1.0                  1.0             default<br>eshop-webhooks-api              1               Fri Apr  5 16:56:03 2019        DEPLOYED        webhooks-api-0.1.0              1.0             default<br>eshop-webhooks-web              1               Fri Apr  5 16:56:04 2019        DEPLOYED        webhooks-web-0.1.0              1.0             default<br>eshop-webmvc                    1               Fri Apr  5 16:55:59 2019        DEPLOYED        webmvc-0.1.0                    1.0             default<br>eshop-webshoppingagg            1               Fri Apr  5 16:56:00 2019        DEPLOYED        webshoppingagg-0.1.0            1.0             default<br>eshop-webspa                    1               Fri Apr  5 16:56:01 2019        DEPLOYED        webspa-0.1.0                    1.0             default<br>eshop-webstatus                 1               Fri Apr  5 16:56:02 2019        DEPLOYED        webstatus-0.1.0                 1.0             default</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 3.4. 验证部署</span><br><span class="line">使用&#96;kubectl get deployment&#96;可以查看所有的弹性部署，使用&#96;kubectl get ingress&#96;可以查看通过ingress暴露的所有服务，使用&#96;kubectl get pod&#96;，可以查看所有运行的pod，等所有的pod的STATUS均为Running时，就可以直接通过[http:&#x2F;&#x2F;localhost](http:&#x2F;&#x2F;localhost)访问应用了，也可以访问[http:&#x2F;&#x2F;localhost&#x2F;webstatus](http:&#x2F;&#x2F;localhost&#x2F;webstatus)监控应用运行状态。</span><br><span class="line"></span><br><span class="line">至此，已成功部署eShopOnContainers到本地K8S集群。</span><br><span class="line"></span><br><span class="line"># 4. 上云</span><br><span class="line">微服务不上云简直就是浪费感情。有了本地部署的经验，那么部署上云也就简单了。除了需要额外创建并配置AKS（Azure Kubernetes Service）外，其他步骤都如出一辙。</span><br><span class="line">下面就来梳理下如何部署应用到AKS集群上。</span><br><span class="line"></span><br><span class="line">*首先你得有Azure账号，这是第一步，如果没有请自行前往[https:&#x2F;&#x2F;azure.microsoft.com&#x2F;zh-cn&#x2F;](https:&#x2F;&#x2F;azure.microsoft.com&#x2F;zh-cn&#x2F;)申请免费账号把玩。*</span><br><span class="line"></span><br><span class="line">## 4.1. 创建AKS</span><br><span class="line">创建AKS有两种方式一种是基于&#96;Azure CLI&#96;，一种是直接通过门户网站直接创建。这里使用第一种方式。</span><br><span class="line">首先确保本地安装Azure CLI，可使用&#96;choco install azure-cli&#96;安装。下面直接通过命令演示。</span><br></pre></td></tr></table></figure>
<p>$ az login #登录Azure，完成客户端认证<br>$ az group create –name aks-group –location eastasia #在East Asia 创建资源组<br>$ az aks create <code>--resource-group aks-group</code><br>–name eshop <code>--node-count 1</code><br>–enable-addons http_application_routing,monitoring ` # 启用Http Routing（包含Ingress Controller和External-DNS)和监控<br>–generate-ssh-keys # 创建 ask 集群<br>$ az aks get-credentials –resource-group aks-group –name eshop # 获取证书以便从本地连接到AKS集群<br>$ kubectl config current-context # 查看当前上下文是不是eshop<br>$ kubectl get nodes # 获取aks集群节点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 4.2. AKS 中安装 Helm</span><br><span class="line">AKS上和本机一样需要安装Helm，不过AKS上主要是要用到服务端（Tiller）以便进行Release的管理。不过好消息是AKS上Helm Client默认已经安装好了，所以只需要安装Tiller就Ok了。</span><br><span class="line">1. 首先创建ServiceAccount，用于K8S与Tiller的认证</span><br><span class="line">我们可以简单使用项目k8s文件夹下现有的&#96;helm-rbac.yaml&#96;来创建ServiceAccount。直接执行&#96;kubectl apply -f .\helm-rbac.yaml&#96;。</span><br><span class="line">2. 创建Tiller</span><br><span class="line">&#96;&#96;&#96;helm init --service-account tiller #指定使用上面创建的ServiceAccount</span><br></pre></td></tr></table></figure>

<h2 id="4-3-部署-eShopOnContainers-到-AKS"><a href="#4-3-部署-eShopOnContainers-到-AKS" class="headerlink" title="4.3. 部署 eShopOnContainers 到 AKS"></a>4.3. 部署 eShopOnContainers 到 AKS</h2><p><code>k8s/helm</code>文件夹打开Powershell执行以下脚本即可一键部署：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .\deploy-all.ps1 -externalDns aks -aksName eshop -aksRg aks-group -imageTag dev</span><br></pre></td></tr></table></figure>

<h2 id="4-4-验证部署"><a href="#4-4-验证部署" class="headerlink" title="4.4. 验证部署"></a>4.4. 验证部署</h2><p>执行<code>kubectl get ingress</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl get ingress</span><br><span class="line">NAME                 HOSTS                                           ADDRESS       PORTS     AGE</span><br><span class="line">eshop-apigwmm        eshop.23a0868cb60a45e18d24.eastasia.aksapp.io   13.70.31.45   80        45s</span><br><span class="line">eshop-apigwms        eshop.23a0868cb60a45e18d24.eastasia.aksapp.io   13.70.31.45   80        44s</span><br><span class="line">eshop-apigwwm        eshop.23a0868cb60a45e18d24.eastasia.aksapp.io   13.70.31.45   80        42s</span><br><span class="line">eshop-apigwws        eshop.23a0868cb60a45e18d24.eastasia.aksapp.io   13.70.31.45   80        41s</span><br><span class="line">eshop-identity-api   eshop.23a0868cb60a45e18d24.eastasia.aksapp.io   13.70.31.45   80        38s</span><br><span class="line">eshop-webhooks-api   eshop.23a0868cb60a45e18d24.eastasia.aksapp.io   13.70.31.45   80        24s</span><br><span class="line">eshop-webhooks-web   eshop.23a0868cb60a45e18d24.eastasia.aksapp.io   13.70.31.45   80        23s</span><br><span class="line">eshop-webmvc         eshop.23a0868cb60a45e18d24.eastasia.aksapp.io   13.70.31.45   80        29s</span><br><span class="line">eshop-webspa         eshop.23a0868cb60a45e18d24.eastasia.aksapp.io   13.70.31.45   80        27s</span><br><span class="line">eshop-webstatus      eshop.23a0868cb60a45e18d24.eastasia.aksapp.io   13.70.31.45   80        25s</span><br></pre></td></tr></table></figure>
<p>等所有的pod都处于Running状态时，就可以直接通过Hosts：<a href="http://eshop.23a0868cb60a45e18d24.eastasia.aksapp.io/" target="_blank" rel="noopener">eshop.23a0868cb60a45e18d24.eastasia.aksapp.io</a><br>来访问应用了。<br>如果测试登录，可能会遭遇<code>502 Bad Gateway</code>，这是因为Identity Server 发送的请求头数据包超过了AKS中Nginx Ingress Controller的默认设置，可以直接<code>/k8s/helm</code>目录执行<code>kubectl apply -f aks-httpaddon-cfg.yaml</code>来解决这个问题。</p>
<p>玩耍了一段时间后，别忘了清理资源，毕竟上云是要RMB的啊。执行<code>az group delete -n aks-group</code>，删除最开始创建的资源组。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>That’s all？<br>虽然成功将eShopOnContainers部署到云上，但一点也高兴不起来。从开发到部署再到运维，发现到处都是学不完的技术债。哎，谁让你当初非要当程序员呢？</p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>eShopOnContainers</tag>
      </tags>
  </entry>
  <entry>
    <title>eShopOnContainers 知多少[12]：Envoy gateway</title>
    <url>/post/eshoponcontainers-envoy-gateway-12/</url>
    <content><![CDATA[<p><img src="/images/eshoponcontainers-envoy-gateway-12/2799767-907fa556a105bc40.png" alt=""></p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>在最新的eShopOnContainers  3.0 中Ocelot 网关被Envoy Proxy 替换。下面就来简要带大家了解下Envoy，并尝试梳理下为什么要使用Envoy替代Ocelot。</p>
<h1 id="2-Hello-Envoy"><a href="#2-Hello-Envoy" class="headerlink" title="2. Hello Envoy"></a>2. Hello Envoy</h1><blockquote>
<p><strong><a href="https://www.envoyproxy.io" target="_blank" rel="noopener">ENVOY</a></strong> IS AN OPEN SOURCE EDGE AND SERVICE PROXY, DESIGNED FOR CLOUD-NATIVE APPLICATIONS.<br><em>Enovy(信使) 是一款开源的专为云原生应用设计的服务代理</em>。</p>
</blockquote>
<h2 id="2-1-快速体验"><a href="#2-1-快速体验" class="headerlink" title="2.1. 快速体验"></a>2.1. 快速体验</h2><p>首先基于本地Dockers快速体验以下，先启动本地Docker-Desktop，拉取Envoy镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; docker search envoy-dev</span><br><span class="line">NAME                        DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">envoyproxy&#x2F;envoy            Images for tagged releases. Use envoy-dev fo…   96</span><br><span class="line">&gt; docker image pull envoyproxy:envoy-dev</span><br><span class="line">latest: Pulling from envoyproxy&#x2F;envoy-dev</span><br><span class="line">171857c49d0f: Pull complete</span><br><span class="line">419640447d26: Pull complete</span><br><span class="line">61e52f862619: Pull complete</span><br><span class="line">3f2a8c910457: Pull complete</span><br><span class="line">b2ce823b3fd3: Pull complete</span><br><span class="line">ec09faba9bc7: Pull complete</span><br><span class="line">b0b9168845d0: Pull complete</span><br><span class="line">39a220277151: Pull complete</span><br><span class="line">9081a11f5983: Pull complete</span><br><span class="line">1880b475bc3a: Pull complete</span><br><span class="line">Digest: sha256:cd8dbbbd8ce4c8c6eb52e4f8eebf55f29d1e597ca8311fecf9eda08b8cca813a</span><br><span class="line">Status: Downloaded newer image for envoyproxy&#x2F;envoy-dev:latest</span><br><span class="line">docker.io&#x2F;envoyproxy&#x2F;envoy-dev:latest</span><br></pre></td></tr></table></figure>
<p>该Docker 镜像将包含最新版本的 Envoy 和一个基本的 Envoy 配置，可以将10000端口的入站请求路由到<code>www.google.com</code>。<br>下面启动容器测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; docker run -d --name envoy -p 10000:10000 envoyproxy&#x2F;envoy-dev:latest</span><br><span class="line">27e422f34b389d99e9180e47d8109a19975ccd139f42ac2f4fa9f724906b72f6</span><br><span class="line">&gt; docker ps | findstr &#39;envoy&#39;</span><br><span class="line">27e422f34b38        envoyproxy&#x2F;envoy-dev:latest   &quot;&#x2F;docker-entrypoint.??   2 minutes ago        Up 2 minutes       0.0.0.0:10000-&gt;10000&#x2F;tcp   envoy</span><br><span class="line">&gt; curl -I http:&#x2F;&#x2F;localhost:10000</span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">content-type: text&#x2F;html; charset&#x3D;ISO-8859-1</span><br><span class="line">p3p: CP&#x3D;&quot;This is not a P3P policy! See g.co&#x2F;p3phelp for more info.&quot;</span><br><span class="line">date: Sat, 17 Oct 2020 04:38:38 GMT</span><br><span class="line">server: envoy</span><br><span class="line">x-xss-protection: 0</span><br><span class="line">x-frame-options: SAMEORIGIN</span><br><span class="line">expires: Sat, 17 Oct 2020 04:38:38 GMT</span><br><span class="line">cache-control: private</span><br><span class="line">set-cookie: 1P_JAR&#x3D;2020-10-17-04; expires&#x3D;Mon, 16-Nov-2020 04:38:38 GMT; path&#x3D;&#x2F;; domain&#x3D;.google.com; Secure</span><br><span class="line">set-cookie: NID&#x3D;204&#x3D;h0EoJXNOTbQA11L-tVowqcwloS0-BCTR71IeN4irsmpubdPIIS4sU8Gco79pt1NhONAxxFdUJ46SKvbX4Ni-jKMWbSW0k_kn3fFkVrfLm7OOBbAtUWtxGGOCRJGbSNIRyOPfDB7_wMngEWW3yoFEs9diSCtZK9DWFZdtJJZtWuI; expires&#x3D;Sun, 18-Apr-2021 04:38:38 GMT; path&#x3D;&#x2F;; domain&#x3D;.google.com; HttpOnly</span><br><span class="line">alt-svc: h3-Q050&#x3D;&quot;:443&quot;; ma&#x3D;2592000,h3-29&#x3D;&quot;:443&quot;; ma&#x3D;2592000,h3-27&#x3D;&quot;:443&quot;; ma&#x3D;2592000,h3-T051&#x3D;&quot;:443&quot;; ma&#x3D;2592000,h3-T050&#x3D;&quot;:443&quot;; ma&#x3D;2592000,h3-Q046&#x3D;&quot;:443&quot;; ma&#x3D;2592000,h3-Q043&#x3D;&quot;:443&quot;; ma&#x3D;2592000,quic&#x3D;&quot;:443&quot;; ma&#x3D;2592000; v&#x3D;&quot;46,43&quot;</span><br><span class="line">x-envoy-upstream-service-time: 37</span><br><span class="line">transfer-encoding: chunked</span><br></pre></td></tr></table></figure>
<p><em>PS: 请确保本地机器能访问Google，否则<code>curl -I http://localhost:10000</code> 会出错。</em></p>
<p>接下来我们进入容器内部，查看下配置文件，默认路径为<code>/etc/envoy/envoy.yaml</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it envoy &#x2F;bin&#x2F;bash</span><br><span class="line">root@27e422f34b38:&#x2F;# cat &#x2F;etc&#x2F;envoy&#x2F;envoy.yaml</span><br><span class="line">admin:</span><br><span class="line">  access_log_path: &#x2F;tmp&#x2F;admin_access.log</span><br><span class="line">  address:</span><br><span class="line">    socket_address:</span><br><span class="line">      protocol: TCP</span><br><span class="line">      address: 127.0.0.1</span><br><span class="line">      port_value: 9901</span><br><span class="line">static_resources:</span><br><span class="line">  listeners:</span><br><span class="line">  - name: listener_0</span><br><span class="line">    address:</span><br><span class="line">      socket_address:</span><br><span class="line">        protocol: TCP</span><br><span class="line">        address: 0.0.0.0</span><br><span class="line">        port_value: 10000</span><br><span class="line">    filter_chains:</span><br><span class="line">    - filters:</span><br><span class="line">      - name: envoy.filters.network.http_connection_manager</span><br><span class="line">        typed_config:</span><br><span class="line">          &quot;@type&quot;: type.googleapis.com&#x2F;envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager</span><br><span class="line">          stat_prefix: ingress_http</span><br><span class="line">          route_config:</span><br><span class="line">            name: local_route</span><br><span class="line">            virtual_hosts:</span><br><span class="line">            - name: local_service</span><br><span class="line">              domains: [&quot;*&quot;]</span><br><span class="line">              routes:</span><br><span class="line">              - match:</span><br><span class="line">                  prefix: &quot;&#x2F;&quot;</span><br><span class="line">                route:</span><br><span class="line">                  host_rewrite_literal: www.google.com</span><br><span class="line">                  cluster: service_google</span><br><span class="line">          http_filters:</span><br><span class="line">          - name: envoy.filters.http.router</span><br><span class="line">  clusters:</span><br><span class="line">  - name: service_google</span><br><span class="line">    connect_timeout: 30s</span><br><span class="line">    type: LOGICAL_DNS</span><br><span class="line">    # Comment out the following line to test on v6 networks</span><br><span class="line">    dns_lookup_family: V4_ONLY</span><br><span class="line">    lb_policy: ROUND_ROBIN</span><br><span class="line">    load_assignment:</span><br><span class="line">      cluster_name: service_google</span><br><span class="line">      endpoints:</span><br><span class="line">      - lb_endpoints:</span><br><span class="line">        - endpoint:</span><br><span class="line">            address:</span><br><span class="line">              socket_address:</span><br><span class="line">                address: www.google.com</span><br><span class="line">                port_value: 443</span><br><span class="line">    transport_socket:</span><br><span class="line">      name: envoy.transport_sockets.tls</span><br><span class="line">      typed_config:</span><br><span class="line">        &quot;@type&quot;: type.googleapis.com&#x2F;envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext</span><br><span class="line">        sni: www.google.com</span><br></pre></td></tr></table></figure>

<p>我们把上面的配置文件拷贝到本地，将上面的<code>www.google.com</code>改为<code>www.baidu.com</code>，将<code>admin.address.socket_address.address: 127.0.0.1</code>该为<code>0.0.0.0</code>，然后把配置文件命名为<code>envoy-baidu.yaml</code>，然后挂载到容器的<code>/etc/envoy/envoy.yaml</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; docker run --rm -d --name envoy-baidu -v $Home&#x2F;k8s&#x2F;envoy-baidu.yaml:&#x2F;etc&#x2F;envoy&#x2F;envoy.yaml -p 9901:9901 -p 15001:15001 envoyproxy&#x2F;envoy-dev:latest</span><br><span class="line">&gt; docker ps | findstr &#39;envoy&#39;</span><br><span class="line">f07f6a1e9305        envoyproxy&#x2F;envoy-dev:latest   &quot;&#x2F;docker-entrypoint.??   2 minutes ago       Up 2 minutes        10000&#x2F;tcp, 0.0.0.0:9901-&gt;9901&#x2F;tcp, 0.0.0.0:15001-&gt;15001&#x2F;tcp   envoy-baidu</span><br><span class="line">3cd12b5f6ddd        envoyproxy&#x2F;envoy-dev:latest   &quot;&#x2F;docker-entrypoint.??   About an hour ago   Up About an hour    0.0.0.0:10000-&gt;10000&#x2F;tcp              envoy</span><br><span class="line">&gt; curl -I http:&#x2F;&#x2F;localhost:15001</span><br><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">accept-ranges: bytes</span><br><span class="line">cache-control: private, no-cache, no-store, proxy-revalidate, no-transform</span><br><span class="line">content-length: 277</span><br><span class="line">content-type: text&#x2F;html</span><br><span class="line">date: Sat, 17 Oct 2020 05:41:01 GMT</span><br><span class="line">etag: &quot;575e1f65-115&quot;</span><br><span class="line">last-modified: Mon, 13 Jun 2016 02:50:13 GMT</span><br><span class="line">pragma: no-cache</span><br><span class="line">server: envoy</span><br><span class="line">x-envoy-upstream-service-time: 24</span><br></pre></td></tr></table></figure>
<p>使用浏览器访问<a href="http://localhost:9901即可访问envoy管理页面，如下图所示：">http://localhost:9901即可访问envoy管理页面，如下图所示：</a><br><img src="/images/eshoponcontainers-envoy-gateway-12/2799767-799930f950c87a20.png" alt="envoy admin page"></p>
<h2 id="2-2-配置简介"><a href="#2-2-配置简介" class="headerlink" title="2.2. 配置简介"></a>2.2. 配置简介</h2><p>第一次看Envoy的配置文件，和第一次接触Nginx的配置文件一样，绝对一脸懵逼。没关系，咱们来理一理。</p>
<p>作为一个代理，不管是Nginx、HAProxy，还是Envoy，其处理流程都是一样的。其首先都是要监听指定端口获取请求流量，然后分析请求数据，进行请求转发。脑补完大致流程后，再来看 Envoy 是如何组织配置信息的。先来了几个核心配置：</p>
<ul>
<li><strong>listener</strong> : Envoy 的监听地址，用来接收请求，处理入站请求。Envoy 会暴露一个或多个 Listener 来监听客户端的请求。</li>
<li><strong>filter</strong> : 过滤器是处理入站和出站流量的链式结构的一部分。在过滤器链上可以集成很多特定功能的过滤器，例如，通过集成 GZip 过滤器可以在数据发送到客户端之前压缩数据。</li>
<li><strong>route_config</strong> : 路由规则配置。即将请求路由到后端的哪个集群。</li>
<li><strong>cluster</strong> : 集群定义了流量的目标端点，同时还包括一些其他可选配置，如负载均衡策略等。</li>
</ul>
<p>整体流程如下图所示：</p>
<p><img src="/images/eshoponcontainers-envoy-gateway-12/2799767-51ed0f50d336c308.png" alt="图片来源：https://fuckcloudnative.io/envoy-handbook/docs/gettingstarted/quick-start/"></p>
<h2 id="2-3-代理-ASP-NET-Core-WebApi"><a href="#2-3-代理-ASP-NET-Core-WebApi" class="headerlink" title="2.3. 代理 ASP.NET Core WebApi"></a>2.3. 代理 ASP.NET Core WebApi</h2><p>有了上面的基础，下面尝试使用Envoy代理ASP.NET Core WebApi。<br>首先创建两个简单API，然后创建一个Envoy配置文件，最后通过docker compose启动三个容器进行测试。由于项目文件结构简单，这里不再过多阐述，主要包含四个部分：</p>
<ol>
<li>City Api</li>
<li>Weather Api</li>
<li>Envoy 代理配置</li>
<li>docker compose 配置</li>
</ol>
<p>整体解决方案如下图所示。源码路径：<a href="https://github.com/sheng-jie/dotnet.on.k8s/tree/master/K8S.NET.Envoy" target="_blank" rel="noopener">K8S.NET.Envoy</a>。</p>
<p><img src="/images/eshoponcontainers-envoy-gateway-12/2799767-dcab57e426d6dcc0.png" alt=""></p>
<p>Envoy 代理配置基于第一节的基础上进行修改，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin:</span><br><span class="line">  access_log_path: &#x2F;tmp&#x2F;admin_access.log</span><br><span class="line">  address:</span><br><span class="line">    socket_address:</span><br><span class="line">      protocol: TCP</span><br><span class="line">      address: 0.0.0.0</span><br><span class="line">      port_value: 9903</span><br><span class="line">static_resources:</span><br><span class="line">  listeners:</span><br><span class="line">    - name: listener_0</span><br><span class="line">      address:</span><br><span class="line">        socket_address:</span><br><span class="line">          protocol: TCP</span><br><span class="line">          address: 0.0.0.0</span><br><span class="line">          port_value: 10003</span><br><span class="line">      filter_chains:</span><br><span class="line">        - filters:</span><br><span class="line">            - name: envoy.filters.network.http_connection_manager</span><br><span class="line">              typed_config:</span><br><span class="line">                &quot;@type&quot;: type.googleapis.com&#x2F;envoy.config.filter.network.http_connection_manager.v2.HttpConnectionManager</span><br><span class="line">                stat_prefix: ingress_http</span><br><span class="line">                route_config:</span><br><span class="line">                  name: local_route</span><br><span class="line">                  virtual_hosts:</span><br><span class="line">                    - name: local_service</span><br><span class="line">                      domains: [&quot;*&quot;]</span><br><span class="line">                      routes:</span><br><span class="line">                        - match:</span><br><span class="line">                            prefix: &quot;&#x2F;c&quot;</span><br><span class="line">                          route:</span><br><span class="line">                            prefix_rewrite: &quot;&#x2F;city&quot;</span><br><span class="line">                            cluster: city_service</span><br><span class="line">                        - match:</span><br><span class="line">                            prefix: &quot;&#x2F;w&quot;</span><br><span class="line">                          route:</span><br><span class="line">                            prefix_rewrite: &quot;&#x2F;weather&quot;</span><br><span class="line">                            cluster: weather_service</span><br><span class="line">                http_filters:</span><br><span class="line">                  - name: envoy.filters.http.router</span><br><span class="line">  clusters:</span><br><span class="line">    - name: city_service</span><br><span class="line">      connect_timeout: 0.25s</span><br><span class="line">      type: LOGICAL_DNS</span><br><span class="line">      # Comment out the following line to test on v6 networks</span><br><span class="line">      dns_lookup_family: V4_ONLY</span><br><span class="line">      lb_policy: ROUND_ROBIN</span><br><span class="line">      load_assignment:</span><br><span class="line">        cluster_name: city_service</span><br><span class="line">        endpoints:</span><br><span class="line">          - lb_endpoints:</span><br><span class="line">              - endpoint:</span><br><span class="line">                  address:</span><br><span class="line">                    socket_address:</span><br><span class="line">                      address: cityapi</span><br><span class="line">                      port_value: 80</span><br><span class="line">    - name: weather_service</span><br><span class="line">      connect_timeout: 0.25s</span><br><span class="line">      type: LOGICAL_DNS</span><br><span class="line">      # Comment out the following line to test on v6 networks</span><br><span class="line">      dns_lookup_family: V4_ONLY</span><br><span class="line">      lb_policy: ROUND_ROBIN</span><br><span class="line">      load_assignment:</span><br><span class="line">        cluster_name: weather_service</span><br><span class="line">        endpoints:</span><br><span class="line">          - lb_endpoints:</span><br><span class="line">              - endpoint:</span><br><span class="line">                  address:</span><br><span class="line">                    socket_address:</span><br><span class="line">                      address: weatherapi</span><br><span class="line">                      port_value: 80</span><br></pre></td></tr></table></figure>
<p>以上配置Envoy监听<code>10003</code>端口，通过指定<code>prefix_rewrite</code>重写前缀，将<code>/c</code>路由至<code>cityapi</code>的<code>/city</code>路径，将<code>/w</code>路由至<code>weatherapi</code>的<code>/weather</code>路径。</p>
<p>docker-compose配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">  envoygateway:</span><br><span class="line">    build: Envoy&#x2F;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;9903:9903&quot;</span><br><span class="line">      - &quot;10003:10003&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;Envoy&#x2F;envoy.yaml:&#x2F;etc&#x2F;envoy&#x2F;envoy.yaml</span><br><span class="line">  cityapi:</span><br><span class="line">    build: K8S.NET.CityApi&#x2F;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:80&quot;</span><br><span class="line">    environment:</span><br><span class="line">      ASPNETCORE_URLS: &quot;http:&#x2F;&#x2F;+&quot;</span><br><span class="line">      ASPNETCORE_ENVIRONMENT: &quot;Development&quot;</span><br><span class="line"></span><br><span class="line">  weatherapi:</span><br><span class="line">    build: K8S.NET.WeatherApi&#x2F;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8082:80&quot;</span><br><span class="line">    environment:</span><br><span class="line">      ASPNETCORE_URLS: &quot;http:&#x2F;&#x2F;+&quot;</span><br><span class="line">      ASPNETCORE_ENVIRONMENT: &quot;Development&quot;</span><br></pre></td></tr></table></figure>
<p>从上可以看到，主要用来启动三个服务：</p>
<ol>
<li>envoy gateway：其中将项目路径下<code>/Envoy/envoy.yaml</code>挂载到容器目录<code>/etc/envoy/envoy.yaml</code>。同时暴露2个端口，9903，10003。</li>
<li>city api</li>
<li>weather api</li>
</ol>
<p>因此最终可以通过以下路径进行访问：</p>
<ol>
<li><a href="http://localhost:10003/c" target="_blank" rel="noopener">http://localhost:10003/c</a> 访问city api。</li>
<li><a href="http://localhost:10003/w" target="_blank" rel="noopener">http://localhost:10003/w</a> 访问weather api。</li>
</ol>
<p>执行以下命令，启动应用和代理，并测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; docker-compose up -d</span><br><span class="line">Starting k8snetenvoy_envoygateway_1 ... done</span><br><span class="line">Starting k8snetenvoy_cityapi_1      ... done</span><br><span class="line">Starting k8snetenvoy_weatherapi_1   ... done</span><br><span class="line">&gt; docker-compose ps</span><br><span class="line">           Name                         Command               State                         Ports</span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------</span><br><span class="line">k8snetenvoy_cityapi_1        dotnet K8S.NET.CityApi.dll       Up      443&#x2F;tcp, 0.0.0.0:8080-&gt;80&#x2F;tcp</span><br><span class="line">k8snetenvoy_envoygateway_1   &#x2F;docker-entrypoint.sh envo ...   Up      10000&#x2F;tcp, 0.0.0.0:10003-&gt;10003&#x2F;tcp,</span><br><span class="line">                                                                      0.0.0.0:9903-&gt;9903&#x2F;tcp</span><br><span class="line">k8snetenvoy_weatherapi_1     dotnet K8S.NET.WeatherApi.dll    Up      443&#x2F;tcp, 0.0.0.0:8082-&gt;80&#x2F;tcp</span><br><span class="line"></span><br><span class="line">&gt; curl http:&#x2F;&#x2F;localhost:10003&#x2F;c</span><br><span class="line">Shanghai</span><br><span class="line">&gt; curl http:&#x2F;&#x2F;localhost:10003&#x2F;w</span><br><span class="line">Cool</span><br></pre></td></tr></table></figure>

<h1 id="3-eShopOnContainers-中的应用"><a href="#3-eShopOnContainers-中的应用" class="headerlink" title="3. eShopOnContainers 中的应用"></a>3. eShopOnContainers 中的应用</h1><p>eShopOnContainer 中主要定义了四个API 网关（BFF 模式），服务间通信方式主要有两种，一种是HTTP，一种是gRPC。如果启用Service Mesh并且部署至K8S，服务整体通信架构如下图所示：</p>
<p><img src="/images/eshoponcontainers-envoy-gateway-12/2799767-47be05d0bd32c83d.png" alt=""></p>
<p>有两点需要补充说明：</p>
<ol>
<li><a href="https://linkerd.io" target="_blank" rel="noopener">Linkerd</a>是一种Service Mesh，其核心思想是借助<strong>Sidecar</strong>模式无侵入式对应用进行服务治理，包括服务发现、流量管理、负载均衡、路由等。</li>
<li>了解过Istio（目前比较流行的Service Mesh）应该知道，Envoy在Istio中作为Sidecar而存在，而在eShopOnContainers中Envoy被充当API Gateways。</li>
</ol>
<p>基于上面的基础，再来看eShopOnContainers中的配置，其实就很明白了，主要是配置文件从Ocelot 转变到envoy.yaml，配置如下图所示。<br><img src="/images/eshoponcontainers-envoy-gateway-12/2799767-5425c94996b90bd5.png" alt="eShopOnContainers  envoy proxy configuration"></p>
<p>路由配置如下：</p>
<ol>
<li>/m/ 、/marketing-api/ 路由至：marketing api</li>
<li>/c/、/catalog-api/ 路由至：catalog api</li>
<li>/o/、/ordering-api/ 路由至：ordering api</li>
<li>/b/、/basket-api/ 路由至：basket api</li>
<li>/ 路由至：web bff aggregator api</li>
</ol>
<p>部署时，基于helm将<code>envoy.yaml</code>保存至<code>ConfigMap</code>，在基于<code>envoyproxy/enovy</code>镜像构建容器，将配置从<code>ConfigMap</code>挂载到容器中，容器内部即可基于配置启动Envoy 网关了。<br><img src="/images/eshoponcontainers-envoy-gateway-12/2799767-7166fb7fafa25e35.png" alt=""></p>
<h1 id="4-Why-Envoy"><a href="#4-Why-Envoy" class="headerlink" title="4. Why Envoy"></a>4. Why Envoy</h1><p>经过上面的了解发现，Envoy还是充当的网关角色，那为什么要替换呢？ 先来了解下Envoy的优势：</p>
<ul>
<li><p><strong>非侵入式架构</strong> : <code>Envoy</code> 基于<code>Sidecar</code>模式，是一个独立进程，对应用透明。（在eShopOnContainer中还是独立的网关项目，并非以<code>Sidecar</code>模式注入到服务中。）</p>
<p><img src="/images/eshoponcontainers-envoy-gateway-12/2799767-d4f4df96d0ad4b1a.png" alt=""></p>
</li>
<li><p><strong>基于C++开发实现</strong>：拥有强大的定制化能力和优异的性能。</p>
</li>
<li><p><strong>L3/L4/L7 架构</strong> : 传统的网络代理，要么在 <code>HTTP</code> 层工作，要么在 <code>TCP</code> 层工作。而<code>Envoy</code> 同时支持 3/4 层和 7 层代理。</p>
</li>
<li><p><strong>顶级 HTTP/2 支持</strong> : 它将 <code>HTTP/2</code> 视为一等公民，并且可以在 <code>HTTP/2</code> 和 <code>HTTP/1.1</code> 之间相互转换（双向），建议使用 <code>HTTP/2</code>。</p>
</li>
<li><p><strong>gRPC 支持</strong> : Envoy 完美支持 HTTP/2，也可以很方便地支持 <code>gRPC</code> (<a href="http://www.grpc.io/" target="_blank" rel="noopener">gRPC</a> 使用 <code>HTTP/2</code> 作为底层多路复用传输协议)。</p>
</li>
<li><p><strong>服务发现和动态配置</strong> : 与 <code>Nginx</code> 等代理的热加载不同，<code>Envoy</code> 可以通过 <code>API</code> 接口动态更新配置，无需重启代理。</p>
</li>
<li><p><strong>特殊协议支持</strong> : Envoy 支持对特殊协议在 L7 进行嗅探和统计，包括：<a href="https://www.envoyproxy.io/docs/envoy/latest/configuration/listeners/network_filters/mongo_proxy_filter#" target="_blank" rel="noopener">MongoDB</a>、<a href="https://www.servicemesher.com/envoy/intro/arch_overview/dynamo.html#arch-overview-dynamo" target="_blank" rel="noopener">DynamoDB</a> 等。</p>
</li>
<li><p><strong>可观测性</strong> : <code>Envoy</code> 内置 <code>stats</code> 模块，可以集成诸如 <code>prometheus/statsd</code> 等监控方案。还可以集成分布式追踪系统，对请求进行追踪。</p>
</li>
</ul>
<p>再来看下Ocelot：其本质还是ASP.NET Core中的一个请求中间件。只能进行7层代理，不支持 gRPC，不支持监控。因此总体而言，Envoy更契合云原生对网络代理的诉求。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>本文简要梳理了Envoy的基本用法，以及其在eShopOnContainers中的运用。Envoy作为一个比肩Nginx的服务代理，其特性在Service Mesh中有着灵活的运用。本文就讲到这里了，下次有机会在和大家分享下Envoy在Service Mesh中的应用。</p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://fuckcloudnative.io/envoy-handbook/docs/overview/overview/" target="_blank" rel="noopener">Envoy 介绍 - Envoy 中文指南</a></li>
<li><a href="https://www.youtube.com/watch?v=UsoH5cqE1OA" target="_blank" rel="noopener">Build an API Gateway with Envoy and use with .NET Core APIs</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>eShopOnContainers</tag>
      </tags>
  </entry>
  <entry>
    <title>eShopOnContainers 知多少[5]：EventBus With RabbitMQ</title>
    <url>/post/eshoponcontainers-eventbus-with-rabbitmq-5/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>事件总线这个概念对你来说可能很陌生，但提到观察者（发布-订阅）模式，你也许就很熟悉。事件总线是对发布-订阅模式的一种实现。它是一种集中式事件处理机制，允许不同的组件之间进行彼此通信而又不需要相互依赖，达到一种解耦的目的。<br><img src="/images/eshoponcontainers-eventbus-with-rabbitmq-5/2799767-6f44bdefa88a23a2.png" alt=""><br>从上图可知，核心就4个角色：</p>
<ol>
<li>事件（事件源+事件处理）</li>
<li>事件发布者</li>
<li>事件订阅者</li>
<li>事件总线</li>
</ol>
<p>实现事件总线的关键是：</p>
<ol>
<li>事件总线维护一个事件源与事件处理的映射字典；</li>
<li>通过单例模式，确保事件总线的唯一入口；</li>
<li>利用反射完成事件源与事件处理的初始化绑定；</li>
<li>提供统一的事件注册、取消注册和触发接口。</li>
</ol>
<p>以上源于我在<a href="https://www.jianshu.com/p/22fbe7a7c120" target="_blank" rel="noopener">事件总线知多少（1）</a>中对于EventBus的分析和简单总结。基于以上的简单认知，我们来梳理下eShopOnContainers中EventBus的实现机制·。</p>
<h1 id="2-高屋建瓴–看类图"><a href="#2-高屋建瓴–看类图" class="headerlink" title="2. 高屋建瓴–看类图"></a>2. 高屋建瓴–看类图</h1><p>我们直接以上帝视角，来看下其实现机制，上类图。<br><img src="/images/eshoponcontainers-eventbus-with-rabbitmq-5/2799767-ffc77b39b8c56084.png" alt="EventBus Class Diagram"></p>
<p>我们知道事件的本质是：<strong>事件源+事件处理</strong>。<br>针对事件源，其定义了<code>IntegrationEvent</code>基类来处理。默认仅包含一个guid和一个创建日期，具体的事件可以通过继承该类，来完善事件的描述信息。</p>
<blockquote>
<p>这里有必要解释下<strong>Integration Event（集成事件）</strong>。因为在微服务中事件的消费不再局限于当前领域内，而是多个微服务可能共享同一个事件，所以这里要和DDD中的领域事件区分开来。集成事件可用于跨多个微服务或外部系统同步领域状态，这是通过在微服务之外发布集成事件来实现的。</p>
</blockquote>
<p>针对事件处理，其本质是对事件的反应，一个事件可引起多个反应，所以，它们之间是一对多的关系。<br>eShopOnContainers中抽象了两个事件处理的接口：</p>
<ol>
<li>IIntegrationEventHandler</li>
<li>IDynamicIntegrationEventHandler</li>
</ol>
<p>二者都定义了一个<code>Handle</code>方法用于响应事件。不同之处在于方法参数的类型：<br>第一个接受的是一个强类型的<code>IntegrationEvent</code>。第二个接收的是一个动态类型<code>dynamic</code>。<br>为什么要单独提供一个事件源为<code>dynamic</code>类型的接口呢？<br>不是每一个事件源都需要详细的事件信息，所以一个强类型的参数约束就没有必要，通过<code>dynamic</code>可以简化事件源的构建，更趋于灵活。</p>
<p>有了事件源和事件处理，接下来就是事件的注册和订阅了。为了方便进行订阅管理，系统提供了额外的一层抽象<code>IEventBusSubscriptionsManager</code>，其用于维护事件的订阅和注销，以及订阅信息的持久化。其默认的实现<code>InMemoryEventBusSubscriptionsManager</code>就是使用内存进行存储事件源和事件处理的映射字典。<br>从类图中看<code>InMemoryEventBusSubscriptionsManager</code>中定义了一个内部类<code>SubscriptionInfo</code>，其主要用于表示事件订阅方的订阅类型和事件处理的类型。</p>
<p>我们来近距离看下<code>InMemoryEventBusSubscriptionsManager</code>的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;InMemoryEventBusSubscriptionsManager.cs</span><br><span class="line">&#x2F;&#x2F;定义的事件名称和事件订阅的字典映射（1:N）</span><br><span class="line">private readonly Dictionary&lt;string, List&lt;SubscriptionInfo&gt;&gt; _handlers;</span><br><span class="line">&#x2F;&#x2F;保存所有的事件处理类型</span><br><span class="line">private readonly List&lt;Type&gt; _eventTypes;</span><br><span class="line">&#x2F;&#x2F;定义事件移除后事件</span><br><span class="line">public event EventHandler&lt;string&gt; OnEventRemoved;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;构造函数初始化</span><br><span class="line">public InMemoryEventBusSubscriptionsManager()</span><br><span class="line">&#123;</span><br><span class="line">    _handlers &#x3D; new Dictionary&lt;string, List&lt;SubscriptionInfo&gt;&gt;();</span><br><span class="line">    _eventTypes &#x3D; new List&lt;Type&gt;();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;添加动态类型事件订阅（需要手动指定事件名称）</span><br><span class="line">public void AddDynamicSubscription&lt;TH&gt;(string eventName)</span><br><span class="line">    where TH : IDynamicIntegrationEventHandler</span><br><span class="line">&#123;</span><br><span class="line">    DoAddSubscription(typeof(TH), eventName, isDynamic: true);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;添加强类型事件订阅（事件名称为事件源类型）</span><br><span class="line">public void AddSubscription&lt;T, TH&gt;()</span><br><span class="line">    where T : IntegrationEvent</span><br><span class="line">    where TH : IIntegrationEventHandler&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var eventName &#x3D; GetEventKey&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">    DoAddSubscription(typeof(TH), eventName, isDynamic: false);</span><br><span class="line"></span><br><span class="line">    if (!_eventTypes.Contains(typeof(T)))</span><br><span class="line">    &#123;</span><br><span class="line">        _eventTypes.Add(typeof(T));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;移除动态类型事件订阅</span><br><span class="line">public void RemoveDynamicSubscription&lt;TH&gt;(string eventName)</span><br><span class="line">    where TH : IDynamicIntegrationEventHandler</span><br><span class="line">&#123;</span><br><span class="line">    var handlerToRemove &#x3D; FindDynamicSubscriptionToRemove&lt;TH&gt;(eventName);</span><br><span class="line">    DoRemoveHandler(eventName, handlerToRemove);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;移除强类型事件订阅</span><br><span class="line">public void RemoveSubscription&lt;T, TH&gt;()</span><br><span class="line">    where TH : IIntegrationEventHandler&lt;T&gt;</span><br><span class="line">    where T : IntegrationEvent</span><br><span class="line">&#123;</span><br><span class="line">    var handlerToRemove &#x3D; FindSubscriptionToRemove&lt;T, TH&gt;();</span><br><span class="line">    var eventName &#x3D; GetEventKey&lt;T&gt;();</span><br><span class="line">    DoRemoveHandler(eventName, handlerToRemove);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>添加了这么一层抽象，即符合了单一职责原则，又完成了代码重用。<code>IEventBus</code>的具体实现通过注入对<code>IEventBusSubscriptionsManager</code>的依赖，即可完成订阅管理。<br>你这里可能会好奇，为什么要暴露一个<code>OnEventRemoved</code>事件？这里先按住不表，留给大家思考。</p>
<h1 id="3-使用RabbitMQ实现EventBus"><a href="#3-使用RabbitMQ实现EventBus" class="headerlink" title="3. 使用RabbitMQ实现EventBus"></a>3. 使用RabbitMQ实现EventBus</h1><p><img src="/images/eshoponcontainers-eventbus-with-rabbitmq-5/2799767-e755a64504de3add.png" alt=""></p>
<h2 id="3-1-为什么需要RabbitMQ"><a href="#3-1-为什么需要RabbitMQ" class="headerlink" title="3.1. 为什么需要RabbitMQ?"></a>3.1. 为什么需要RabbitMQ?</h2><p>微服务的一大特点就是分布式。若需要做到<strong>动一发而牵全身</strong>，就需要一个持久化的集中式的EventBus。这就要求<strong>各个微服务内部虽然分别持有一个对EventBus的引用，但它们背后都必须连接着同一个用于持久化的数据源。</strong></p>
<p>那你可能会说：那这个很好实现，使用同一个数据库就好了。为什么非要用个什么RabbitMQ？问的好！这就要去探讨下RabbitMQ是为了解决什么问题了。</p>
<blockquote>
<p>RabbitMQ提供了可靠的消息机制、跟踪机制和灵活的消息路由，支持消息集群和分布式部署。适用于排队算法、秒杀活动、消息分发、异步处理、数据同步、处理耗时任务、CQRS等应用场景。</p>
</blockquote>
<p>而关于RabbitMQ的具体使用，这里不再展开，可参考<a href="https://www.jianshu.com/p/ca6736de9511" target="_blank" rel="noopener">RabbitMQ知多少</a>。</p>
<h2 id="3-2-EventBus集成RabbitMQ的核心"><a href="#3-2-EventBus集成RabbitMQ的核心" class="headerlink" title="3.2. EventBus集成RabbitMQ的核心"></a>3.2. EventBus集成RabbitMQ的核心</h2><p>集成RabbitMQ的关键在于理解其对消息的处理机制：</p>
<ol>
<li>消息的生产者和消费者通过与服务器（Broker）建立连接，然后基于创建的信道（Chanel）进行消息的发生和接收。</li>
<li>消息的生产者可以通过声明指定的队列（queue）或交换机（exchange）以及路由（routingKey）进行消息的发送。</li>
<li>消息的消费者通过绑定到相应的队列（queue）或交换机（exchange）监听相应的路由（routingKey），进行消息的接收。</li>
<li>消息的消费者通过构造消费者实例绑定消息接收后的事件委托来进行消息消费。</li>
</ol>
<h2 id="3-3-源码一览"><a href="#3-3-源码一览" class="headerlink" title="3.3. 源码一览"></a>3.3. 源码一览</h2><p>基于以上的认知，我们再与<code>EventBusRabbitMQ</code>源码亲密接触。</p>
<h3 id="3-3-1-构造函数定义"><a href="#3-3-1-构造函数定义" class="headerlink" title="3.3.1. 构造函数定义"></a>3.3.1. 构造函数定义</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class EventBusRabbitMQ : IEventBus, IDisposable</span><br><span class="line">&#123;</span><br><span class="line">    const string BROKER_NAME &#x3D; &quot;eshop_event_bus&quot;;</span><br><span class="line"></span><br><span class="line">    private readonly IRabbitMQPersistentConnection _persistentConnection;</span><br><span class="line">    private readonly ILogger&lt;EventBusRabbitMQ&gt; _logger;</span><br><span class="line">    private readonly IEventBusSubscriptionsManager _subsManager;</span><br><span class="line">    private readonly ILifetimeScope _autofac;</span><br><span class="line">    private readonly string AUTOFAC_SCOPE_NAME &#x3D; &quot;eshop_event_bus&quot;;</span><br><span class="line">    private readonly int _retryCount;</span><br><span class="line"></span><br><span class="line">    private IModel _consumerChannel;</span><br><span class="line">    private string _queueName;</span><br><span class="line"></span><br><span class="line">    public EventBusRabbitMQ(IRabbitMQPersistentConnection persistentConnection, ILogger&lt;EventBusRabbitMQ&gt; logger,</span><br><span class="line">        ILifetimeScope autofac, IEventBusSubscriptionsManager subsManager, string queueName &#x3D; null, int retryCount &#x3D; 5)</span><br><span class="line">    &#123;</span><br><span class="line">        _persistentConnection &#x3D; persistentConnection ?? throw new ArgumentNullException(nameof(persistentConnection));</span><br><span class="line">        _logger &#x3D; logger ?? throw new ArgumentNullException(nameof(logger));</span><br><span class="line">        _subsManager &#x3D; subsManager ?? new InMemoryEventBusSubscriptionsManager();</span><br><span class="line">        _queueName &#x3D; queueName;</span><br><span class="line">        _consumerChannel &#x3D; CreateConsumerChannel();</span><br><span class="line">        _autofac &#x3D; autofac;</span><br><span class="line">        _retryCount &#x3D; retryCount;</span><br><span class="line">        _subsManager.OnEventRemoved +&#x3D; SubsManager_OnEventRemoved;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void SubsManager_OnEventRemoved(object sender, string eventName)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!_persistentConnection.IsConnected)</span><br><span class="line">        &#123;</span><br><span class="line">            _persistentConnection.TryConnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        using (var channel &#x3D; _persistentConnection.CreateModel())</span><br><span class="line">        &#123;</span><br><span class="line">            channel.QueueUnbind(queue: _queueName, exchange: BROKER_NAME, routingKey: eventName);</span><br><span class="line"></span><br><span class="line">            if (_subsManager.IsEmpty)</span><br><span class="line">            &#123;</span><br><span class="line">                _queueName &#x3D; string.Empty;</span><br><span class="line">                _consumerChannel.Close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#x2F;&#x2F;....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造函数主要做了以下几件事：</p>
<ol>
<li>注入<code>IRabbitMQPersistentConnection</code>以便连接到对应的Broke。</li>
<li>使用空对象模式注入<code>IEventBusSubscriptionsManager</code>，进行订阅管理。</li>
<li>创建消费者信道，用于消息消费。</li>
<li>注册<code>OnEventRemoved</code>事件，取消队列的绑定。（这也就回答了上面遗留的问题）</li>
</ol>
<h3 id="3-3-2-事件订阅的逻辑："><a href="#3-3-2-事件订阅的逻辑：" class="headerlink" title="3.3.2. 事件订阅的逻辑："></a>3.3.2. 事件订阅的逻辑：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void DoInternalSubscription(string eventName)</span><br><span class="line">&#123;</span><br><span class="line">    var containsKey &#x3D; _subsManager.HasSubscriptionsForEvent(eventName);</span><br><span class="line">    if (!containsKey)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!_persistentConnection.IsConnected)</span><br><span class="line">        &#123;</span><br><span class="line">            _persistentConnection.TryConnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        using (var channel &#x3D; _persistentConnection.CreateModel())</span><br><span class="line">        &#123;</span><br><span class="line">            channel.QueueBind(queue: _queueName,</span><br><span class="line">                              exchange: BROKER_NAME,</span><br><span class="line">                              routingKey: eventName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面我们可以看到事件的订阅主要是进行rabbitmq队列的绑定。以eventName为routingKey进行路由。</p>
<h3 id="3-3-3-事件的发布逻辑"><a href="#3-3-3-事件的发布逻辑" class="headerlink" title="3.3.3. 事件的发布逻辑"></a>3.3.3. 事件的发布逻辑</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void Publish(IntegrationEvent @event)</span><br><span class="line">&#123;</span><br><span class="line">    if (!_persistentConnection.IsConnected)</span><br><span class="line">    &#123;</span><br><span class="line">        _persistentConnection.TryConnect();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    var policy &#x3D; RetryPolicy.Handle&lt;BrokerUnreachableException&gt;()</span><br><span class="line">        .Or&lt;SocketException&gt;()</span><br><span class="line">        .WaitAndRetry(_retryCount, retryAttempt &#x3D;&gt; TimeSpan.FromSeconds(Math.Pow(2, retryAttempt)), (ex, time) &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            _logger.LogWarning(ex.ToString());</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    using (var channel &#x3D; _persistentConnection.CreateModel())</span><br><span class="line">    &#123;</span><br><span class="line">        var eventName &#x3D; @event.GetType()</span><br><span class="line">            .Name;</span><br><span class="line"></span><br><span class="line">        channel.ExchangeDeclare(exchange: BROKER_NAME, type: &quot;direct&quot;);</span><br><span class="line"></span><br><span class="line">        var message &#x3D; JsonConvert.SerializeObject(@event);</span><br><span class="line">        var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line"></span><br><span class="line">        policy.Execute(() &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            var properties &#x3D; channel.CreateBasicProperties();</span><br><span class="line">            properties.DeliveryMode &#x3D; 2; &#x2F;&#x2F; persistent</span><br><span class="line"></span><br><span class="line">            channel.BasicPublish(exchange: BROKER_NAME, routingKey: eventName, mandatory:true, basicProperties: properties, body: body);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面有以下几个知识点：</p>
<ol>
<li>使用Polly，以2的阶乘的时间间隔进行重试。（第一次2s后，第二次4s后，第三次8s后…重试）</li>
<li>使用direct全匹配、单播形式的路由机制进行消息分发</li>
<li>消息主体是格式化的json字符串</li>
<li>指定<code>DeliveryMode = 2</code>进行消息持久化</li>
<li>指定<code>mandatory: true</code>告知服务器当根据指定的routingKey和消息找不到对应的队列时，直接返回消息给生产者。</li>
</ol>
<h3 id="3-3-4-然后看看事件消息的监听"><a href="#3-3-4-然后看看事件消息的监听" class="headerlink" title="3.3.4. 然后看看事件消息的监听"></a>3.3.4. 然后看看事件消息的监听</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private IModel CreateConsumerChannel()</span><br><span class="line">&#123;</span><br><span class="line">    if (!_persistentConnection.IsConnected)</span><br><span class="line">    &#123;</span><br><span class="line">        _persistentConnection.TryConnect();</span><br><span class="line">    &#125;</span><br><span class="line">    var channel &#x3D; _persistentConnection.CreateModel();</span><br><span class="line">    channel.ExchangeDeclare(exchange: BROKER_NAME, type: &quot;direct&quot;);</span><br><span class="line">    channel.QueueDeclare(queue: _queueName, durable: true, exclusive: false,autoDelete: false, arguments: null);</span><br><span class="line">    var consumer &#x3D; new EventingBasicConsumer(channel);</span><br><span class="line">    consumer.Received +&#x3D; async (model, ea) &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        var eventName &#x3D; ea.RoutingKey;</span><br><span class="line">        var message &#x3D; Encoding.UTF8.GetString(ea.Body);</span><br><span class="line">        await ProcessEvent(eventName, message);</span><br><span class="line">        channel.BasicAck(ea.DeliveryTag, multiple:false);</span><br><span class="line">    &#125;;</span><br><span class="line">    channel.BasicConsume(queue: _queueName, autoAck: false, consumer: consumer);</span><br><span class="line">    channel.CallbackException +&#x3D; (sender, ea) &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        _consumerChannel.Dispose();</span><br><span class="line">        _consumerChannel &#x3D; CreateConsumerChannel();</span><br><span class="line">    &#125;;</span><br><span class="line">    return channel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码演示了如创建消费信道进行消息处理的步骤：</p>
<ol>
<li>创建信道Channel</li>
<li>并申明Exchange</li>
<li>实例化绑定Channel的消费者实例</li>
<li>注册<code>Received</code>事件委托处理消息接收事件</li>
<li>调用<code>channel.BasicConsume</code>启动监听</li>
</ol>
<h3 id="3-3-5-具体的事件处理"><a href="#3-3-5-具体的事件处理" class="headerlink" title="3.3.5. 具体的事件处理"></a>3.3.5. 具体的事件处理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private async Task ProcessEvent(string eventName, string message)</span><br><span class="line">&#123;</span><br><span class="line">    if (_subsManager.HasSubscriptionsForEvent(eventName))</span><br><span class="line">    &#123;</span><br><span class="line">        using (var scope &#x3D; _autofac.BeginLifetimeScope(AUTOFAC_SCOPE_NAME))</span><br><span class="line">        &#123;</span><br><span class="line">            var subscriptions &#x3D; _subsManager.GetHandlersForEvent(eventName);</span><br><span class="line">            foreach (var subscription in subscriptions)</span><br><span class="line">            &#123;</span><br><span class="line">                if (subscription.IsDynamic)</span><br><span class="line">                &#123; </span><br><span class="line">                    var handler &#x3D; scope.ResolveOptional(subscription.HandlerType) as IDynamicIntegrationEventHandler;</span><br><span class="line">                    dynamic eventData &#x3D; JObject.Parse(message);</span><br><span class="line">                    await handler.Handle(eventData);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                &#123;</span><br><span class="line">                    var eventType &#x3D; _subsManager.GetEventTypeByName(eventName);</span><br><span class="line">                    var integrationEvent &#x3D; JsonConvert.DeserializeObject(message, eventType);</span><br><span class="line">                    var handler &#x3D; scope.ResolveOptional(subscription.HandlerType);</span><br><span class="line">                    var concreteType &#x3D; typeof(IIntegrationEventHandler&lt;&gt;).MakeGenericType(eventType);</span><br><span class="line">                    await (Task)concreteType.GetMethod(&quot;Handle&quot;).Invoke(handler, new object[] &#123; integrationEvent &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码主要包括以下知识点：</p>
<ol>
<li>Json字符串的反序列化</li>
<li>利用依赖注入容器解析集成事件（Integration Event）和事件处理（Event Handler）类型</li>
<li>反射调用具体的事件处理方法</li>
</ol>
<h1 id="4-EventBus的集成和使用"><a href="#4-EventBus的集成和使用" class="headerlink" title="4. EventBus的集成和使用"></a>4. EventBus的集成和使用</h1><p>以上介绍了EventBus的实现要点，那各个微服务是如何集成呢？<br><strong>1. 注册<code>IRabbitMQPersistentConnection</code>服务用于设置RabbitMQ连接</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">services.AddSingleton&lt;IRabbitMQPersistentConnection&gt;(sp &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var logger &#x3D; sp.GetRequiredService&lt;ILogger&lt;DefaultRabbitMQPersistentConnection&gt;&gt;();</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">    return new DefaultRabbitMQPersistentConnection(factory, logger, retryCount);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>2. 注册单例模式的<code>IEventBusSubscriptionsManager</code>用于订阅管理</strong><br><code>services.AddSingleton&lt;IEventBusSubscriptionsManager, InMemoryEventBusSubscriptionsManager&gt;();</code></p>
<p><strong>3. 注册单例模式的<code>EventBusRabbitMQ</code></strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">services.AddSingleton&lt;IEventBus, EventBusRabbitMQ&gt;(sp &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var rabbitMQPersistentConnection &#x3D; sp.GetRequiredService&lt;IRabbitMQPersistentConnection&gt;();</span><br><span class="line">    var iLifetimeScope &#x3D; sp.GetRequiredService&lt;ILifetimeScope&gt;();</span><br><span class="line">    var logger &#x3D; sp.GetRequiredService&lt;ILogger&lt;EventBusRabbitMQ&gt;&gt;();</span><br><span class="line">    var eventBusSubcriptionsManager &#x3D; sp.GetRequiredService&lt;IEventBusSubscriptionsManager&gt;();</span><br><span class="line"></span><br><span class="line">    var retryCount &#x3D; 5;</span><br><span class="line">    if (!string.IsNullOrEmpty(Configuration[&quot;EventBusRetryCount&quot;]))</span><br><span class="line">    &#123;</span><br><span class="line">        retryCount &#x3D; int.Parse(Configuration[&quot;EventBusRetryCount&quot;]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return new EventBusRabbitMQ(rabbitMQPersistentConnection, logger, iLifetimeScope, eventBusSubcriptionsManager, subscriptionClientName, retryCount);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>完成了以上集成，就可以在代码中使用事件总线，进行事件的发布和订阅。</p>
<p><strong>4. 发布事件</strong><br>若要发布事件，需要根据是否需要事件源（参数传递）来决定是否需要申明相应的集成事件，需要则继承自<code>IntegrationEvent</code>进行申明。然后在需要发布事件的地方进行实例化，并通过调用<code>IEventBus</code>的实例的<code>Publish</code>方法进行发布。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;事件源的声明</span><br><span class="line">public class ProductPriceChangedIntegrationEvent : IntegrationEvent</span><br><span class="line">&#123;        </span><br><span class="line">    public int ProductId &#123; get; private set; &#125;</span><br><span class="line"></span><br><span class="line">    public decimal NewPrice &#123; get; private set; &#125;</span><br><span class="line"></span><br><span class="line">    public decimal OldPrice &#123; get; private set; &#125;</span><br><span class="line"></span><br><span class="line">    public ProductPriceChangedIntegrationEvent(int productId, decimal newPrice, decimal oldPrice)</span><br><span class="line">    &#123;</span><br><span class="line">        ProductId &#x3D; productId;</span><br><span class="line">        NewPrice &#x3D; newPrice;</span><br><span class="line">        OldPrice &#x3D; oldPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;声明事件源</span><br><span class="line">var priceChangedEvent &#x3D; new ProductPriceChangedIntegrationEvent(1001, 200.00, 169.00)</span><br><span class="line">&#x2F;&#x2F;发布事件</span><br><span class="line">_eventBus.Publish(priceChangedEvent）</span><br></pre></td></tr></table></figure>
<p><strong>5. 订阅事件</strong><br>若要订阅事件，需要根据需要处理的事件类型，申明对应的事件处理类，继承自<code>IIntegrationEventHandler</code>或<code>IDynamicIntegrationEventHandler</code>，并注册到IOC容器。然后创建<code>IEventBus</code>的实例调用<code>Subscribe</code>方法进行显式订阅。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;定义事件处理</span><br><span class="line">public class ProductPriceChangedIntegrationEventHandler : IIntegrationEventHandler&lt;ProductPriceChangedIntegrationEvent&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public async Task Handle(ProductPriceChangedIntegrationEvent @event)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;事件订阅</span><br><span class="line">var eventBus &#x3D; app.ApplicationServices.GetRequiredService&lt;IEventBus&gt;();</span><br><span class="line">eventBus.Subscribe&lt;ProductPriceChangedIntegrationEvent, ProductPriceChangedIntegrationEventHandler&gt;();</span><br></pre></td></tr></table></figure>
<p><strong>6. 跨服务事件消费</strong><br>在微服务中跨服务事件消费很普遍，这里有一点需要说明的是如果订阅的强类型事件非当前微服务中订阅的事件，需要复制定义订阅的事件类型。换句话说，比如在A服务发布的<code>TestEvent</code>事件，B服务订阅该事件，同样需要在B服务复制定义一个<code>TestEvent</code>。<br>这也是微服务的一个通病，重复代码。</p>
<h1 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h1><p>通过一步一步的源码梳理，我们发现eShopOnContainers中事件总线的总体实现思路与引言部分的介绍十分契合。所以对于事件总线，不要觉得高深，明确参与的几个角色以及基本的实现步骤，那么不管是基于RabbitMQ实现也好还是基于Azure Service Bus也好，万变不离其宗！</p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>eShopOnContainers</tag>
      </tags>
  </entry>
  <entry>
    <title>eShopOnContainers 知多少[3]：Identity microservice</title>
    <url>/post/eshoponcontainers-identity-microservice-3/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>通常，服务所公开的资源和 API 必须仅限受信任的特定用户和客户端访问。那进行 API 级别信任决策的第一步就是身份认证——确定用户身份是否可靠。</p>
<p>在微服务场景中，身份认证通常统一处理。一般有两种实现形式：</p>
<ol>
<li><p><strong>基于API 网关中心化认证</strong>：要求客户端必须都通过网关访问微服务。（这就要求提供一种安全机制来认证请求是来自于网关。）<br><img src="/images/eshoponcontainers-identity-microservice-3/2799767-c144a034f31f618a.png" alt="基于API 网关中心化认证"></p>
</li>
<li><p><strong>基于安全令牌服务（STS）认证</strong>：所有的客户端先从STS获取令牌，然后请求时携带令牌完成认证。<br><img src="/images/eshoponcontainers-identity-microservice-3/2799767-5fd11c4964526d9e.png" alt="基于安全令牌服务（STS）认证"></p>
</li>
</ol>
<p>而本节所讲的Identity microservice就是使用第二种身份认证方式。</p>
<h1 id="服务简介"><a href="#服务简介" class="headerlink" title="服务简介"></a>服务简介</h1><p>Identity microservice 主要用于统一的身份认证和授权，为其他服务提供支撑。</p>
<p>提到认证，大家最熟悉不过的当属Cookie认证了，它也是目前使用最多的认证方式。但Cookie认证也有其局限性：不支持跨域、移动端不友好等。而从当前的架构来看，需要支持移动端、Web端、微服务间的交叉认证授权，所以传统的基于Cookie的本地认证方案就行不通了。我们就需要使用远程认证的方式来提供统一的认证授权机制。<br>而远程认证方式当属：OAuth2.0和OpenID Connect了。借助OAuth2.0和OpenID Connect即可实现类似下图的认证体系：<br><img src="/images/eshoponcontainers-identity-microservice-3/2799767-e11fee58768082b6.png" alt=""></p>
<p>而如何实现呢，借助：</p>
<ol>
<li>ASP.NET Core Identity</li>
<li>IdentityServer4</li>
</ol>
<p>基于Cookie的认证和基于Token的认证的差别如下所示：</p>
<p><img src="/images/eshoponcontainers-identity-microservice-3/2799767-94fe62157ce8bc16.png" alt="Cookie-Based Auth VS Token-Based Auth"></p>
<h1 id="架构模式"><a href="#架构模式" class="headerlink" title="架构模式"></a>架构模式</h1><p>该微服务作为支撑服务，并没有选择复杂的架构模式，使用了MVC单层架构，使用EF Core ORM框架用于数据持久化，SQL Server数据库。使用Autofac IOC框架替换了默认依赖注入框架。</p>
<p>项目结构如下所示：<br><img src="/images/eshoponcontainers-identity-microservice-3/2799767-1f015f6381e5178f.png" alt="Identity.API 项目结构"></p>
<p>核心技术选型：</p>
<ol>
<li>MVC单层架构</li>
<li>EF Core</li>
<li><a href="https://github.com/aspnet/Identity" target="_blank" rel="noopener">ASP.NET Core Identity</a></li>
<li><a href="https://github.com/IdentityServer/IdentityServer4" target="_blank" rel="noopener">IdentityServer4</a></li>
<li>SQL Server 数据库</li>
<li>Autofac</li>
</ol>
<p>PS：对ASP.NET Core Identity、IdentityServer4以及OAuth2.0不了解的，请先行阅读文末参考资料补课！！！</p>
<p>下面就着重讲解ASP.NET Core Identity和IdentityServer4在本服务中的使用。</p>
<h1 id="ASP-NET-Core-Identity-amp-amp-IdentityServer4简介"><a href="#ASP-NET-Core-Identity-amp-amp-IdentityServer4简介" class="headerlink" title="ASP.NET Core Identity &amp;&amp; IdentityServer4简介"></a>ASP.NET Core Identity &amp;&amp; IdentityServer4简介</h1><p>ASP.NET Core Identity用于构建ASP.NET Core Web应用程序的成员资格系统，包括成员资格，登录和用户数据（包括登录信息、角色和声明）。<br>ASP.NET Core Identity封装了User、Role、Claim等身份信息，便于我们快速完成登录功能的实现，并且支持第三方登录（Google、Facebook、QQ、Weixin等，支持开箱即用[<a href="https://github.com/aspnet-contrib/AspNet.Security.OAuth.Providers/tree/dev/src" target="_blank" rel="noopener">第三方身份提供商列表</a>]），以及双重验证，同时内置支持Bearer 认证（令牌认证）。</p>
<p>虽然ASP.NET Core Identity已经完成了绝大多数的功能，且支持第三方登录（第三方为其用户颁发令牌），但若要为本地用户颁发令牌，则需要自己实现令牌的颁发和验证逻辑。换句话说，我们需要自行实现OpenId Connect协议。</p>
<blockquote>
<p>OpenID Connect 1.0 是基于OAuth 2.0协议之上的简单身份层，它允许客户端根据授权服务器的认证结果最终确认终端用户的身份，以及获取基本的用户信息。</p>
</blockquote>
<p>而IdentityServer4就是为ASP.NET Core量身定制的实现了OpenId Connect和OAuth2.0协议的认证授权中间件。IdentityServer4在ASP.NET Core Identity的基础上，提供令牌的颁发验证等。</p>
<h1 id="认证流程简介"><a href="#认证流程简介" class="headerlink" title="认证流程简介"></a>认证流程简介</h1><p>在ASP.NET Core中使用的是<strong>基于申明（Claim）的认证</strong>，而什么是申明（Cliam）呢？</p>
<blockquote>
<p>Claim 是关于一个人或组织的某个主题的陈述，比如：一个人的名称，角色，个人喜好，种族，特权，社团，能力等等。它本质上就是一个键值对，是一种非常通用的保存用户信息的方式，可以很容易的将认证和授权分离开来，前者用来表示用户是/不是什么，后者用来表示用户能/不能做什么。在认证阶段我们通过用户信息获取到用户的Claims，而授权便是对这些的Claims的验证，如：是否拥有Admin的角色，姓名是否叫XXX等等。</p>
</blockquote>
<p>认证主要与以下几个核心对象打交道：</p>
<ol>
<li>Claim（身份信息）</li>
<li>ClaimsIdentity（身份证）</li>
<li>ClaimsPrincipal （身份证持有者）</li>
<li>AuthorizationToken （授权令牌）</li>
<li>IAuthenticationScheme（认证方案）</li>
<li>IAuthenticationHandler（与认证方案对应的认证处理器）</li>
<li>IAuthenticationService （向外提供统一的认证服务接口）</li>
</ol>
<p>那其认证流程是怎样的呢？</p>
<blockquote>
<p>用户打开登录界面，输入用户名密码先行登录，服务端先行校验用户名密码是否有效，有效则返回用户实例（User），这时进入认证准备阶段，根据用户实例携带的身份信息（Claim），创建身份证（ClaimsIdentity），然后将身份证交给身份证持有者（ClaimsPrincipal）持有。接下来进入真正的认证阶段，根据配置的认证方案（IAuthenticationScheme），使用相对应的认证处理器（IAuthenticationHandler）进行认证 。认证成功后发放授权令牌（AuthorizationToken）。该授权令牌包含后续授权阶段需要的全部信息。</p>
</blockquote>
<h1 id="授权流程简介"><a href="#授权流程简介" class="headerlink" title="授权流程简介"></a>授权流程简介</h1><p>授权就是对于用户身份信息（Claims）的验证，，授权又分以下几种种：</p>
<ol>
<li>基于Role的授权</li>
<li>基于Scheme的授权</li>
<li>基于Policy的授权</li>
</ol>
<p>授权主要与以下几个核心对象打交道：</p>
<ol>
<li>IAuthorizationRequirement（授权条件）</li>
<li>IAuthorizationService（授权服务）</li>
<li>AuthorizationPolicy（授权策略）</li>
<li>IAuthorizationHandler （授权处理器）</li>
<li>AuthorizationResult（授权结果）</li>
</ol>
<p>那授权流程是怎样的呢？</p>
<blockquote>
<p>当收到授权请求后，由授权服务（IAuthorizationService）根据资源上指定的授权策略（AuthorizationPolicy）中包含的授权条件（IAuthorizationRequirement），找到相对应的授权处理器（IAuthorizationHandler ）来判断授权令牌中包含的身份信息是否满足授权条件，并返回授权结果。</p>
</blockquote>
<p><img src="/images/eshoponcontainers-identity-microservice-3/2799767-3e02fb3a7f95ef00.png" alt="核心对象"></p>
<h1 id="中间件集成"><a href="#中间件集成" class="headerlink" title="中间件集成"></a>中间件集成</h1><p>简单了解了下认证和授权流程后，我们来了解Identity microservice是如何集成相关中间件的。</p>
<h2 id="1-首先是映射自定义扩展的User和Role"><a href="#1-首先是映射自定义扩展的User和Role" class="headerlink" title="1. 首先是映射自定义扩展的User和Role"></a>1. 首先是映射自定义扩展的User和Role</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &#x2F;&#x2F; 映射自定义的User，Role</span><br><span class="line">services.AddIdentity&lt;ApplicationUser, IdentityRole&gt;()</span><br><span class="line">    .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;()&#x2F;&#x2F;配置使用EF持久化存储</span><br><span class="line">    .AddDefaultTokenProviders();&#x2F;&#x2F;配置默认的TokenProvider用于变更密码和修改email时生成Token</span><br></pre></td></tr></table></figure>
<h2 id="2-配置IdentityServer服务"><a href="#2-配置IdentityServer服务" class="headerlink" title="2. 配置IdentityServer服务"></a>2. 配置IdentityServer服务</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Adds IdentityServer</span><br><span class="line">services.AddIdentityServer(x &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    x.IssuerUri &#x3D; &quot;null&quot;;</span><br><span class="line">    x.Authentication.CookieLifetime &#x3D; TimeSpan.FromHours(2);</span><br><span class="line">&#125;)</span><br><span class="line">.AddSigningCredential(Certificate.Get())</span><br><span class="line">.AddAspNetIdentity&lt;ApplicationUser&gt;()</span><br><span class="line">.AddConfigurationStore(options &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.ConfigureDbContext &#x3D; builder &#x3D;&gt; builder.UseSqlServer(connectionString,</span><br><span class="line">     sqlServerOptionsAction: sqlOptions &#x3D;&gt;</span><br><span class="line">     &#123;</span><br><span class="line">         sqlOptions.MigrationsAssembly(migrationsAssembly);</span><br><span class="line">         &#x2F;&#x2F;Configuring Connection Resiliency: https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;ef&#x2F;core&#x2F;miscellaneous&#x2F;connection-resiliency </span><br><span class="line">         sqlOptions.EnableRetryOnFailure(maxRetryCount: 15, maxRetryDelay: TimeSpan.FromSeconds(30), errorNumbersToAdd: null);</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.AddOperationalStore(options &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.ConfigureDbContext &#x3D; builder &#x3D;&gt; builder.UseSqlServer(connectionString,</span><br><span class="line">     sqlServerOptionsAction: sqlOptions &#x3D;&gt;</span><br><span class="line">     &#123;</span><br><span class="line">         sqlOptions.MigrationsAssembly(migrationsAssembly);</span><br><span class="line">         &#x2F;&#x2F;Configuring Connection Resiliency: https:&#x2F;&#x2F;docs.microsoft.com&#x2F;en-us&#x2F;ef&#x2F;core&#x2F;miscellaneous&#x2F;connection-resiliency </span><br><span class="line">         sqlOptions.EnableRetryOnFailure(maxRetryCount: 15, maxRetryDelay: TimeSpan.FromSeconds(30), errorNumbersToAdd: null);</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.Services.AddTransient&lt;IProfileService, ProfileService&gt;();</span><br></pre></td></tr></table></figure>
<p>IdentityServer默认直接在内存中存储配置数据（客户端和资源）和操作数据（令牌，代码和和用户的授权信息consents）。这显然在生产环境是不合适的，如果服务所在主机宕机，那么内存中的数据就会丢失，所以有必要持久化到数据库。<br>其中<code>AddConfigurationStore</code>和<code>AddOperationalStore</code>扩展方法就是用来来指定配置数据和操作数据基于EF进行持久化。</p>
<h2 id="3-添加IdentityServer中间件"><a href="#3-添加IdentityServer中间件" class="headerlink" title="3. 添加IdentityServer中间件"></a>3. 添加IdentityServer中间件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)</span><br><span class="line">&#123;</span><br><span class="line">     &#x2F;&#x2F; .....</span><br><span class="line">    &#x2F;&#x2F; Adds IdentityServer</span><br><span class="line">    app.UseIdentityServer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-预置种子数据"><a href="#4-预置种子数据" class="headerlink" title="4. 预置种子数据"></a>4. 预置种子数据</h2><p>从已知的体系结构来说，我们需要预置Client和Resource：</p>
<ol>
<li><p>Client</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static IEnumerable&lt;Client&gt; GetClients(Dictionary&lt;string,string&gt; clientsUrl)</span><br><span class="line">&#123;</span><br><span class="line">    return new List&lt;Client&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; SPA OpenId Client Client(Implicit)</span><br><span class="line">        new Client</span><br><span class="line">        &#x2F;&#x2F; Xamarin Client(Hybrid)</span><br><span class="line">        new Client</span><br><span class="line">        &#x2F;&#x2F; MVC Client(Hybrid)</span><br><span class="line">        new Client</span><br><span class="line">        &#x2F;&#x2F; MVC TEST Client(Hybrid)</span><br><span class="line">        new Client</span><br><span class="line">        &#x2F;&#x2F; Locations Swagger UI(Implicit)</span><br><span class="line">        new Client</span><br><span class="line">        &#x2F;&#x2F; Marketing Swagger UI(Implicit)</span><br><span class="line">        new Client</span><br><span class="line">        &#x2F;&#x2F; Basket Swagger UI(Implicit)</span><br><span class="line">        new Client</span><br><span class="line">        &#x2F;&#x2F; Ordering Swagger UI(Implicit)</span><br><span class="line">        new Client</span><br><span class="line">        &#x2F;&#x2F; Mobile Shopping Aggregattor Swagger UI(Implicit)</span><br><span class="line">        new Client</span><br><span class="line">        &#x2F;&#x2F; Web Shopping Aggregattor Swagger UI(Implicit)</span><br><span class="line">        new Client</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>IdentityResources</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static IEnumerable&lt;IdentityResource&gt; GetResources()</span><br><span class="line">&#123;</span><br><span class="line">    return new List&lt;IdentityResource&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        new IdentityResources.OpenId(),</span><br><span class="line">        new IdentityResources.Profile()</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ApiResources</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static IEnumerable&lt;ApiResource&gt; GetApis()</span><br><span class="line">&#123;</span><br><span class="line">    return new List&lt;ApiResource&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        new ApiResource(&quot;orders&quot;, &quot;Orders Service&quot;),</span><br><span class="line">        new ApiResource(&quot;basket&quot;, &quot;Basket Service&quot;),</span><br><span class="line">        new ApiResource(&quot;marketing&quot;, &quot;Marketing Service&quot;),</span><br><span class="line">        new ApiResource(&quot;locations&quot;, &quot;Locations Service&quot;),</span><br><span class="line">        new ApiResource(&quot;mobileshoppingagg&quot;, &quot;Mobile Shopping Aggregator&quot;),</span><br><span class="line">        new ApiResource(&quot;webshoppingagg&quot;, &quot;Web Shopping Aggregator&quot;),</span><br><span class="line">        new ApiResource(&quot;orders.signalrhub&quot;, &quot;Ordering Signalr Hub&quot;)</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-迁移数据库上下文"><a href="#5-迁移数据库上下文" class="headerlink" title="5. 迁移数据库上下文"></a>5. 迁移数据库上下文</h2><p>下面就把提前在代码预置的种子数据迁移到数据库中，我们如何做呢？IdentityServer为配置数据和操作数据分别定义了<code>DBContext</code>用于持久化，配置数据对应<code>ConfigurationDbContext</code>，操作数据对应<code>PersistedGrantDbContext</code>。代码如下所示：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    BuildWebHost(args)</span><br><span class="line">        .MigrateDbContext&lt;PersistedGrantDbContext&gt;((_, __) &#x3D;&gt; &#123; &#125;)&#x2F;&#x2F;迁移操作数据库</span><br><span class="line">        .MigrateDbContext&lt;ApplicationDbContext&gt;((context, services) &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            var env &#x3D; services.GetService&lt;IHostingEnvironment&gt;();</span><br><span class="line">            var logger &#x3D; services.GetService&lt;ILogger&lt;ApplicationDbContextSeed&gt;&gt;();</span><br><span class="line">            var settings &#x3D; services.GetService&lt;IOptions&lt;AppSettings&gt;&gt;();</span><br><span class="line"></span><br><span class="line">            new ApplicationDbContextSeed()</span><br><span class="line">                .SeedAsync(context, env, logger, settings)</span><br><span class="line">                .Wait();</span><br><span class="line">        &#125;)&#x2F;&#x2F;迁移用户数据库</span><br><span class="line">        .MigrateDbContext&lt;ConfigurationDbContext&gt;((context,services)&#x3D;&gt; </span><br><span class="line">        &#123;</span><br><span class="line">            var configuration &#x3D; services.GetService&lt;IConfiguration&gt;();</span><br><span class="line"></span><br><span class="line">            new ConfigurationDbContextSeed()</span><br><span class="line">                .SeedAsync(context, configuration)</span><br><span class="line">                .Wait();</span><br><span class="line">        &#125;)&#x2F;&#x2F;迁移配置数据库</span><br><span class="line">        .Run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，本服务的核心代码已解析完毕。</p>
<p>最终的生成的数据库如下图所示：<br><img src="/images/eshoponcontainers-identity-microservice-3/2799767-7f7adefcc2ac323d.png" alt="IdentityDb"></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>本文从业务和技术上对本服务进行剖析，介绍了其技术选型，并紧接着简要介绍了ASP.NET Core Identity和IdentityServer4，最后分析源码，一步步揭开其神秘的面纱。至于客户端和其他微服务服务如何使用Identity microservice进行认证和授权，我将在后续文章再行讲解。</p>
<p>如果对ASP.NET Core Idenity和IdentityServer4不太了解，建议大家博客园阅读<strong><a href="https://www.cnblogs.com/RainingNight" target="_blank" rel="noopener">雨夜朦胧</a>、<a href="https://www.cnblogs.com/stulzq/" target="_blank" rel="noopener">晓晨Master</a>和<a href="https://www.cnblogs.com/savorboard/p/aspnetcore-identity.html" target="_blank" rel="noopener">Savorboard </a></strong><br>的博客进行系统学习后，再重读本文，相信你对Identity microservice的实现机制豁然开朗。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/RainingNight/p/introduce-basic-authentication-in-asp-net-core.html" target="_blank" rel="noopener">雨夜朦胧 – ASP.NET Core 认证与授权:初识认证/授权</a><br><a href="https://www.cnblogs.com/savorboard/p/aspnetcore-identity.html" target="_blank" rel="noopener">Savorboard – ASP.NET Core 之 Identity 入门（一）</a><br><a href="https://www.cnblogs.com/stulzq/p/8120518.html" target="_blank" rel="noopener">晓晨Master – IdentityServer（14）- 通过EntityFramework Core持久化配置和操作数据</a><br><a href="https://www.cnblogs.com/sheng-jie/p/9430920.html" target="_blank" rel="noopener">IdentityServer4 知多少</a><br><a href="https://www.cnblogs.com/sheng-jie/p/6564520.html" target="_blank" rel="noopener">OAuth2.0 知多少</a></p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>eShopOnContainers</tag>
      </tags>
  </entry>
  <entry>
    <title>eShopOnContainers 知多少[9]：Ocelot gateways</title>
    <url>/post/eshoponcontainers-ocelot-gateway-9/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>客户端与微服务的通信问题永远是一个绕不开的问题，对于小型微服务应用，客户端与微服务可以使用直连的方式进行通信，但对于对于大型的微服务应用我们将不得不面对以下问题：</p>
<ol>
<li>如何降低客户端到后台的请求数量，并减少与多个微服务的无效交互？</li>
<li>如何处理微服务间的交叉问题，比如授权、数据转换和动态请求派发？</li>
<li>客户端如何与使用非互联网友好协议的服务进行交互？</li>
<li>如何打造移动端友好的服务？</li>
</ol>
<p>而解决这一问题的方法之一就是借助API网关，其允许我们按需组合某些微服务以提供单一入口。</p>
<p>接下来，本文就来梳理一下eShopOnContainers是如何集成Ocelot网关来进行通信的。</p>
<p><img src="/images/eshoponcontainers-ocelot-gateway-9/2799767-6df888bfb800d24b.png" alt="使用自定义的API 网关服务"></p>
<h1 id="Hello-Ocelot"><a href="#Hello-Ocelot" class="headerlink" title="Hello Ocelot"></a>Hello Ocelot</h1><p>关于Ocelot，张队在Github上贴心的整理了<strong><a href="https://github.com/geffzhang/awesome-ocelot" target="_blank" rel="noopener">awesome-ocelot</a></strong>系列以便于我们学习。这里就简单介绍下Ocelot，不过多展开。<br>Ocelot是一个开源的轻量级的基于ASP.NET Core构建的快速且可扩展的API网关，核心功能包括路由、请求聚合、限速和负载均衡，集成了IdentityServer4以提供身份认证和授权，基于Consul提供了服务发现能力，借助Polly实现了服务熔断，能够很好的和k8s和Service Fabric集成。</p>
<h1 id="Ocelot-集成"><a href="#Ocelot-集成" class="headerlink" title="Ocelot 集成"></a>Ocelot 集成</h1><p>eShopOnContainers中的以下六个微服务都是通过网关API进行发布的。<br><img src="/images/eshoponcontainers-ocelot-gateway-9/2799767-11e65f8b4d35c06d.png" alt=""></p>
<p>引入网关层后，eShopOnContainers的整体架构如下图所示：<br><img src="/images/eshoponcontainers-ocelot-gateway-9/2799767-cddf9d8899d1b5e2.png" alt="引入网关层后的整体架构设计"></p>
<p>从代码结构来看，其基于业务边界（Marketing和Shopping）分别为Mobile和Web端建立多个网关项目，这样做利于隔离变化，降低耦合，且保证开发团队的独立自主性。所以我们在设计网关时也应注意到这一点，切忌设计大一统的单一API网关，以避免整个微服务架构体系的过度耦合。在网关设计中应当根据业务和领域去决定API网关的边界，尽量设计细粒度而非粗粒度的API网关。</p>
<p>eShopOnContainers中<code>ApiGateways</code>文件下是相关的网关项目。相关项目结构如下图所示。</p>
<p><img src="/images/eshoponcontainers-ocelot-gateway-9/2799767-d7346fe9e4650a78.png" alt="ApiGateways 代码结构"></p>
<p>从代码结构看，有四个<code>configuration.json</code>文件，该文件就是ocelot的配置文件，其中主要包含两个节点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;ReRoutes&quot;: [],</span><br><span class="line"> &quot;GlobalConfiguration&quot;: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那4个独立的配置文件是怎样设计成4个独立的API网关的呢？<br>在eShopOnContainers中，首先基于<code>OcelotApiGw</code>项目构建单个Ocelot API网关Docker容器镜像，然后在运行时，通过使用<code>docker volume</code>分别挂载不同路径下的<code>configuration.json</code>文件来启动不同类型的API-Gateway容器。示意图如下：<br><img src="/images/eshoponcontainers-ocelot-gateway-9/2799767-97b8124b36117983.png" alt="重用Ocelot Docker镜像启动多个网关容器服务"></p>
<p><code>docker-compse.yml</code>中相关配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; docker-compse.yml</span><br><span class="line">mobileshoppingapigw:</span><br><span class="line"> image: eshop&#x2F;ocelotapigw:$&#123;TAG:-latest&#125;</span><br><span class="line"> build:</span><br><span class="line"> context: .</span><br><span class="line"> dockerfile: src&#x2F;ApiGateways&#x2F;ApiGw-Base&#x2F;Dockerfile</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; docker-compse.override.yml</span><br><span class="line">mobileshoppingapigw:</span><br><span class="line"> environment:</span><br><span class="line"> - ASPNETCORE_ENVIRONMENT&#x3D;Development</span><br><span class="line"> - IdentityUrl&#x3D;http:&#x2F;&#x2F;identity.api</span><br><span class="line"> ports:</span><br><span class="line"> - &quot;5200:80&quot;</span><br><span class="line"> volumes:</span><br><span class="line"> - .&#x2F;src&#x2F;ApiGateways&#x2F;Mobile.Bff.Shopping&#x2F;apigw:&#x2F;app&#x2F;configuration</span><br></pre></td></tr></table></figure>
<p>通过这种方式将API网关分成多个API网关，不仅可以同时重复使用相同的Ocelot Docker镜像，而且开发团队可以专注于团队所属微服务的开发，并通过独立的Ocelot配置文件来管理自己的API网关。</p>
<p>而关于Ocelot的代码集成，主要就是指定配置文件以及注册Ocelot中间件。核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void ConfigureServices(IServiceCollection services)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;..</span><br><span class="line">    services.AddOcelot (new ConfigurationBuilder ()</span><br><span class="line">    .AddJsonFile (Path.Combine (&quot;configuration&quot;, &quot;configuration.json&quot;))</span><br><span class="line">    .Build ());</span><br><span class="line">&#125;</span><br><span class="line">public void Configure(IApplicationBuilder app, IHostingEnvironment env)</span><br><span class="line">&#123;</span><br><span class="line">     &#x2F;&#x2F;...</span><br><span class="line">    app.UseOcelot().Wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="请求聚合"><a href="#请求聚合" class="headerlink" title="请求聚合"></a>请求聚合</h1><p>在单体应用中时，进行页面展示时，可以一次性关联查询所需的对象并返回，但是对于微服务应用来说，某一个页面的展示可能需要涉及多个微服务的数据，那如何进行将多个微服务的数据进行聚合呢？首先，不可否认的是，Ocelot提供了请求聚合功能，但是就其灵活性而言，远不能满足我们的需求。因此，一般会选择自定义聚合器来完成灵活的聚合功能。在eShopOnContainers中就是通过独立ASP.NET Core Web API项目来提供明确的聚合服务。<code>Mobile.Shopping.HttpAggregator</code>和<code>Web.Shopping.HttpAggregator</code>即是用于提供自定义的请求聚合服务。</p>
<p><img src="/images/eshoponcontainers-ocelot-gateway-9/2799767-6303c1e408d91ec0.png" alt="使用聚合服务的架构"></p>
<p>下面就以<code>Web.Shopping.HttpAggregator</code>项目为例来讲解自定义聚合的实现思路。<br>首先，该网关项目是基于ASP.NET Web API构建。其代码结构如下图所示：<br><img src="/images/eshoponcontainers-ocelot-gateway-9/2799767-9ff01f34b16ae3bb.png" alt="Web.Shopping.HttpAggregator 自定义聚合服务代码结构"></p>
<p>其核心思路是自定义网关服务借助HttpClient发起请求。我们来看一下<code>BasketService</code>的实现代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BasketService : IBasketService</span><br><span class="line">&#123;</span><br><span class="line">    private readonly HttpClient _apiClient;</span><br><span class="line">    private readonly ILogger&lt;BasketService&gt; _logger;</span><br><span class="line">    private readonly UrlsConfig _urls;</span><br><span class="line">    public BasketService(HttpClient httpClient,ILogger&lt;BasketService&gt; logger, IOptions&lt;UrlsConfig&gt; config)</span><br><span class="line">    &#123;</span><br><span class="line">        _apiClient &#x3D; httpClient;</span><br><span class="line">        _logger &#x3D; logger;</span><br><span class="line">        _urls &#x3D; config.Value;</span><br><span class="line">    &#125;</span><br><span class="line">    public async Task&lt;BasketData&gt; GetById(string id)</span><br><span class="line">    &#123;</span><br><span class="line">        var data &#x3D; await _apiClient.GetStringAsync(_urls.Basket +  UrlsConfig.BasketOperations.GetItemById(id));</span><br><span class="line">        var basket &#x3D; !string.IsNullOrEmpty(data) ? JsonConvert.DeserializeObject&lt;BasketData&gt;(data) : null;</span><br><span class="line">        return basket;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中主要是通过构造函数注入<code>HttpClient</code>，然后方法中借助<code>HttpClient</code>实例发起相应请求。那<code>HttpClient</code>实例是如何注册的呢，我们来看下启动类里服务注册逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static IServiceCollection AddApplicationServices(this IServiceCollection services)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;register delegating handlers</span><br><span class="line">    services.AddTransient&lt;HttpClientAuthorizationDelegatingHandler&gt;();</span><br><span class="line">    services.AddSingleton&lt;IHttpContextAccessor, HttpContextAccessor&gt;();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;register http services  </span><br><span class="line">    services.AddHttpClient&lt;IBasketService, BasketService&gt;()</span><br><span class="line">        .AddHttpMessageHandler&lt;HttpClientAuthorizationDelegatingHandler&gt;()</span><br><span class="line">        .AddPolicyHandler(GetRetryPolicy())</span><br><span class="line">        .AddPolicyHandler(GetCircuitBreakerPolicy());</span><br><span class="line"></span><br><span class="line">    services.AddHttpClient&lt;ICatalogService, CatalogService&gt;()</span><br><span class="line">        .AddPolicyHandler(GetRetryPolicy())</span><br><span class="line">        .AddPolicyHandler(GetCircuitBreakerPolicy());</span><br><span class="line"></span><br><span class="line">    services.AddHttpClient&lt;IOrderApiClient, OrderApiClient&gt;()</span><br><span class="line">        .AddHttpMessageHandler&lt;HttpClientAuthorizationDelegatingHandler&gt;()</span><br><span class="line">        .AddPolicyHandler(GetRetryPolicy())</span><br><span class="line">        .AddPolicyHandler(GetCircuitBreakerPolicy());</span><br><span class="line">    return services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看到主要做了三件事：</p>
<ol>
<li>注册<code>HttpClientAuthorizationDelegatingHandler</code>负责为HttpClient构造<code>Authorization</code>请求头</li>
<li>注册<code>IHttpContextAccessor</code>用于获取<code>HttpContext</code></li>
<li>为三个网关服务分别注册独立的<code>HttpClient</code>，其中<code>IBasketServie</code>和<code>IOrderApiClient</code>需要认证，所以注册了<code>HttpClientAuthorizationDelegatingHandler</code>用于构造<code>Authorization</code>请求头。另外，分别注册了<code>Polly</code>的请求重试和断路器策略。</li>
</ol>
<p>那<code>HttpClientAuthorizationDelegatingHandler</code>是如何构造<code>Authorization</code>请求头的呢？直接看代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HttpClientAuthorizationDelegatingHandler</span><br><span class="line">     : DelegatingHandler</span><br><span class="line">&#123;</span><br><span class="line">    private readonly IHttpContextAccessor _httpContextAccesor;</span><br><span class="line">    public HttpClientAuthorizationDelegatingHandler(IHttpContextAccessor httpContextAccesor)</span><br><span class="line">    &#123;</span><br><span class="line">        _httpContextAccesor &#x3D; httpContextAccesor;</span><br><span class="line">    &#125;</span><br><span class="line">    protected override async Task&lt;HttpResponseMessage&gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)</span><br><span class="line">    &#123;</span><br><span class="line">        var authorizationHeader &#x3D; _httpContextAccesor.HttpContext</span><br><span class="line">            .Request.Headers[&quot;Authorization&quot;];</span><br><span class="line">        if (!string.IsNullOrEmpty(authorizationHeader))</span><br><span class="line">        &#123;</span><br><span class="line">            request.Headers.Add(&quot;Authorization&quot;, new List&lt;string&gt;() &#123; authorizationHeader &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        var token &#x3D; await GetToken();</span><br><span class="line">        if (token !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            request.Headers.Authorization &#x3D; new AuthenticationHeaderValue(&quot;Bearer&quot;, token);</span><br><span class="line">        &#125;</span><br><span class="line">        return await base.SendAsync(request, cancellationToken);</span><br><span class="line">    &#125;</span><br><span class="line">    async Task&lt;string&gt; GetToken()</span><br><span class="line">    &#123;</span><br><span class="line">        const string ACCESS_TOKEN &#x3D; &quot;access_token&quot;;</span><br><span class="line">        return await _httpContextAccesor.HttpContext</span><br><span class="line">            .GetTokenAsync(ACCESS_TOKEN);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码实现也很简单：首先从<code>_httpContextAccesor.HttpContext.Request.Headers[&quot;Authorization&quot;]</code>中取，若没有则从<code>_httpContextAccesor.HttpContext.GetTokenAsync(&quot;access_token&quot;)</code>中取，拿到访问令牌后，添加到请求头<code>request.Headers.Authorization = new AuthenticationHeaderValue(&quot;Bearer&quot;, token);</code>即可。</p>
<p>这里你肯定有个疑问就是：为什么不是到Identity microservices去取访问令牌，而是直接从<code>_httpContextAccesor.HttpContext.GetTokenAsync(&quot;access_token&quot;)</code>中取访问令牌？</p>
<p>Good Question，因为对于网关项目而言，其本身也是需要认证的，在访问网关暴露的需要认证的API时，其已经同Identity microservices协商并获取到令牌，并将令牌内置到<code>HttpContext</code>中了。所以，对于同一个请求上下文，我们仅需将网关项目申请到的令牌传递下去即可。</p>
<h1 id="Ocelot网关中如何集成认证和授权"><a href="#Ocelot网关中如何集成认证和授权" class="headerlink" title="Ocelot网关中如何集成认证和授权"></a>Ocelot网关中如何集成认证和授权</h1><p>不管是独立的微服务还是网关，认证和授权问题都是要考虑的。Ocelot允许我们直接在网关内的进行身份验证，如下图所示：<br><img src="/images/eshoponcontainers-ocelot-gateway-9/2799767-73c68efafdb967d6.png" alt="网关内身份验证"></p>
<p>因为认证授权作为微服务的交叉问题，所以将认证授权作为横切关注点设计为独立的微服务更符合关注点分离的思想。而Ocelot网关仅需简单的配置即可完成与外部认证授权服务的集成。</p>
<p><strong>1. 配置认证选项</strong><br>首先在<code>configuration.json</code>配置文件中为需要进行身份验证保护API的网关设置<code>AuthenticationProviderKey</code>。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;DownstreamPathTemplate&quot;: &quot;&#x2F;api&#x2F;&#123;version&#125;&#x2F;&#123;everything&#125;&quot;,</span><br><span class="line">  &quot;DownstreamScheme&quot;: &quot;http&quot;,</span><br><span class="line">  &quot;DownstreamHostAndPorts&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;Host&quot;: &quot;basket.api&quot;,</span><br><span class="line">      &quot;Port&quot;: 80</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;UpstreamPathTemplate&quot;: &quot;&#x2F;api&#x2F;&#123;version&#125;&#x2F;b&#x2F;&#123;everything&#125;&quot;,</span><br><span class="line">  &quot;UpstreamHttpMethod&quot;: [],</span><br><span class="line">  &quot;AuthenticationOptions&quot;: &#123;</span><br><span class="line">    &quot;AuthenticationProviderKey&quot;: &quot;IdentityApiKey&quot;,</span><br><span class="line">    &quot;AllowedScopes&quot;: []</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 注册认证服务</strong><br>当Ocelot运行时，它将根据Re-Routes节点中定义的<code>AuthenticationOptions.AuthenticationProviderKey</code>，去确认系统是否注册了相对应身份验证提供程序。如果没有，那么Ocelot将无法启动。如果有，则ReRoute将在执行时使用该提供程序。<br>在<code>OcelotApiGw</code>的启动配置中，就注册了<code>AuthenticationProviderKey：IdentityApiKey</code>的认证服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void ConfigureServices (IServiceCollection services) &#123;</span><br><span class="line">    var identityUrl &#x3D; _cfg.GetValue&lt;string&gt; (&quot;IdentityUrl&quot;);</span><br><span class="line">    var authenticationProviderKey &#x3D; &quot;IdentityApiKey&quot;;</span><br><span class="line">    &#x2F;&#x2F;…</span><br><span class="line">    services.AddAuthentication ()</span><br><span class="line">        .AddJwtBearer (authenticationProviderKey, x &#x3D;&gt; &#123;</span><br><span class="line">            x.Authority &#x3D; identityUrl;</span><br><span class="line">            x.RequireHttpsMetadata &#x3D; false;</span><br><span class="line">            x.TokenValidationParameters &#x3D; new</span><br><span class="line">            Microsoft.IdentityModel.Tokens.TokenValidationParameters () &#123;</span><br><span class="line">                ValidAudiences &#x3D; new [] &#123;</span><br><span class="line">                &quot;orders&quot;,</span><br><span class="line">                &quot;basket&quot;,</span><br><span class="line">                &quot;locations&quot;,</span><br><span class="line">                &quot;marketing&quot;,</span><br><span class="line">                &quot;mobileshoppingagg&quot;,</span><br><span class="line">                &quot;webshoppingagg&quot;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要说明一点的是<code>ValidAudiences</code>用来指定可被允许访问的服务。其与各个微服务启动类中<code>ConfigureServices()</code>内<code>AddJwtBearer()</code>指定的<code>Audience</code>相对应。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; prevent from mapping &quot;sub&quot; claim to nameidentifier.</span><br><span class="line">JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear ();</span><br><span class="line">var identityUrl &#x3D; Configuration.GetValue&lt;string&gt; (&quot;IdentityUrl&quot;);</span><br><span class="line">services.AddAuthentication (options &#x3D;&gt; &#123;</span><br><span class="line">    options.DefaultAuthenticateScheme &#x3D; JwtBearerDefaults.AuthenticationScheme</span><br><span class="line">    options.DefaultChallengeScheme &#x3D; JwtBearerDefaults.AuthenticationScheme;</span><br><span class="line">&#125;).AddJwtBearer (options &#x3D;&gt; &#123;</span><br><span class="line">    options.Authority &#x3D; identityUrl;</span><br><span class="line">    options.RequireHttpsMetadata &#x3D; false;</span><br><span class="line">    options.Audience &#x3D; &quot;basket&quot;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>3. 按需配置申明进行鉴权</strong><br>另外有一点不得不提的是，Ocelot支持在身份认证后进行基于声明的授权。仅需在<code>ReRoute</code>节点下配置<code>RouteClaimsRequirement</code>即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;RouteClaimsRequirement&quot;: &#123;</span><br><span class="line"> &quot;UserType&quot;: &quot;employee&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该示例中，当调用授权中间件时，Ocelot将查找用户是否在令牌中是否存在<code>UserType:employee</code>的申明。如果不存在，则用户将不被授权，并响应403。</p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>经过以上的讲解，想必你对eShopOnContainers中如何借助API 网关模式解决客户端与微服务的通信问题有所了解，但其就是万金油吗？API 网关模式也有其缺点所在。</p>
<ol>
<li>网关层与内部微服务间的高度耦合。</li>
<li>网关层可能出现单点故障。</li>
<li>API网关可能导致性能瓶颈。</li>
<li>API网关如果包含复杂的自定义逻辑和数据聚合，额外增加了团队的开发维护沟通成本。</li>
</ol>
<p>虽然IT没有银弹，但eShopOnContainers中网关模式的应用案例至少指明了一种解决问题的思路。而至于在实战场景中的技术选型，适合的就是最好的。</p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>eShopOnContainers</tag>
      </tags>
  </entry>
  <entry>
    <title>eShopOnContainers 知多少[8]：Ordering microservice</title>
    <url>/post/eshoponcontainers-ordering-microservice-8/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>Ordering microservice（订单微服务）就是处理订单的了，它与前面讲到的几个微服务相比要复杂的多。主要涉及以下业务逻辑：</p>
<ol>
<li>订单的创建、取消、支付、发货</li>
<li>库存的扣减</li>
</ol>
<h1 id="2-架构模式"><a href="#2-架构模式" class="headerlink" title="2. 架构模式"></a>2. 架构模式</h1><p><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-343d9d945b08bbf5.png" alt="简化的CQRS和DDD微服务设计"></p>
<p>如上图所示，该服务基于CQRS 和DDD来实现。</p>
<p><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-6fc65e19772eb543.png" alt="项目结构"></p>
<p>从项目结构来看，主要包括7个项目：</p>
<ol>
<li>Ordering.API：应用层</li>
<li>Ordering.Domain：领域层</li>
<li>Ordering.Infrastructure：基础设施层</li>
<li>Ordering.BackgroundTasks：后台任务</li>
<li>Ordering.SignalrHub：基于Signalr的消息推送和实时通信</li>
<li>Ordering.FunctionalTests：功能测试项目</li>
<li>Ordering.UnitTests：单元测试项目</li>
</ol>
<p>从以上的项目定义来看，该微服务的设计并符合DDD经典的四层架构。</p>
<p><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-73fcf75187848a35.png" alt="Ordering.API对应DDD中分层"></p>
<p>核心技术选型：</p>
<ol>
<li>ASP.NET Core Web API</li>
<li>Entity Framework Core</li>
<li>SQL Server</li>
<li>Swashbuckle（可选）</li>
<li>Autofac</li>
<li>Eventbus</li>
<li>MediatR</li>
<li>SignalR</li>
<li>Dapper</li>
<li>Polly</li>
<li><a href="https://github.com/JeremySkinner/FluentValidation" target="_blank" rel="noopener">FluentValidator</a></li>
</ol>
<h1 id="3-简明DDD"><a href="#3-简明DDD" class="headerlink" title="3. 简明DDD"></a>3. 简明DDD</h1><p>领域驱动设计是一种方法论，用于解决软件复杂度问题。它强调以领域为核心驱动设计。主要包括战略和战术设计两大部分，其中战略设计指导我们在宏观层面对问题域进行识别和划分，从而将大问题划分为多个小问题，分而治之。而战术设计从微观层面指导我们如何对领域进行建模。<br><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-ef01773a3d9cf4f0.png" alt="DDD开发过程"><br>其中战术设计了引入了很多核心要素，指导我们建模：</p>
<ol>
<li>值对象（Value Object）</li>
<li>实体（Entity）</li>
<li>领域服务（Domain Service）</li>
<li>领域事件（Domain Event）</li>
<li>资源库（Repository）</li>
<li>工厂（Factory）</li>
<li>聚合（Aggregate）</li>
<li>应用服务（Application Service）<br><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-8a9983089971134f.png" alt="战术要素"></li>
</ol>
<p>其中实体、值对象和领域服务用于表示领域模型，来实现领域逻辑。<br>聚合用于封装一到多个实体和值对象，确保业务完整性。<br>领域事件来丰富领域对象之间的交互。<br>工厂、资源库用于管理领域对象的生命周期。<br>应用服务是用来表达用例和用户故事。</p>
<p>有了以上的战术设计要素还不够，如果它们糅合在一起，还是会很混乱，因此DDD再通过分层架构来确保关注点分离，即将领域模型相关（实体、值对象、聚合、领域服务、领域事件）放到领域层，将资源库、工厂放到基础设施层，将应用服务放到应用层。以下就是DDD经典的四层架构：<br><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-4d370f5d388fc4b7.png" alt="DDD经典四层架构"></p>
<p><em>以上相关图片来源于：<a href="https://gitbook.cn/gitchat/author/5859f00b7ad84fe60dda4b28" target="_blank" rel="noopener">张逸 · 领域驱动战略设计实践</a></em></p>
<h1 id="4-Ordering-Domain：领域层"><a href="#4-Ordering-Domain：领域层" class="headerlink" title="4. Ordering.Domain：领域层"></a>4. Ordering.Domain：领域层</h1><p><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-094d769f601b4785.png" alt="项目结构"></p>
<p>如果对订单微服务应用DDD，那么要摒弃传统的面向数据库建模的思想，转向领域建模。该项目中主要定义了以下领域对象：</p>
<ul>
<li>Order：订单</li>
<li>OrderItem：订单项</li>
<li>OrderStatus：订单状态</li>
<li>Buyer：买家</li>
<li>Address：地址</li>
<li>PaymentMethod：支付方式</li>
<li>CardType：银行卡片类型</li>
</ul>
<p>在该示例项目中，定义了两个聚合：订单聚合和买家聚合，其中Order和Buyer分属两个聚合根，其中订单聚合通过持有买家聚合的唯一ID进行关联。如下图所示：<br> <img src="/images/eshoponcontainers-ordering-microservice-8/2799767-8beb654e7b16903d.png" alt="订单聚会和买家聚合"></p>
<p>我们依次来看其对实体、值对象、聚合、资源库、领域事件的实现方式。</p>
<h2 id="4-1-实体、值对象与聚合"><a href="#4-1-实体、值对象与聚合" class="headerlink" title="4.1. 实体、值对象与聚合"></a>4.1. 实体、值对象与聚合</h2><p><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-ee03b90b483b4124.png" alt="实体相关类图"></p>
<p>实体与值对象最大的区别在于，实体有标识符可变，值对象不可变。为了保证领域的不变性，也就是更好的封装，所有的属性字段都设置为<code>private set</code>，集合都设置为只读的，通过构造函数进行初始化，通过暴露方法供外部调用修改。<br>从类图中我们可以看出，其主要定义了一个<code>Entity</code>抽象基类，所有的实体通过继承<code>Entity</code>来实现命名约定。这里面有两点需要说明：</p>
<ol>
<li>通过<code>Id</code>属性确保唯一标识符</li>
<li>重写<code>Equals</code>和<code>GetHashCode</code>方法（hash值计算：<code>this.Id.GetHashCode() ^ 31</code>)</li>
<li>定义<code>DomainEvents</code>来存储实体关联的领域事件（领域事件的发生归根结底是由于领域对象的状态变化引起的，而领域对象[实体、值对象和聚合]）中值对象是不可变的，而聚合往往包含多个实体，所以将领域事件关联在实体上最合适不过。）</li>
</ol>
<p><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-38e6a3e13569efaf.png" alt="值对象相关类图"></p>
<p>同样，值对象也是通过继承抽象基类<code>ValueObject</code>来进行约定。其主要也是重载了<code>Equals</code>和<code>GetHashCode</code>和方法。这里面有必要学习其<code>GetHashCode</code>的实现技巧：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ValueObject.cs</span><br><span class="line">protected abstract IEnumerable&lt;object&gt; GetAtomicValues();</span><br><span class="line">public override int GetHashCode()</span><br><span class="line">&#123;</span><br><span class="line">    return GetAtomicValues()</span><br><span class="line">     .Select(x &#x3D;&gt; x !&#x3D; null ? x.GetHashCode() : 0)</span><br><span class="line">     .Aggregate((x, y) &#x3D;&gt; x ^ y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Address.cs</span><br><span class="line">protected override IEnumerable&lt;object&gt; GetAtomicValues()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Using a yield return statement to return each ele</span><br><span class="line">    yield return Street;</span><br><span class="line">    yield return City;</span><br><span class="line">    yield return State;</span><br><span class="line">    yield return Country;</span><br><span class="line">    yield return ZipCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，通过在基类定义<code>GetAtomicValues</code>方法，用来要求子类指定需要hash的字段，然后将每个字段取hash值，然后通过异或运算再行聚合得到唯一hash值。</p>
<p>所有对聚合中领域对象的操作都是通过聚合根来维护的。因此我们可以看到聚合根中定义了许多方法来处理领域逻辑。</p>
<h2 id="4-2-仓储"><a href="#4-2-仓储" class="headerlink" title="4.2. 仓储"></a>4.2. 仓储</h2><p><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-40dd2ace7ba84ea4.png" alt="仓储相关类图"><br>聚合中的领域对象的持久化借助仓储来完成的。其提供统一的入口来进行聚合内相关领域对象的CRUD，从而完成透明持久化。从图中看出，<code>IRepository</code>定义了一个<code>IUnitOfWork</code>属性，其代表工作单元，主要定义了两个方法<code>SaveChangesAsync</code>和<code>SaveEntitiesAsync</code>，借助事务一次性提交所有更改，以确保数据的完整性和有效性。</p>
<h2 id="4-3-领域事件"><a href="#4-3-领域事件" class="headerlink" title="4.3. 领域事件"></a>4.3. 领域事件</h2><p><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-1a8c9cb8dbd6a346.png" alt="领域事件相关类图"></p>
<p>从类图中可以看出一个共同特征，都实现了<code>INotification</code>接口。对MediatR熟悉的肯定一眼就明白了。是的，这个是<code>MediatR</code>中定义的接口。借助MediatR，来实现事件处理管道。通过进程内事件处理管道来驱动命令接收，并将它们（在内存中）路由到正确的事件处理器。<br>关于MeidatR可以参考我的这篇博文：<a href="https://www.jianshu.com/p/583bcba352ec" target="_blank" rel="noopener">MediatR 知多少</a></p>
<p>而关于领域事件的处理，是通过继承<code>INotificationHanlder</code>接口来实现，这样<code>INotification</code>与<code>INotificationHandler</code>通过Ioc容器的服务注册，自动完成事件的订阅。而领域事件的处理其下放到了<code>Ordering.Api</code>中处理了。这里大家可能会有疑惑，既然叫领域事件，那为什么领域事件的处理不放到领域层呢？我们可以这样理解，事件是领域内触发，但对事件的处理，其并非都是业务逻辑的相关处理，比如订单创建成功后发送短信、邮件等就不属于业务逻辑。</p>
<p>eShopOnContainers中领域事件的触发时机并非是即时触发，选择的是延迟触发模式。具体的实现，后面会讲到。</p>
<h1 id="5-Ordering-Infrastructure：基础设施层"><a href="#5-Ordering-Infrastructure：基础设施层" class="headerlink" title="5. Ordering.Infrastructure：基础设施层"></a>5. Ordering.Infrastructure：基础设施层</h1><p>基础设施层主要用于提供基础服务，主要是用来实体映射和持久化。</p>
<p><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-6f022e44c3817c52.png" alt="Ordering.Infrastructure 代码结构"></p>
<p>从图中可以看到，主要包含以下业务处理：</p>
<ol>
<li>实体类型映射</li>
<li>幂等性控制器的实现</li>
<li>仓储的具体实现</li>
<li>数据库上下文的实现（UnitOfWork的实现）</li>
<li>领域事件的批量派发</li>
</ol>
<p>这里着重下第2、4、5点的介绍。</p>
<h2 id="5-1-幂等性控制器"><a href="#5-1-幂等性控制器" class="headerlink" title="5.1. 幂等性控制器"></a>5.1. 幂等性控制器</h2><p>幂等性是指某个操作多次执行但结果相同，换句话说，多次执行操作而不改变结果。举例来说：我们在写预插脚本时，会添加条件判断，当表中不存在数据时才将数据插入到表中。无论重复运行多少次 SQL 语句，结果一定是相同的，并且结果数据会包含在表中。</p>
<p>那怎样确保幂等性呢？一种方式就是确保操作本身的幂等性，比如可以创建一个表示“将产品价格设置为￥25”而不是“将产品价格增加￥5”的事件。此时可以安全地处理第一条消息，无论处理多少次结果都一样，而第二个消息则完全不同。<br>但是假设价格是一个时刻在变的，而你当前的操作就是要将产品价格增加￥5怎么办呢？显然这个操作是不能重复执行的。那我如何确保当前的操作只执行一次呢？<br>一种简便的方法就是记录每次执行的操作。该项目中的<code>Idempotency</code>文件夹就是来做这件事的。</p>
<p><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-75184d0ee8bb6fce.png" alt="Idempotency 类图"></p>
<p>从类图来看很简单，就是每次发送事件时生成一个唯一的Guid，然后构造一个<code>ClientRequest</code>对象实例持久化到数据库中，每次借助MediatR发送消息时都去检测消息是否已经发送。</p>
<p><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-c5a83a395e6ed3b6.png" alt="幂等性处理"></p>
<h2 id="5-2-UnitOfWork（工作单元的实现）"><a href="#5-2-UnitOfWork（工作单元的实现）" class="headerlink" title="5.2. UnitOfWork（工作单元的实现）"></a>5.2. UnitOfWork（工作单元的实现）</h2><p><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-051bd572cbeaa626.png" alt="Uow实现逻辑"></p>
<p>从代码来看，主要干了两件事：</p>
<ol>
<li>在提交变更之前，触发所有的领域事件</li>
<li>批量提交变更</li>
</ol>
<p>这里需要解释的一点是，为什么要在持久化之前而不是之后进行领域事件的触发呢？<br>这种触发就是延迟触发，将领域事件的发布与领域实体的持久化放到一个事务中来达到一致性。<br>当然这有利有弊，弊端就是当领域事件的处理非常耗时，很有可能会导致事务超时，最终导致提交失败。而避免这一问题，也只有做事务拆分，这时就要考虑最终一致性和相应的补偿措施，显然更复杂。</p>
<p>至此，我们可以总结下聚合、仓储与数据库之间的关系，如下图所示。<br><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-3729c88ddb502b81.png" alt=""></p>
<h1 id="6-Ordering-Api：应用层"><a href="#6-Ordering-Api：应用层" class="headerlink" title="6. Ordering.Api：应用层"></a>6. Ordering.Api：应用层</h1><p>应用层通过应用服务接口来暴露系统的全部功能。在这里主要涉及到：</p>
<ol>
<li>领域事件的处理</li>
<li>集成事件的处理</li>
<li>CQRS的实现</li>
<li>服务注册</li>
<li>认证授权</li>
<li>集成事件的订阅</li>
</ol>
<p><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-ca87ba8929dd58df.png" alt="项目结构"></p>
<h2 id="6-1-领域事件和集成事件"><a href="#6-1-领域事件和集成事件" class="headerlink" title="6.1. 领域事件和集成事件"></a>6.1. 领域事件和集成事件</h2><p>对于领域事件和集成事件的处理，我们需要先明白二者的区别。领域事件是发生在领域内的通信（同步或异步均可），而集成事件是基于多个微服务（其他限界上下文）甚至外部系统或应用间的异步通信。<br>领域事件是借助于MediatR的<code>INotification 和 INotificationHandler</code>的接口来实现。</p>
<p>其中<code>Application/Behaviors</code>文件夹中是实现MediatR中的<code>IPipelineBehavior</code>接口而定义的请求处理管道。</p>
<p><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-e1e2327f76bc49e1.png" alt=""></p>
<p>集成事件的发布订阅是借助事件总线来完成的，关于事件总线之前有文章详述，这里不再赘述。在此，仅代码举例其订阅方式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void ConfigureEventBus(IApplicationBuilder app)</span><br><span class="line">&#123;</span><br><span class="line">    var eventBus &#x3D; app.ApplicationServices.GetRequiredService&lt;BuildingBlocks.EventBus.Abstractions.IEventBus&gt;();</span><br><span class="line"></span><br><span class="line">    eventBus.Subscribe&lt;UserCheckoutAcceptedIntegrationEvent, IIntegrationEventHandler&lt;UserCheckoutAcceptedIntegrationEvent&gt;&gt;();</span><br><span class="line">&#x2F;&#x2F; some other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-基于MediatR实现的CQRS"><a href="#6-2-基于MediatR实现的CQRS" class="headerlink" title="6.2. 基于MediatR实现的CQRS"></a>6.2. 基于MediatR实现的CQRS</h2><p><a href="https://martinfowler.com/bliki/CQRS.html" target="_blank" rel="noopener">CQRS</a>（Command Query Responsibility Separation）：命令查询职责分离。是一种用来实现数据模型读写分离的架构模式。顾名思义，分为两大职责：</p>
<ol>
<li>命令职责</li>
<li>查询职责</li>
</ol>
<p>其核心思想是：在客户端就将数据的新增修改删除等动作和查询进行分离，前者称为Command，通过Command Bus对领域模型进行操作，而查询则从另外一条路径直接对数据进行操作，比如报表输出等。</p>
<p><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-5b8c260043ca3aa2.png" alt="CQRS"></p>
<p>对于命令职责，其是借助于MediatR充当的CommandBus，使用<code>IRequest</code>来定义命令，使用<code>IRequestHandler</code>来定义命令处理程序。我们可以看下<code>CancelOrderCommand</code>和<code>CancelOrderCommandHandler</code>的实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CancelOrderCommand : IRequest&lt;bool&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    [DataMember]</span><br><span class="line">    public int OrderNumber &#123; get; private set; &#125;</span><br><span class="line"></span><br><span class="line">    public CancelOrderCommand(int orderNumber)</span><br><span class="line">    &#123;</span><br><span class="line">        OrderNumber &#x3D; orderNumber;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CancelOrderCommandHandler : IRequestHandler&lt;CancelOrderCommand, bool&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private readonly IOrderRepository _orderRepository;</span><br><span class="line"></span><br><span class="line">    public CancelOrderCommandHandler(IOrderRepository orderRepository)</span><br><span class="line">    &#123;</span><br><span class="line">        _orderRepository &#x3D; orderRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public async Task&lt;bool&gt; Handle(CancelOrderCommand command, CancellationToken cancellationToken)</span><br><span class="line">    &#123;</span><br><span class="line">        var orderToUpdate &#x3D; await _orderRepository.GetAsync(command.OrderNumber);</span><br><span class="line">        if(orderToUpdate &#x3D;&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        orderToUpdate.SetCancelledStatus();</span><br><span class="line">        return await _orderRepository.UnitOfWork.SaveEntitiesAsync();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码中，有一点需要指出，就是所有Command中的属性都定义为<code>private set</code>，通过构造函数进行赋值，以确保Command的不变性。</p>
<p>对于查询职责，通过定义查询接口，借助Dapper直接写SQL语句来完成对数据库的直接读取。<br><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-e937282089ecb921.png" alt="查询示例"></p>
<p>而对于定义的命令，为了确保每个命令的合法性，通过引入第三方Nuget包<code>FluentValdiation</code>来进行命令的合法性校验。其代码也很简单，参考下图。<br><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-8f6dc9d49ea2a8eb.png" alt="校验器的定义和注册"></p>
<h2 id="6-3-服务注册"><a href="#6-3-服务注册" class="headerlink" title="6.3. 服务注册"></a>6.3. 服务注册</h2><p>整个订单微服务中所有服务的注册，都是放到应用层来做的，在<code>Ordering.Api\Infrastructure\AutofacModules</code>文件夹下通过继承<code>Autofac.Module</code>定义了两个Module来进行服务注册：</p>
<ul>
<li>ApplicationModule：自定义接口相关服务的注册</li>
<li>MediatorModule：Mediator相关接口服务的注册</li>
</ul>
<p>将所有的服务注册都放到高层模块来进行注册，有点违背关注点分离，各层应该关注本层的服务注册，所以这中实现方式是有待改进的。而具体如何改进，这里给大家提供一个线索，可参考ABP是如何实现进行服务注册的分离和整合的。</p>
<p><em>这里顺带提一下<code>Autofac</code>这个Ioc容器的一个限制，就是所有的服务注册必须在程序启动时完成注册，不允许运行时动态注册。</em></p>
<h1 id="7-Ordering-BackgroundTasks：后台任务"><a href="#7-Ordering-BackgroundTasks：后台任务" class="headerlink" title="7. Ordering.BackgroundTasks：后台任务"></a>7. Ordering.BackgroundTasks：后台任务</h1><p>后台任务，顾名思义，后台静默运行的任务，也称计划任务。在.NET Core 中，我们将这些类型的任务称为托管服务，因为它们是在主机/应用程序/微服务中托管的服务/逻辑。请注意，这种情况下托管服务仅简单表示具有后台任务逻辑类。</p>
<p>那我们如何实现托管服务了，一种简单的方式就是使用.NET Core 2.0之后版本中提供了一个名为<code>IHostedService</code>的新接口。当然也可以选择其他的一些后台任务框架，比如HangFire、Quartz。<br><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-6c256d17cec446e1.png" alt=""></p>
<p>该示例项目就是基于<code>BackgroundService</code>定义的一个后台任务。该任务主要用于轮询订单表中处于已提交超过1分钟的订单，然后发布集成事件到事件总线，最终用来将订单状态更新为待核验（库存）状态。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class BackgroundService : IHostedService, IDisposable</span><br><span class="line">&#123;</span><br><span class="line">    protected BackgroundService();</span><br><span class="line"></span><br><span class="line">    public virtual void Dispose();</span><br><span class="line">    public virtual Task StartAsync(CancellationToken cancellationToken);</span><br><span class="line">    [AsyncStateMachine(typeof(&lt;StopAsync&gt;d__4))]</span><br><span class="line">    public virtual Task StopAsync(CancellationToken cancellationToken);</span><br><span class="line">    protected abstract Task ExecuteAsync(CancellationToken stoppingToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从<code>BackgroundService</code>的方法申明中我们可以看出仅需实现<code>ExecuteAsync</code>方法即可。</p>
<p>完成后台任务的定义后，将服务注册到Ioc容器中即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public IServiceProvider ConfigureServices(IServiceCollection services)</span><br><span class="line">&#123;</span><br><span class="line"> &#x2F;&#x2F;Other DI registrations;</span><br><span class="line"> &#x2F;&#x2F; Register Hosted Services</span><br><span class="line"> services.AddSingleton&lt;IHostedService, GracePeriodManagerService&gt;();</span><br><span class="line"> services.AddSingleton&lt;IHostedService, MyHostedServiceB&gt;();</span><br><span class="line"> services.AddSingleton&lt;IHostedService, MyHostedServiceC&gt;();</span><br><span class="line"> &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-ced7a0cba0c216e0.png" alt=""></p>
<p>总之，<code>IHostedService</code>接口为 ASP.NET Core Web 应用程序启动后台任务提供了一种便捷的方法。它的优势主要在于：当主机本身关闭时，可以利用取消令牌来优雅的清理后台任务。</p>
<h1 id="8-Ordering-SignalrHub：即时通信"><a href="#8-Ordering-SignalrHub：即时通信" class="headerlink" title="8. Ordering.SignalrHub：即时通信"></a>8. Ordering.SignalrHub：即时通信</h1><p>在订单微服务中，当订单状态变更时，需要实时推送订单状态变更消息给客户端。而这就涉及到实时通信。实时 HTTP 通信意味着，当数据可用时，服务端代码会推送内容到已连接的客户端，而不是服务端等待客户端来请求新数据。</p>
<p>而对于实时通信，ASP.NET Core中<a href="https://github.com/aspnet/AspNetCore/tree/master/src/SignalR" target="_blank" rel="noopener">SignalR</a>可以满足我们的需求，其支持几种处理实时通信的技术以确保实时通信的可靠传输。 </p>
<ul>
<li><a href="https://tools.ietf.org/html/rfc7118" target="_blank" rel="noopener">WebSockets</a></li>
<li>Server-Sent Events</li>
<li>Long Polling</li>
</ul>
<p><img src="/images/eshoponcontainers-ordering-microservice-8/2799767-acef8253cd696e68.png" alt=""></p>
<p>该示例项目的实现思路很简单：</p>
<ol>
<li>订阅订单状态变更相关的集成事件</li>
<li>继承<code>SignalR.Hub</code>定义一个<code>NotificationsHub</code></li>
<li>在集成事件处理程序中调用Hub进行消息的实时推送</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 订阅集成事件</span><br><span class="line">private void ConfigureEventBus(IApplicationBuilder app)</span><br><span class="line">&#123;</span><br><span class="line">    var eventBus &#x3D; app.ApplicationServices.GetRequiredService&lt;IEventBus&gt;()；  </span><br><span class="line">    eventBus.Subscribe&lt;OrderStatusChangedToAwaitingValidationIntegrationEvent, OrderStatusChangedToAwaitingValidationIntegrationEventHandler&gt;();</span><br><span class="line">    eventBus.Subscribe&lt;OrderStatusChangedToPaidIntegrationEvent, OrderStatusChangedToPaidIntegrationEventHandler&gt;();</span><br><span class="line">    eventBus.Subscribe&lt;OrderStatusChangedToStockConfirmedIntegrationEvent, OrderStatusChangedToStockConfirmedIntegrationEventHandler&gt;();</span><br><span class="line">    eventBus.Subscribe&lt;OrderStatusChangedToShippedIntegrationEvent, OrderStatusChangedToShippedIntegrationEventHandler&gt;();</span><br><span class="line">    eventBus.Subscribe&lt;OrderStatusChangedToCancelledIntegrationEvent, OrderStatusChangedToCancelledIntegrationEventHandler&gt;();</span><br><span class="line">    eventBus.Subscribe&lt;OrderStatusChangedToSubmittedIntegrationEvent, OrderStatusChangedToSubmittedIntegrationEventHandler&gt;();  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 定义SignalR.Hub</span><br><span class="line">[Authorize]</span><br><span class="line">public class NotificationsHub : Hub</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    public override async Task OnConnectedAsync()</span><br><span class="line">    &#123;</span><br><span class="line">        await Groups.AddToGroupAsync(Context.ConnectionId, Context.User.Identity.Name);</span><br><span class="line">        await base.OnConnectedAsync();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public override async Task OnDisconnectedAsync(Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        await Groups.AddToGroupAsync(Context.ConnectionId, Context.User.Identity.Name);</span><br><span class="line">        await base.OnDisconnectedAsync(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 在集成事件处理器中调用Hub进行消息的实时推送</span><br><span class="line">public class OrderStatusChangedToPaidIntegrationEventHandler : IIntegrationEventHandler&lt;OrderStatusChangedToPaidIntegrationEvent&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private readonly IHubContext&lt;NotificationsHub&gt; _hubContext;</span><br><span class="line"></span><br><span class="line">    public OrderStatusChangedToPaidIntegrationEventHandler(IHubContext&lt;NotificationsHub&gt; hubContext)</span><br><span class="line">    &#123;</span><br><span class="line">        _hubContext &#x3D; hubContext ?? throw new ArgumentNullException(nameof(hubContext));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public async Task Handle(OrderStatusChangedToPaidIntegrationEvent @event)</span><br><span class="line">    &#123;</span><br><span class="line">        await _hubContext.Clients</span><br><span class="line">            .Group(@event.BuyerName)</span><br><span class="line">            .SendAsync(&quot;UpdatedOrderState&quot;, new &#123; OrderId &#x3D; @event.OrderId, Status &#x3D; @event.OrderStatus &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-最后"><a href="#8-最后" class="headerlink" title="8. 最后"></a>8. 最后</h1><p>订单微服务在整个eShopOnContainers中属于最复杂的一个微服务了。<br>通过对DDD的简要介绍，以及对每一层的技术选型以及实现的思路和逻辑的梳理，希望对你有所帮助。</p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>eShopOnContainers</tag>
      </tags>
  </entry>
  <entry>
    <title>eShopOnContainers 知多少[1]：总体概览</title>
    <url>/post/eshoponcontainers-overview-1/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在微服务大行其道的今天，Java阵营的Spring Boot、Spring Cloud、Dubbo微服务框架可谓是风水水起，也不得不感慨Java的生态圈的火爆。反观国内.NET阵营，微服务却不愠不火。</p>
<p>微软在其官网的架构体系上推出了<a href="https://github.com/dotnet-architecture/eShopOnContainers" target="_blank" rel="noopener">eShopOnContainers</a>微服务参考应用，用来推广基于.NET Core的微服务架构。我也将基于此来学习研究微服务，并分享自己的所学所得，形成一个系列，为.NET社区微服务的推广略尽绵薄之力。</p>
<h1 id="eShopOnContainers-简介"><a href="#eShopOnContainers-简介" class="headerlink" title="eShopOnContainers 简介"></a>eShopOnContainers 简介</h1><blockquote>
<p>Easy to get started sample reference microservice and container based application. Cross-platform on Linux and Windows Docker Containers, powered by .NET Core 2.1, Docker engine and optionally Azure, Kubernetes or Service Fabric. Supports Visual Studio 2017, VS for Mac and CLI based environments with Docker CLI, dotnet CLI, VS Code or any other…</p>
</blockquote>
<p>简单来说：<strong><a href="https://github.com/dotnet-architecture/eShopOnContainers" target="_blank" rel="noopener">eShopOnContainers</a>是一个简化版的基于.NET Core和Docker等技术开发的面向微服务架构的参考应用</strong>。</p>
<p>该参考应用是一个<strong>简化版的在线商城/电子商务应用</strong>。</p>
<p>虽然是简化版的微服务参考示例，但对没接触过Docker、DDD、微服务的同学来说，并不简单。其中不仅包含了很多术语、设计模式、架构风格，还使用了一系列的常见技术（RabbitMQ、EventBus、IdentityServer4、Polly、Api Gateway、Redis、CQRS、CAP、CI/CD等），还有一些相关工具（Docker、K8S等）。所以这将是一个难啃的骨头。</p>
<h1 id="总体介绍"><a href="#总体介绍" class="headerlink" title="总体介绍"></a>总体介绍</h1><p>eShopOnContainers作为跨平台的微服务架构，得益于.NET Core能够在Linux或Windows容器上运行。其包含基于浏览器的Web应用、基于Xamarin的Android、IOS、Windows/UWP 移动应用，以及服务端应用。其中服务端包含多个自治微服务（每个都拥有自己的数据/ db），并且每个微服务都有不同的实现形式（简单的CRUD与DDD / CQRS模式）。使用Http作为客户端应用程序之间的通信协议。支持异步通信，使用Integration Events(集成事件)和Event Bus(事件总线)进行数据更新传播。</p>
<h1 id="开发环境架构"><a href="#开发环境架构" class="headerlink" title="开发环境架构"></a>开发环境架构</h1><p><img src="/images/eshoponcontainers-overview-1/2799767-b67206c4174b987d.png" alt="针对开发环境的eShopOnContainers 示例应用程序架构"></p>
<p>一图胜千言，从上图可知，该架构主要包括两个部分：客户端应用和Docker主机中运行的服务端应用。</p>
<ol>
<li>客户端应用：基于浏览器的Web应用；基于Xamarin开发的Android、IOS、UWP移动应用。</li>
<li>服务端应用：部署在在Doker主机的系列微服务。</li>
</ol>
<p>其中服务端主要包括六大微服务：</p>
<ol>
<li>Identity Micsroservice（身份微服务）：用于身份认证和授权。使用SQL Server数据库。</li>
<li>Catalog microservice（产品目录微服务）：用于产品资料的维护。使用SQL Server数据库。</li>
<li>Ordering microservice（订单微服务）：用于订单逻辑的处理。使用SQL Server数据库。</li>
<li>Basket microservice（购物车微服务）：用于购物车逻辑的处理。使用Redis数据库。</li>
<li>Marketing microservice（市场营销微服务）：用于市场营销逻辑的处理。使用MongoDB/CosmosDB 和SQL Server数据库。</li>
<li>Locations microservice （位置微服务）：用于提供位置服务。使用MongoDB/CosmosDB 数据库。</li>
<li><em>[New]</em> Payment microservice （支付微服务）：用于处理支付逻辑。</li>
</ol>
<p>另外从上图我们还可以清晰看出其<strong>通信架构</strong>：</p>
<ol>
<li>客户端与微服务通过API网关通信：用于查询和接收来自客户端应用程序的更新或事务命令。</li>
<li>异步事件通信：通过事件总线传播来自微服务的更新或与外部应用程序集成。事件总线可使用任何消息代理架构技术（如 RabbitMQ）来实现，也可使用诸如 Azure 服务总线、NServiceBus、MassTransit 或 Brighter 等更高级的服务总线。</li>
</ol>
<h1 id="微服务架构模式"><a href="#微服务架构模式" class="headerlink" title="微服务架构模式"></a>微服务架构模式</h1><p><img src="/images/eshoponcontainers-overview-1/2799767-1b6af5a602d3ecd7.png" alt="微服务的不同实现形式"></p>
<p>上图列举的四个微服务主要使用了两种架构模式：</p>
<ol>
<li>基于数据驱动的CURD微服务</li>
<li>基于DDD的微服务</li>
</ol>
<p>而实际上，软件架构师和开发人员会使用不同的架构模式，比如（混合架构风格和架构模式）：</p>
<ol>
<li>简单的 CRUD，单层</li>
<li>传统N层</li>
<li>DDD N层</li>
<li>整洁架构</li>
<li>命令和查询分离（CQRS）</li>
<li>事件驱动架构</li>
</ol>
<p><img src="/images/eshoponcontainers-overview-1/2799767-2bfcba1475511ad9.png" alt="多种架构模式和多语言的微服务世界"></p>
<p>在由多个微服务组成的应用程序中，可以用不同方式实现每个微服务。每个微服务可能具有不同架构模式，并根据应用程序的性质、业务需求和优先级使用不同的语言和数据库。</p>
<p>这也就是微服务的灵活性与复杂性的源头。</p>
<h1 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h1><p><img src="/images/eshoponcontainers-overview-1/2799767-02477e568033b7a9.png" alt="image.png"></p>
<h1 id="系列计划"><a href="#系列计划" class="headerlink" title="系列计划"></a>系列计划</h1><p>对于微服务我也只是初步了解，该项目也将是我学习微服务的起点。所以我将以<strong>小白的视角</strong>（难免有所纰漏，请大家积极交流指正），尽量以通俗易懂的语言来梳理每一个知识点，并形成<strong>eShopOnContainers知多少系列</strong>，与大家共同学习进步。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/dotnet-architecture/eShopOnContainers" target="_blank" rel="noopener">eShopOnContainers 官方文档</a><br><a href="https://aka.ms/microservicesebook-zh-cn" target="_blank" rel="noopener">.NET 微服务：容器化 .NET 应用架构指南.pdf</a><a href="https://aka.ms/microservicesebook-zh-cn" target="_blank" rel="noopener">https://aka.ms/microservicesebook-zh-cn</a>)</p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>eShopOnContainers</tag>
      </tags>
  </entry>
  <entry>
    <title>eShopOnContainers 知多少[6]：持久化事件日志</title>
    <url>/post/eshoponcontainers-persist-eventlog-6/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>事件总线解决了微服务间如何基于集成事件进行异步通信的问题。然而只有事件总线正常运行，微服务之间基于事件的通信才得以运转。<br>而现实情况是，总有这样或那样的问题，导致事件总线不稳定或不可用，比如：网络中断，系统断电等等，这都可能导致微服务间的不一致性问题。<br>那如何解决事件总线故障导致的不一致问题呢？</p>
<ol>
<li>事件溯源</li>
<li>事件日志挖掘</li>
<li>发件箱模式<h1 id="2-问题"><a href="#2-问题" class="headerlink" title="2. 问题"></a>2. 问题</h1>既然上面提到了一致性问题，那具体的问题是什么呢，在什么情况才会发生呢？我想我有必要简单举例。上代码：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var oldPrice &#x3D; item.Price;</span><br><span class="line">item.Price &#x3D; product.Price;</span><br><span class="line">_context.CatalogItems.Update(item);</span><br><span class="line">var @event &#x3D; new ProductPriceChangedIntegrationEvent(item.Id, item.Price, oldPrice);</span><br><span class="line">&#x2F;&#x2F; Commit changes in original transaction</span><br><span class="line">await _context.SaveChangesAsync();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Publish integration event to the event bus</span><br><span class="line">&#x2F;&#x2F; (RabbitMQ or a service bus underneath)</span><br><span class="line">_eventBus.Publish(@event);</span><br></pre></td></tr></table></figure>
当产品价格更改后，代码将数据提交给数据库，然后发布<code>ProductPriceChangedIntegrationEvent</code> 事件。<br>如果服务在数据库更新后崩溃（奔溃发生在<code>_context.SaveChangesAsync()</code>代码执行之后，但又发生在集成事件成功发布前），就会导致本地微服务价格已成功更新，但集成事件未发布的问题。就会导致目录微服务中定义的价格和顾客购物车中缓存的价格不一致。</li>
</ol>
<h1 id="3-分析问题"><a href="#3-分析问题" class="headerlink" title="3. 分析问题"></a>3. 分析问题</h1><p>以上问题的关键在于是如何确保两个独立的操作的原子性。如果单从单体应用的角度来处理的话，我们完全是可以将他们放到同一个事务中去保证。然而在微服务中，就违背了其<strong>高可用</strong>的基本要求。因为一旦事件总线处于瘫痪状态，那么整个目录微服务就不可用了。这种强制通过事务保证的一致性，就引入了太多的问题依赖。</p>
<p>如果从微服务的角度来看，每个微服务负责各自的业务逻辑，对于目录微服务来说，它的关注点是产品的更新是否成功。至于借助事件总线通过异步事件实现微服务间的通信，并不是其关注点。这也就是关注点分离。换句话说，产品的更新不应该依赖外部状态。在这里，外部状态就是事件总线的可用性。</p>
<p>你可能会说了，既然不允许通过强事务保证一致性，那么如何解决一致性问题呢（好像绕了半天又回到了原点）？</p>
<p>这里就要引入强一致性和最终一致性的概念了。<br><strong>强一致性：也就是事务一致性，将多个操作放到单一事务处理。要么全部成功，要么全部失败。</strong><br><img src="/images/eshoponcontainers-persist-eventlog-6/2799767-a1cb098f2743061e.png" alt="事务一致性"><br><strong>最终一致性：通过将某些操作的执行延迟到稍后的时间来执行。若前面的操作执行成功，后续操作将延后执行。若前面的操作失败，后续的操作就不会执行。</strong><br><img src="/images/eshoponcontainers-persist-eventlog-6/2799767-6f5a98a93b77bf5e.png" alt="最终一致性"></p>
<p>到这里，我们实际要解决的问题就明确了：<strong>如何确保事件总线能够正确进行事件转发？</strong></p>
<p>换句话说：事件总线挂了，但是事件消息不能丢失。只要事件消息不丢，后面我们还有机会挽救（重新发布消息）。</p>
<p>如何保证事件消息不丢失呢？当然是持久化了。</p>
<h1 id="4-持久化事件源"><a href="#4-持久化事件源" class="headerlink" title="4. 持久化事件源"></a>4. 持久化事件源</h1><p>eShopOnContainers已经考虑了这一点，集成了事件日志用于持久化。我们直接来看类图：<br><img src="/images/eshoponcontainers-persist-eventlog-6/2799767-f6e0c51883a2ab1b.png" alt="事件日志"><br>从类图中看其实现逻辑也很简单，主要是定义了一个<code>IntegrationEventLogEntry</code>实体、<code>EventStateEnum</code>事件状态枚举和<code>IntegrationEventLogContext</code>EF上下文用于事件日志持久化。暴露<code>IIntegrationEventLogService</code>用于事件状态的更新。</p>
<p>其他微服务通过在启动类中注册<code>IntegrationEventLogContext</code>即可完成事件日志的集成。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">services.AddDbContext&lt;IntegrationEventLogContext&gt;(options &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.UseSqlServer(configuration[&quot;ConnectionString&quot;],</span><br><span class="line">        sqlServerOptionsAction: sqlOptions &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            sqlOptions.MigrationsAssembly(typeof(Startup)</span><br><span class="line">                .GetTypeInfo().Assembly.GetName().Name);</span><br><span class="line">            sqlOptions.EnableRetryOnFailure(maxRetryCount: 10,</span><br><span class="line">                maxRetryDelay: TimeSpan.FromSeconds(30), </span><br><span class="line">                errorNumbersToAdd: null);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用EF进行数据库迁移后，就会生成<code>IntergrationEventLog</code>表。如下图所示：<br><img src="/images/eshoponcontainers-persist-eventlog-6/2799767-c3d9ca9b52ea1d49.png" alt=""></p>
<h1 id="5-如何借助事件日志确保高可用"><a href="#5-如何借助事件日志确保高可用" class="headerlink" title="5. 如何借助事件日志确保高可用"></a>5. 如何借助事件日志确保高可用</h1><p>主要分两步走：</p>
<ol>
<li>应用程序开始本地数据库事务，然后更新领域实体状态，并将集成事件插入集成事件日志表中，最后提交事务来确保领域实体更新和保存事件日志所需的原子性。</li>
<li>发布事件</li>
</ol>
<p>第一步毋庸置疑，第二步发布事件，我们又有多种实现方式：</p>
<ol>
<li>在提交事务后立即发布集成事件，并将其标记为已发布。当微服务发生故障时，可以通过遍历存储的集成事件（未发布）执行补救措施。</li>
<li>将事件日志表用作一种队列。使用单独的线程或进程查询事件日志表，将事件发布到事件总<br>线，然后将事件标记为已发布。</li>
</ol>
<p><img src="/images/eshoponcontainers-persist-eventlog-6/2799767-7378c0b969776ba6.png" alt="通过单独的进程，将事件日志表作为队列进行事件发布"></p>
<p>这里很显然第二种方式更为稳妥。而eShopOnContainers出于简单考虑，采用了第一种方案，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using (var transaction &#x3D; _catalogContext.Database.BeginTransaction())</span><br><span class="line">&#123;</span><br><span class="line"> _catalogContext.CatalogItems.Update(catalogItem);</span><br><span class="line"> await _catalogContext.SaveChangesAsync();</span><br><span class="line"> &#x2F;&#x2F; Save to EventLog only if product price changed</span><br><span class="line"> if(raiseProductPriceChangedEvent)</span><br><span class="line"> await</span><br><span class="line">_integrationEventLogService.SaveEventAsync(priceChangedEvent);</span><br><span class="line"> transaction.Commit();</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Publish the intergation event through the event bus</span><br><span class="line">_eventBus.Publish(priceChangedEvent);</span><br><span class="line">integrationEventLogService.MarkEventAsPublishedAsync( priceChangedEvent);</span><br></pre></td></tr></table></figure>
<p>至此，eShopOnContainers确保事件总线能够正确转发消息的解决方案阐述完毕。你可能会问，这对应的是引言中的哪一种方案？都不是，你可以看作其是基于事件日志的简化版的事件溯源。</p>
<h1 id="6-仅此而已？"><a href="#6-仅此而已？" class="headerlink" title="6. 仅此而已？"></a>6. 仅此而已？</h1><p>通过持久化事件日志来避免事件发布失败导致的一致性问题，是一种有效措施。然而消息从发送到接收再到正常消费的过程中，每一个环节都可能故障，所以仅仅在消息发送端使用事件日志只是确保最终一致性的一小步。还有很多问题有待完善：</p>
<ol>
<li>消息发送成功了，但未被成功接收</li>
<li>消息发送且成功接收，但未被正确消费</li>
<li>消息重复发送，导致多次消费问题</li>
<li>消息被多个微服务订阅，如何确保每个微服务都成功接收并消费</li>
<li>等等</li>
</ol>
<p>而这些问题就留给大家思考吧。</p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>eShopOnContainers</tag>
      </tags>
  </entry>
  <entry>
    <title>eShopOnContainers 知多少[2]：Run起来</title>
    <url>/post/eshoponcontainers-run-2/</url>
    <content><![CDATA[<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ol>
<li>Win10（开启Hyper-V）</li>
<li><a href="http://dot.net/" target="_blank" rel="noopener">.NET Core SDK</a></li>
<li><a href="https://docs.docker.com/docker-for-windows/install/" target="_blank" rel="noopener">Docker for Windows</a></li>
<li><a href="https://visualstudio.microsoft.com" target="_blank" rel="noopener">VS2017 or VS Code</a></li>
<li><a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a></li>
<li><a href="https://go.microsoft.com/fwlink/?linkid=2014306" target="_blank" rel="noopener">SQL Server Management Studio</a>（可选）</li>
<li><a href="https://redisdesktop.com/" target="_blank" rel="noopener">Redis Desktop Manager</a>（可选）</li>
<li><a href="https://nodejs.org" target="_blank" rel="noopener">Node.js</a>（可选）</li>
<li><a href="https://bower.io/" target="_blank" rel="noopener">Bower</a>（可选）</li>
</ol>
<h1 id="Clone代码到本地"><a href="#Clone代码到本地" class="headerlink" title="Clone代码到本地"></a>Clone代码到本地</h1><p>执行命令<code>git clone https://github.com/dotnet/eShopOnContainers.git</code>clone代码到本地。使用默认<strong><code>DEV</code></strong>分支即可，该分支会保持最新改动，不要切换到其他分支。</p>
<p><img src="/images/eshoponcontainers-run-2/2799767-95499d84e9bbf5b1.png" alt="git clone"></p>
<h1 id="环境设置"><a href="#环境设置" class="headerlink" title="环境设置"></a>环境设置</h1><ol>
<li>给Docker分配CPU和内存</li>
</ol>
<p><em>温馨提示：以下的配置是最低需求，否则不保证项目能正常运行！</em><br><img src="/images/eshoponcontainers-run-2/2799767-20beee6caa8467b3.png" alt="内存和CPU设置"></p>
<ol start="2">
<li><p>设置共享驱动器<br><img src="/images/eshoponcontainers-run-2/2799767-f41eff4b0158ab41.png" alt="驱动器共享"></p>
</li>
<li><p>设置镜像加速<br>把<a href="https://www.daocloud.io/mirror#accelerator-doc" target="_blank" rel="noopener">DaoCloud</a>提供的镜像加速地址<code>http://f1361db2.m.daocloud.io</code>加到”registry-mirrors”的数组里，点击 Apply 。<br><img src="/images/eshoponcontainers-run-2/2799767-4c9ccc376c511389.png" alt="镜像加速"></p>
</li>
<li><p>勾选试验功能<br>如果遇到这个报错，<a href="https://stackoverflow.com/questions/48066994/docker-no-matching-manifest-for-windows-amd64-in-the-manifest-list-entries" target="_blank" rel="noopener">Docker: “no matching manifest for windows/amd64 in the manifest list entries”</a>，就勾选下面这个参数。<br><img src="/images/eshoponcontainers-run-2/2799767-6485e771cfc35f6a.png" alt="Experimental features"></p>
</li>
<li><p>防火墙设置<br>打开代码路径，找到<code>cli-windows\add-firewall-rules-for-sts-auth-thru-docker.ps1</code>power shell脚本并执行，打开本地防火墙中的端口，以便对STS（Security Token Service container）进行身份验证。<br><img src="/images/eshoponcontainers-run-2/2799767-286b591d724a9f33.png" alt="eShopOnContainers 防火墙入站规则设置"></p>
</li>
</ol>
<h1 id="构建并部署到本机Docker主机"><a href="#构建并部署到本机Docker主机" class="headerlink" title="构建并部署到本机Docker主机"></a>构建并部署到本机Docker主机</h1><p>进入eShopOnContainers根目录，执行<code>docker-compose build</code>。<br><img src="/images/eshoponcontainers-run-2/2799767-1c214b031d5a8daf.png" alt="构建"></p>
<p>去喝几杯咖啡或者打个盹吧，估计得好一会。完成后，执行<code>docker image</code>，可以查看已经构建好的镜像。<br><img src="/images/eshoponcontainers-run-2/2799767-52c4703c139a6218.png" alt="镜像列表"></p>
<p><em>PS：你可能会看到很多为<code>&lt;none&gt;</code>的镜像，这些是临时镜像，可以通过命令<code>docker rmi $(docker images -f &quot;dangling=true&quot; -q)</code>删除。</em></p>
<p>接下来执行<code>docker-compose up</code>命令部署到本地Docker主机。<br><img src="/images/eshoponcontainers-run-2/2799767-cc16e47bd13dbf93.png" alt="运行镜像"></p>
<p>启动完成后，执行<code>docker ps</code>命令查看已启动的容器列表。<br><img src="/images/eshoponcontainers-run-2/2799767-2d4abb8f1e0e1f10.png" alt="运行中的容器列表"></p>
<p>本地访问<a href="http://localhost:5100/" target="_blank" rel="noopener">http://localhost:5100/</a>，即可打开MVC Web应用。如下图所示：<br><img src="/images/eshoponcontainers-run-2/2799767-b96e8dbbb9be5854.png" alt="MVC Web"></p>
<h1 id="测试所有应用程序和微服务"><a href="#测试所有应用程序和微服务" class="headerlink" title="测试所有应用程序和微服务"></a>测试所有应用程序和微服务</h1><p>一旦完成容器部署，就可以从本地开发机器通过一下URL或连接字符串任何服务。</p>
<p><a href="https://github.com/dotnet-architecture/eShopOnContainers/wiki/03.-Setting-the-eShopOnContainers-solution-up-in-a-Windows-CLI-environment-(dotnet-CLI,-Docker-CLI-and-VS-Code)" target="_blank" rel="noopener"></a></p>
<ul>
<li>Web MVC: <a href="http://localhost:5100/" target="_blank" rel="noopener">http://localhost:5100</a></li>
<li>Web Spa: <a href="http://localhost:5104/" target="_blank" rel="noopener">http://localhost:5104</a> </li>
<li>Catalog microservice（产品目录微服务）: <a href="http://localhost:5101/" target="_blank" rel="noopener">http://localhost:5101</a> (Not secured)</li>
<li>Ordering microservice（订单微服务）: <a href="http://localhost:5102/" target="_blank" rel="noopener">http://localhost:5102</a> (Requires token for authorization)</li>
<li>Basket microservice（购物车微服务: <a href="http://localhost:5103/" target="_blank" rel="noopener">http://localhost:5103</a> (Requires token for authorization)</li>
<li>Identity microservice（认证授权微服务）: <a href="http://localhost:5105/" target="_blank" rel="noopener">http://localhost:5105</a></li>
<li>Web Status（健康检查): <a href="http://localhost:5107/" target="_blank" rel="noopener">http://localhost:5107</a> </li>
<li>Orders database （订单数据库）(SQL Server connection string): <code>Server=tcp:localhost,5432;Database=Microsoft.eShopOnContainers.Services.OrderingDb;User Id=sa;Password=Pass@word;</code></li>
<li>Catalog database (产品目录数据库）(SQL Server connection string): <code>Server=tcp:localhost,5434;Database=CatalogDB;User Id=sa;Password=Pass@word</code></li>
<li>ASP.NET Identity database（身份数据库） (SQL Server connection string): <code>Server=localhost,5433;Database=aspnet-Microsoft.eShopOnContainers;User Id=sa;Password=Pass@word</code></li>
<li>Basket data（购物车数据） (Redis): listening at localhost:6379</li>
</ul>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p><strong>1. 如何从外部连接SQL Server数据库</strong><br>Server：<strong>localhost,5433 （这里是逗号，不是冒号！！！）</strong><br>User：sa<br>Pwd：Pass@word<br><img src="/images/eshoponcontainers-run-2/2799767-0ffb8bcbb9e5fab1.png" alt="连接到容器内SQL Server数据库"></p>
<hr>
<p><strong>2. 构建报错问题</strong><br>构建eshop/webspa镜像时可能会报一下错误：<br><code>npm ERR! 404 Not Found: event-stream@https://registry.npmjs.org/event-stream/-/event-stream-3.3.6.tgz</code><br>解决方案是删除WebSap项目下的<code>package-lock.json</code>文件，重新构建即可。</p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>eShopOnContainers</tag>
      </tags>
  </entry>
  <entry>
    <title>Dapr 知多少 | 分布式应用运行时</title>
    <url>/post/how-much-you-know-about-dapr/</url>
    <content><![CDATA[<p><img src="/images/how-much-you-know-about-dapr/2799767-daf921ef4504be15.png" alt=""></p>
<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>Dapr 官方团队已于最近（2021.1.17）正式发布<a href="https://blog.dapr.io/posts/2021/02/17/announcing-dapr-v1.0/" target="_blank" rel="noopener">Dapr v1.0</a>，Dapr已正式生产可用，可以部署到自托管环境或 Kubernetes 集群。对于绝大多数开发者来说，想必对Dapr只是有所耳闻，而具体是什么（What），可以解决什么样的问题（Why&amp;How），有怎样的应用场景（Where），并不知悉。本文就尝试简要梳理下Dapr，并尝试回答以上问题。</p>
<h1 id="What’s-Dapr"><a href="#What’s-Dapr" class="headerlink" title="What’s Dapr"></a>What’s Dapr</h1><blockquote>
<p>Distributed Application Runtime. An event-driven, portable runtime for building microservices on cloud and edge.<br>分布式应用运行时。一个事件驱动、可移植的运行时用于在云上和边缘计算上构建微服务。</p>
</blockquote>
<p>以上是<a href="https://github.com/dapr" target="_blank" rel="noopener">Dapr官方GitHub仓库</a>上对Dapr的简介。文字虽短，口气却很大，因为其除了涵盖了当前所有的技术热点：分布式、云、微服务，还自我标榜为：<strong>分布式应用运行时</strong>。分布式应用我们或多或少有些了解，运行时也听到不少，比如常见的语言运行时：Java 运行时，.NET 运行时，Go 运行时等等，那运行时又是什么东西？简要来说：运行时是程序运行依赖的执行环境。以.NET 程序运行时CLR为例，它为.NET应用程序提供了一个托管的代码执行环境负责应用程序在整个执行期间的内存管理、线程管理、安全管理、远程管理、即时编译等。</p>
<p>那分布式应用运行时，就是提供分布式应用运行所依赖的的执行环境。那运行分布式应用需要哪些环境依赖呢？回答这个问题，我们要先思考开发分布式应用的挑战是什么？明确了挑战，那就找到了答案。</p>
<p>从单机到分布式，是追求更快和更高的性能，但也带来了更多的不确定性。比如，不确定计算机何时异常，不确定磁盘何时损坏，不确定网络通信的延迟，也不确定消息是否被正常消费。这些不确定性构成了分布式应用的挑战，简而言之：</p>
<ol>
<li>异构的机器与网络：稳定性问题</li>
<li>普遍的节点故障：可靠性问题</li>
<li>不可靠的网络：一致性问题</li>
</ol>
<p>面对这些挑战，业界提出了诸多的分布式理论、协议，如CAP定理，BASE理论，一致性协议2PC/3PC/ZAB，来保证系统的正常运行。虽然问题貌似是有了解决方案，但是应用的复杂度升高了。应用除了需要实现业务需求，还要兼顾非业务需求，集成诸如服务发现、负载均衡、失效转移、动态扩容、数据分片、调用链路监控等分布式系统的核心功能，对应用有很强的<strong>侵入性</strong>，这就是以Spring Cloud为代表的微服务框架的常见做法。</p>
<p>那如何解决侵入性的问题呢？这个问题随着容器编排技术的成熟有了新的解法。Kubernetes可以不侵入应用层，在容器层解决问题，比如K8S Service就具有服务发现、负载均衡的能力，HPA具有动态扩容的能力。随着K8S的快速发展，云原生的概念，也就越来越深入人心，那如何利用好K8S提供的基座能力，将更多的分布式能力下沉，让应用开发回归业务呢？<strong>其中Service Mesh提出的Sidecar模式，就很好的解决了微服务架构中网络通信的问题</strong>。Sidecar主要就是用来处理诸如服务发现、负载均衡、请求熔断等一系列非业务需求，应用在部署时动态插入Sidecar，服务间的通信通过Sidecar进行代理，以完成对服务间网络通信的接管。</p>
<p>到这里，微服务开发在Service Mesh的帮助下，已经渐渐回归业务本身，让更多的开发者看到了一丝曙光。It’s enough? 来看下Bilgin Ibryam在<a href="https://www.infoq.com/articles/multi-runtime-microservice-architecture/" target="_blank" rel="noopener">Multi-Runtime Microservices Architecture</a>文章中提及的分布式应用的四大需求：</p>
<p><img src="/images/how-much-you-know-about-dapr/2799767-12a37d38029530f3.png" alt="分布式应用的四大需求"></p>
<p>从上图可以看出，除了网络（Networking）外，生命周期（Lifecycle）、状态（State）、捆绑（Binding）也是分布式应用要解决的问题之一。网络问题可以借由Service Mesh 比如Istio予以解决。那其他三个该如何解决呢？又要应用自行开发集成吗？显然不符合应用回归业务本身的诉求。这时，Dapr登场了，Dapr提出的分布式应用运行时就是实现了以上四个需求并将其下沉作为分布式应用的运行环境。</p>
<p>简而言之：<strong>Dapr将分布式能力进行封装下沉作为运行时以简化分布式应用开发的技术复杂度。</strong></p>
<h1 id="How-Dapr-Works"><a href="#How-Dapr-Works" class="headerlink" title="How Dapr Works"></a>How Dapr Works</h1><p>那Dapr如何简化分布式应用的开发呢？下面我们来看一看Dapr的主要特性。<br><img src="/images/how-much-you-know-about-dapr/2799767-999e3583f2f9308f.png" alt="Any language, any framework, anywhere"><br>一图胜千言：Dapr通过以HTTP/gRPC API这种与语言无关的方式暴露封装的分布式能力供应用调用，从而支持使用任意语言或框架进行开发集成。目前官方已经提供了Go，Node，Python，.NET，Java， C++，PHP，Rust，Javascript的Sdk，简化Dapr的集成。</p>
<p>其中Dapr的核心构建块（Building Block）就是用来提供各种不同的分布式能力，我们来分别看一看。<br><img src="/images/how-much-you-know-about-dapr/2799767-dec9d699da1910fa.png" alt="Building Block"></p>
<p><strong>1. Service-to-service invocation（服务调用）</strong><br>提到跨服务方法调用，这个大家肯定会想，这简单啊，不就是服务暴露API就好了嘛。是，但不完全是。比如nodeapp暴露了一个API：<code>http://10.0.0.2:8000/neworder</code>，按照传统的方式，直接HTTP POST这个API访问就得了，但在Dapr中，其提供了服务间方法调用的接口规范，需要按照<br><code>POST/GET/PUT/DELETE http://localhost:&lt;daprPort&gt;/v1.0/invoke/&lt;appId&gt;/method/&lt;method-name&gt;</code>的格式进行访问。那假设pythonapp需要访问nodeapp的方法，就需要POST一个请求到<code>http://localhost:3500/v1.0/invoke/nodeapp/method/neworder</code>。你可能会想为何多此一举呢？此举的意义何在呢？目的很简单，就是为了实现对服务间网络通信的控制以完成诸如服务发现、流量控制、重试熔断、安全访问等，而这相关的网络控制功能就是集成在Dapr的Sidecar中，以对应用透明的方式集成进来的。整体的服务调用流程如下图所示：<br><img src="/images/how-much-you-know-about-dapr/2799767-4df6cd3ab8055bf0.png" alt="服务间调用"></p>
<p><em>PS：如果对Istio熟悉的同学需要注意，二者虽然都是通过Sidecar的模式进行网络控制，但二者是有有区别的。Dapr是以API的方式，而Istio是以代理的方式（不改变HTTP请求URI)。</em></p>
<p><strong>2. State management（状态管理）</strong><br>在进行微服务开发时，绕不开的话题就是服务间的状态共享、并发一致性问题。对于状态共享，你可能会说，各个服务连接到同一个Redis实例就OK了。是，但不得不考虑潜在的更新冲突的问题。Dapr 以更友好的HTTP API的方式进行状态的存储和读取，同时支持通过ETags进行并发控制，并支持通过选项设置并发和一致性行为。</p>
<ul>
<li>存储：<code>POST http://localhost:&lt;daprPort&gt;/v1.0/state/&lt;storename&gt;</code></li>
<li>读取：<code>GET http://localhost:&lt;daprPort&gt;/v1.0/state/&lt;storename&gt;/&lt;key&gt;</code></li>
<li>删除：<code>DELETE http://localhost:&lt;daprPort&gt;/v1.0/state/&lt;storename&gt;/&lt;key&gt;</code></li>
</ul>
<p>以下是保存状态的举例：</p>
<ul>
<li><code>concurrency</code>用于指定并发选项：first-write-wins/last-write-wins（以第一次写入为准/以最后一次写入为准），默认以最后一次写入为准。</li>
<li><code>consistency</code>用于指定一致性选项：strong/eventual（强一致性/最终一致性），默认为最终一致性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -X POST http:&#x2F;&#x2F;localhost:3500&#x2F;v1.0&#x2F;state&#x2F;starwars \</span><br><span class="line">  -H &quot;Content-Type: application&#x2F;json&quot; \</span><br><span class="line">  -d &#39;[</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;key&quot;: &quot;weapon&quot;,</span><br><span class="line">          &quot;value&quot;: &quot;DeathStar&quot;,</span><br><span class="line">          &quot;etag&quot;: &quot;xxxxx&quot;,</span><br><span class="line">          &quot;options&quot;: &#123;</span><br><span class="line">            &quot;concurrency&quot;: &quot;first-write&quot;,</span><br><span class="line">            &quot;consistency&quot;: &quot;strong&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]&#39;</span><br></pre></td></tr></table></figure>
<p>目前支持使用Azure CosmosDB、 Azure SQL Server、 PostgreSQL,、AWS DynamoDB、Redis 作为状态存储介质。</p>
<p><strong>3. Publish and subscribe（消息发布及订阅）</strong><br>发布订阅模式，老生常谈了，主要是用于微服务间基于消息进行相互通信。你可能也会说，这也要拿出来说，我搞个RabbitMQ/RocketMQ就是了。是的，但我还是要说，Dapr提供了一致性的消息发布、订阅API，而无需关注具体使用的是何种Message Broker，从而和底层基础设施解耦。</p>
<ul>
<li>发布：<code>POST http://localhost:&lt;daprPort&gt;/v1.0/publish/&lt;pubsubname&gt;/&lt;topic&gt;[?&lt;metadata&gt;]</code></li>
<li>获取可订阅主题：<code>GET http://localhost:&lt;appPort&gt;/dapr/subscribe</code></li>
<li>订阅：<code>POST http://localhost:&lt;appPort&gt;/&lt;path&gt;</code></li>
</ul>
<p><img src="/images/how-much-you-know-about-dapr/2799767-082d07ff5e75d4b5.png" alt="发布订阅"></p>
<p><strong>4. Resource bindings and triggers （资源绑定及事件触发）</strong><br>Dapr的Bindings与Azure Functions很类似，其是建立在事件驱动架构的基础之上的。通过建立触发器与资源的绑定，可以从任何外部源（例如数据库，队列，文件系统等）接收和发送事件，而无需借助消息队列，即可实现灵活的业务场景。Dapr的Bindings分为两种：</p>
<ol>
<li>Input Bindings（输入绑定）：当外部资源的事件发生时，借助输入绑定，你的应用即可通过特定的API：<code>POST http://localhost:&lt;appPort&gt;/&lt;name&gt;</code>收到外部资源的事件，用于处理特定逻辑。</li>
<li>Output Bindings（输出绑定）：输出绑定允许你调用外部资源。比如，在订单处理场景中，在订单创建成功后，可以将订单信息通过Dapr的绑定API：<code>POST/PUT http://localhost:&lt;daprPort&gt;/v1.0/bindings/&lt;name&gt;</code>输出到Kafka特定队列上。</li>
</ol>
<p><img src="/images/how-much-you-know-about-dapr/2799767-7890edd7396295b1.png" alt="资源绑定及事件触发"></p>
<p><strong>5. Actors</strong><br>Dapr中的Actor模型，和Orleans的Virtual Actor一脉相传，之前写过一篇文章<a href="https://www.jianshu.com/p/116da07c8469" target="_blank" rel="noopener">Orleans 知多少 | .NET Core 分布式框架</a>介绍过。简单来讲：Actor模型 = 状态 + 行为 + 消息。一个应用/服务由多个Actor组成，每个Actor都是一个独立的运行单元，拥有隔离的运行空间，在隔离的空间内，其有独立的状态和行为，不被外界干预，Actor之间通过消息进行交互，而同一时刻，每个Actor只能被单个线程执行，这样既有效避免了数据共享和并发问题，又确保了应用的伸缩性。</p>
<p>Actor模型大大简化了并发编程的复杂度，Dapr在Actor运行时中提供了许多功能，包括并发控制，状态管理，生命周期管理如Actor的激活/停用以及用于唤醒Actor的Timer(计时器)和Reminder(提醒)。这些功能同样也是通过<a href="https://docs.dapr.io/developing-applications/building-blocks/actors/howto-actors/" target="_blank" rel="noopener">API</a>的方式予以提供。</p>
<ul>
<li>调用Actor 方法：<code>POST/GET/PUT/DELETE http://localhost:3500/v1.0/actors/&lt;actorType&gt;/&lt;actorId&gt;/method/&lt;method&gt;</code></li>
<li>创建 Timer：<code>POST/PUT http://localhost:3500/v1.0/actors/&lt;actorType&gt;/&lt;actorId&gt;/timers/&lt;name&gt;</code></li>
<li>创建 Reminder：<code>POST/PUT http://localhost:3500/v1.0/actors/&lt;actorType&gt;/&lt;actorId&gt;/reminders/&lt;name&gt;</code></li>
</ul>
<p><strong>6. Observability（遥测）</strong><br>Dapr记录指标，日志，链路以调试和监视Dapr和用户应用的运行状况。 Dapr支持分布式跟踪，其使用W3C跟踪上下文标准和开放式遥测技术，可以轻松地诊断在生产环境中服务间的网络调用，并发送到不同的监视工具，如Prometheus。</p>
<p><strong>7. Secrets（安全）</strong><br>Dapr 提供了Secret管理，不过不同于K8S中的Secret，其支持与公有云和本地的Secret存储集成，以供应用检索使用。</p>
<h1 id="What-Can-We-Do-With-Dapr"><a href="#What-Can-We-Do-With-Dapr" class="headerlink" title="What Can We Do With Dapr"></a>What Can We Do With Dapr</h1><p>了解了Dapr是什么，以及其提供的特性，那Dapr的应用场景就一目了然了。也就是<a href="https://dapr.io" target="_blank" rel="noopener">官网首页</a>的Slogan：Simplify cloud-native application development–Focus on your application’s core logic and keep your code simple and portable。<br><em>简化云原生应用的开发，确保应用专注于业务，并保证代码简单可移植。</em></p>
<p>因此，在考虑云原生应用开发的技术选型时，尽情尝试吧，目前在国内阿里云也已采用。</p>
<h1 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h1><p>在云原生如火如荼发展之际，Dapr V1.0 的正式发布，为开发者指明了云原生时代微服务的开发方向。相信Dapr 在未来的微服务架构选型中必将占有一席之地！</p>
<blockquote>
<p>参考：<br><a href="https://www.cnblogs.com/xybaby/p/7787034.html" target="_blank" rel="noopener">什么是分布式系统，如何学习分布式系统</a><br><a href="https://mp.weixin.qq.com/s/ywvy3O0wTA4SSNE86hw0Xg" target="_blank" rel="noopener">Mecha：将Mesh进行到底</a></p>
</blockquote>
]]></content>
      <categories>
        <category>云原生</category>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>Dapr</tag>
        <tag>CloudNative</tag>
        <tag>K8S</tag>
        <tag>Microservice</tag>
      </tags>
  </entry>
  <entry>
    <title>诊断日志知多少 | DiagnosticSource 在.NET上的应用</title>
    <url>/post/how-much-you-know-about-diagnostic-in-dotnet/</url>
    <content><![CDATA[<p><img src="/images/how-much-you-know-about-diagnostic-in-dotnet/2799767-f9fe53d73a593166.png" alt=""></p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>最近为了解决ABP集成CAP时无法通过拦截器启用工作单元的问题，从小伙伴那里学了一招。借助<code>DiagnossticSource</code>，可以最小改动完成需求。关于DiagnosticSource晓东大佬18年在文章 <a href="https://www.cnblogs.com/savorboard/p/diagnostics.html" target="_blank" rel="noopener">在 .NET Core 中使用 Diagnostics (Diagnostic Source) 记录跟踪信息</a>就有介绍，文章开头就说明了Diagnostics 一直是一个被大多数开发者忽视的东西。是的，我也忽略了，这个好东西，有必要学习一下，下面就和大家简单聊一聊<a href="https://github.com/dotnet/runtime/tree/master/src/libraries/System.Diagnostics.DiagnosticSource/src/System/Diagnostics" target="_blank" rel="noopener">System.Diagnostics.DiagnosticSource</a>在.NET上的应用。</p>
<h1 id="2-System-Diagnostics-DiagnosticSource"><a href="#2-System-Diagnostics-DiagnosticSource" class="headerlink" title="2. System.Diagnostics.DiagnosticSource"></a>2. System.Diagnostics.DiagnosticSource</h1><p><code>Diagnostics</code>位于<code>System</code>命名空间下，由此可见<code>Diagnostics</code>在.NET 运行时中的地位不可小觑。其中<a href="https://github.com/dotnet/runtime/tree/master/src/libraries" target="_blank" rel="noopener">System.Diagnostics</a>命名空间下又包含不同类库，提供了允许与系统进程，事件日志和性能计数器进行交互的类。如下图所示：</p>
<p><img src="/images/how-much-you-know-about-diagnostic-in-dotnet/2799767-f00800a0b8dbfe92.png" alt="Diagnostic Namespace"></p>
<p>其中System.Diagnostics.DiagnosticSource模块，它允许对代码进行检测，以在生产时记录丰富的数据负载（可以传递不可序列化的数据类型），以便在<strong>进程内</strong>进行消耗。消费者可以在运行时动态发现数据源并订阅感兴趣的数据源。</p>
<p><img src="/images/how-much-you-know-about-diagnostic-in-dotnet/2799767-7197a426f10d7b66.png" alt=""></p>
<p>在展开之前，有必要先梳理下涉及的以下核心概念：</p>
<ul>
<li>IObservable：可观测对象</li>
<li>IObserver：观察者</li>
<li>DiagnosticSource ：诊断来源</li>
<li>DiagnosticListener：诊断监听器</li>
<li>Activity：活动</li>
</ul>
<h1 id="3-观察者模式（IObservable-amp-IObserver"><a href="#3-观察者模式（IObservable-amp-IObserver" class="headerlink" title="3. 观察者模式（IObservable &amp; IObserver)"></a>3. 观察者模式（IObservable &amp; IObserver)</h1><p><code>IObservable</code> 和<code>IObserver</code>位于<code>System</code>命名空间下，是.NET中对观察者模式的抽象。</p>
<blockquote>
<p>观察者设计模式使观察者能够从可观察对象订阅并接收通知。 它适用于需要基于推送通知的任何方案。 此模式定义可观察对象，以及零个、一个或多个观察者。 观察者订阅可观察对象，并且每当预定义的条件、事件或状态发生更改时，该可观察对象会通过调用其方法之一来自动通知所有观察者。 在此方法调用中，该可观察对象还可向观察者提供当前状态信息。 在 .NET Framework 中，通过实现泛型 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.iobservable-1" target="_blank" rel="noopener">System.IObservable<T></a> 和 <a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.iobserver-1" target="_blank" rel="noopener">System.IObserver<T></a> 接口来应用观察者设计模式。 泛型类型参数表示提供通知信息的类型。 </p>
</blockquote>
<p>第一次学习观察者模式，应该是大学课本中基于事件烧水的例子，咱们就基于此实现个简单的Demo吧。首先执行<code>dotnet new web -n Dotnet.Diagnostic.Demo</code>创建示例项目。</p>
<h2 id="3-1-定义可观察对象（实现IObservable接口）"><a href="#3-1-定义可观察对象（实现IObservable接口）" class="headerlink" title="3.1. 定义可观察对象（实现IObservable接口）"></a>3.1. 定义可观察对象（实现IObservable接口）</h2><p>对于烧水的示例，主要关注水温的变化，因此先定义<code>Temperature</code>来表示温度变化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Temperature</span><br><span class="line">&#123;</span><br><span class="line">    public Temperature(decimal temperature, DateTime date)</span><br><span class="line">    &#123;</span><br><span class="line">        Degree &#x3D; temperature;</span><br><span class="line">        Date &#x3D; date;</span><br><span class="line">    &#125;</span><br><span class="line">    public decimal Degree &#123; get;  &#125;</span><br><span class="line">    public DateTime Date &#123; get;  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来通过实现<code>IObservable&lt;T&gt;</code>接口来定义可观察对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IObservable&lt;out T&gt;</span><br><span class="line">&#123;</span><br><span class="line">  IDisposable Subscribe(IObserver&lt;T&gt; observer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从接口申明来看，只定义了一个<code>Subscribe</code>方法，从观察者模式讲，观察者应该既能订阅又能取消订阅消息。为什么没有定义一个<code>UnSubscribe</code>方法呢？其实这里方法申明已经说明，期望通过返回<code>IDisposable</code>对象的<code>Dispose</code>方法来达到这个目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 热水壶</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public class Kettle : IObservable&lt;Temperature&gt;</span><br><span class="line">&#123;</span><br><span class="line">    private List&lt;IObserver&lt;Temperature&gt;&gt; observers;</span><br><span class="line">    private decimal temperature &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public Kettle()</span><br><span class="line">    &#123;</span><br><span class="line">        observers &#x3D; new List&lt;IObserver&lt;Temperature&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public decimal Temperature</span><br><span class="line">    &#123;</span><br><span class="line">        get &#x3D;&gt; temperature;</span><br><span class="line">        private set</span><br><span class="line">        &#123;</span><br><span class="line">            temperature &#x3D; value;</span><br><span class="line">            observers.ForEach(observer &#x3D;&gt; observer.OnNext(new Temperature(temperature, DateTime.Now)));</span><br><span class="line">            </span><br><span class="line">            if (temperature &#x3D;&#x3D; 100)</span><br><span class="line">                observers.ForEach(observer &#x3D;&gt; observer.OnCompleted());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public IDisposable Subscribe(IObserver&lt;Temperature&gt; observer)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!observers.Contains(observer))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Subscribed!&quot;);</span><br><span class="line">            observers.Add(observer);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;使用UnSubscriber包装，返回IDisposable对象，用于观察者取消订阅</span><br><span class="line">        return new UnSubscriber&lt;Temperature&gt;(observers, observer);</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 烧水方法</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    public async Task StartBoilWaterAsync()</span><br><span class="line">    &#123;</span><br><span class="line">        var random &#x3D; new Random(DateTime.Now.Millisecond);</span><br><span class="line">        while (Temperature &lt; 100)</span><br><span class="line">        &#123;</span><br><span class="line">            Temperature +&#x3D; 10;</span><br><span class="line">            await Task.Delay(random.Next(5000));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;定义泛型取消订阅对象，用于取消订阅</span><br><span class="line">internal class UnSubscriber&lt;T&gt; : IDisposable</span><br><span class="line">&#123;</span><br><span class="line">    private List&lt;IObserver&lt;T&gt;&gt; _observers;</span><br><span class="line">    private IObserver&lt;T&gt; _observer;</span><br><span class="line">    internal UnSubscriber(List&lt;IObserver&lt;T&gt;&gt; observers, IObserver&lt;T&gt; observer)</span><br><span class="line">    &#123;</span><br><span class="line">        this._observers &#x3D; observers;</span><br><span class="line">        this._observer &#x3D; observer;</span><br><span class="line">    &#125;</span><br><span class="line">    public void Dispose()</span><br><span class="line">    &#123;</span><br><span class="line">        if (_observers.Contains(_observer))</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(&quot;Unsubscribed!&quot;);</span><br><span class="line">            _observers.Remove(_observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>以上代码中List&lt;IObserver<T>&gt;存在线程安全问题，因为简单Demo，就不予优化了。</em></p>
<h2 id="3-2-定义观察者（实现IObserver接口"><a href="#3-2-定义观察者（实现IObserver接口" class="headerlink" title="3.2. 定义观察者（实现IObserver接口)"></a>3.2. 定义观察者（实现IObserver<T>接口)</h2><p>比如定义一个报警器，实时播报温度。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Alter : IObserver&lt;Temperature&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public void OnCompleted()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;du du du !!!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void OnError(Exception error)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;Nothing to do</span><br><span class="line">    &#125;</span><br><span class="line">    public void OnNext(Temperature value)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;&#123;value.Date.ToString()&#125;: Current temperature is &#123;value.Degree&#125;.&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加测试代码，访问<code>localhost:5000/subscriber</code>控制台输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">endpoints.MapGet(&quot;&#x2F;subscriber&quot;, async context &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var kettle &#x3D; new Kettle();&#x2F;&#x2F;初始化热水壶</span><br><span class="line">    var subscribeRef &#x3D; kettle.Subscribe(new Alter());&#x2F;&#x2F;订阅</span><br><span class="line">    </span><br><span class="line">    var boilTask &#x3D; kettle.StartBoilWaterAsync();&#x2F;&#x2F;启动开始烧水任务</span><br><span class="line">    var timoutTask &#x3D; Task.Delay(TimeSpan.FromSeconds(15));&#x2F;&#x2F;定义15s超时任务</span><br><span class="line">    &#x2F;&#x2F;等待，如果超时任务先返回则取消订阅</span><br><span class="line">    var firstReturnTask &#x3D; await Task.WhenAny(boilTask, timoutTask);</span><br><span class="line">    if (firstReturnTask &#x3D;&#x3D; timoutTask)</span><br><span class="line">        subscribeRef.Dispose();</span><br><span class="line">    await context.Response.WriteAsync(&quot;Hello subscriber!&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">Subscribed!</span><br><span class="line">10&#x2F;2&#x2F;2020 4:53:20 PM: Current temperature is 10.</span><br><span class="line">10&#x2F;2&#x2F;2020 4:53:20 PM: Current temperature is 20.</span><br><span class="line">10&#x2F;2&#x2F;2020 4:53:21 PM: Current temperature is 30.</span><br><span class="line">10&#x2F;2&#x2F;2020 4:53:21 PM: Current temperature is 40.</span><br><span class="line">10&#x2F;2&#x2F;2020 4:53:24 PM: Current temperature is 50.</span><br><span class="line">10&#x2F;2&#x2F;2020 4:53:25 PM: Current temperature is 60.</span><br><span class="line">10&#x2F;2&#x2F;2020 4:53:26 PM: Current temperature is 70.</span><br><span class="line">10&#x2F;2&#x2F;2020 4:53:30 PM: Current temperature is 80.</span><br><span class="line">Unsubscribed!</span><br></pre></td></tr></table></figure>

<h1 id="4-DiagnosticSource-amp-DiagnosticListener"><a href="#4-DiagnosticSource-amp-DiagnosticListener" class="headerlink" title="4. DiagnosticSource &amp; DiagnosticListener"></a>4. DiagnosticSource &amp; DiagnosticListener</h1><h2 id="4-1-概念讲解"><a href="#4-1-概念讲解" class="headerlink" title="4.1. 概念讲解"></a>4.1. 概念讲解</h2><p><code>DiagnosticSource</code>直译就是诊断源，也就是它是诊断日志的来源入口。DiagnosticSource其是一个<em>抽象类</em>主要定义了以下方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Provides a generic way of logging complex payloads</span><br><span class="line">public abstract void Write(string name, object value);</span><br><span class="line">&#x2F;&#x2F;Verifies if the notification event is enabled.</span><br><span class="line">public abstract bool IsEnabled(string name);</span><br></pre></td></tr></table></figure>
<p><code>DiagnosticListener</code>直译就是诊断监听器，继承自<code>DiagnosticSource</code>，同时实现了<code>IObservable&lt;KeyValuePair&lt;string, object&gt;&gt;</code>接口，因此其本质是一个可观察对象。小结以下：</p>
<ol>
<li><code>DiagnosticSource</code> 作为诊断日志来源，提供接口，用于写入诊断日志。 </li>
<li>诊断日志的可观察数据类型为<code>KeyValuePair&lt;string, object&gt;</code>。</li>
<li><code>DiagnosticListener</code> 继承自<code>DiagnosticSource</code>，作为可观察对象，可由其他观察者订阅，以获取诊断日志。</li>
</ol>
<p><code>DiagnosticListener</code> 其构造函数接收一个<code>name</code>参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static DiagnosticSource httpLogger &#x3D; new DiagnosticListener(&quot;System.Net.Http&quot;);</span><br></pre></td></tr></table></figure>
<p>可以通过下面这种方式记录诊断日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (httpLogger.IsEnabled(&quot;RequestStart&quot;))</span><br><span class="line">    httpLogger.Write(&quot;RequestStart&quot;, new &#123; Url&#x3D;&quot;http:&#x2F;&#x2F;clr&quot;, Request&#x3D;aRequest &#125;);</span><br></pre></td></tr></table></figure>
<p>然后需要实现<code>IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;</code>接口，以便消费诊断数据。定义<code>DiagnosticObserver</code>，进行诊断日志消费：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DiagnosticObserver : IObserver&lt;KeyValuePair&lt;string, object&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public void OnCompleted()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;Noting to do</span><br><span class="line">    &#125;</span><br><span class="line">    public void OnError(Exception error)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;&#123;error.Message&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void OnNext(KeyValuePair&lt;string, object&gt; pair)</span><br><span class="line">    &#123; </span><br><span class="line">        &#x2F;&#x2F; 这里消费诊断数据</span><br><span class="line">        Console.WriteLine($&quot;&#123;pair.Key&#125;-&#123;pair.Value&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ASP.NET Core 项目中默认就依赖了<code>System.Diagnostics.DiagnosticSource</code>Nuget包，同时在构建通用Web主机时，就注入了名为<code>Microsoft.AspNetCore</code>的<code>DiagnosticListener</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;GenericWebHostBuilder.cs</span><br><span class="line">DiagnosticListener instance &#x3D; new DiagnosticListener(&quot;Microsoft.AspNetCore&quot;);</span><br><span class="line">services.TryAddSingleton&lt;DiagnosticListener&gt;(instance);</span><br><span class="line">services.TryAddSingleton&lt;DiagnosticSource&gt;((DiagnosticSource) instance);</span><br></pre></td></tr></table></figure>
<p>因此我们可以直接通过注入<code>DiagnosticListener</code>进行诊断日志的订阅：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void Configure(IApplicationBuilder app, IWebHostEnvironment env, DiagnosticListener diagnosticListener)</span><br><span class="line">&#123;</span><br><span class="line">    diagnosticListener.Subscribe(new DiagnosticObserver());&#x2F;&#x2F;订阅诊断日志</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em>当然也可以直接使用<code>DiagnosticListener.AllListeners.Subscribe(IObserver&lt;DiagnosticListener&gt; observer);</code>进行订阅，不过区别是，接收的参数类型为<code>IObserver&lt;DiagnosticListener&gt;</code>。</em></p>
<p>运行项目输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Microsoft.AspNetCore.Hosting.HttpRequestIn.Start-Microsoft.AspNetCore.Http.DefaultHttpContext</span><br><span class="line">Microsoft.AspNetCore.Hosting.BeginRequest-&#123; httpContext &#x3D; Microsoft.AspNetCore.Http.DefaultHttpContext, timestamp &#x3D; 7526300014352 &#125;</span><br><span class="line">Microsoft.AspNetCore.Routing.EndpointMatched-Microsoft.AspNetCore.Http.DefaultHttpContext</span><br><span class="line">Microsoft.AspNetCore.Hosting.EndRequest-&#123; httpContext &#x3D; Microsoft.AspNetCore.Http.DefaultHttpContext, timestamp &#x3D; 7526300319214 &#125;</span><br><span class="line">Microsoft.AspNetCore.Hosting.HttpRequestIn.Stop-Microsoft.AspNetCore.Http.DefaultHttpContext</span><br></pre></td></tr></table></figure>
<p>从中可以看出，ASP.NET Core Empty Web Project在一次正常的Http请求过程中分别在请求进入、请求处理、路由匹配都埋了点，除此之外还有请求异常、Action处理都有埋点。因此，根据需要，可以实现比如请求拦截、耗时统计等系列操作。</p>
<h2 id="4-2-耗时统计"><a href="#4-2-耗时统计" class="headerlink" title="4.2. 耗时统计"></a>4.2. 耗时统计</h2><p>基于以上知识，下面尝试完成一个简单的耗时统计。从上面的内容可知，ASP.NET Core在BeginRequest和EndRequest返回的诊断数据类型如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Microsoft.AspNetCore.Hosting.BeginRequest-&#123; httpContext &#x3D; Microsoft.AspNetCore.Http.DefaultHttpContext, timestamp &#x3D; 7526300014352 &#125;</span><br><span class="line">Microsoft.AspNetCore.Hosting.EndRequest-&#123; httpContext &#x3D; Microsoft.AspNetCore.Http.DefaultHttpContext, timestamp &#x3D; 7526300319214 &#125;</span><br></pre></td></tr></table></figure>
<p>因此只要拿到两个timestamp就可以直接计算耗时，修改<code>DiagnosticObserver</code>的<code>OnNext</code>方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private ConcurrentDictionary&lt;string, long&gt; startTimes &#x3D; new ConcurrentDictionary&lt;string, long&gt;();</span><br><span class="line">public void OnNext(KeyValuePair&lt;string, object&gt; pair)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;Console.WriteLine($&quot;&#123;pair.Key&#125;-&#123;pair.Value&#125;&quot;);</span><br><span class="line">    &#x2F;&#x2F;获取httpContext</span><br><span class="line">    var context &#x3D; pair.Value.GetType().GetTypeInfo().GetDeclaredProperty(&quot;httpContext&quot;)</span><br><span class="line">        ?.GetValue(pair.Value) as DefaultHttpContext;</span><br><span class="line">    &#x2F;&#x2F;获取timestamp</span><br><span class="line">    var timestamp &#x3D; pair.Value.GetType().GetTypeInfo().GetDeclaredProperty(&quot;timestamp&quot;)</span><br><span class="line">        ?.GetValue(pair.Value) as long?;</span><br><span class="line">    switch (pair.Key)</span><br><span class="line">    &#123;</span><br><span class="line">        case &quot;Microsoft.AspNetCore.Hosting.BeginRequest&quot;:</span><br><span class="line">            Console.WriteLine($&quot;Request &#123;context.TraceIdentifier&#125; Begin:&#123;context.Request.GetUri()&#125;&quot;);</span><br><span class="line">            startTimes.TryAdd(context.TraceIdentifier, timestamp.Value);&#x2F;&#x2F;记录请求开始时间</span><br><span class="line">            break;</span><br><span class="line">        case &quot;Microsoft.AspNetCore.Hosting.EndRequest&quot;:</span><br><span class="line">            startTimes.TryGetValue(context.TraceIdentifier, out long startTime);</span><br><span class="line">            var elapsedMs &#x3D; (timestamp - startTime) &#x2F; TimeSpan.TicksPerMillisecond;&#x2F;&#x2F;计算耗时</span><br><span class="line">            Console.WriteLine(</span><br><span class="line">                $&quot;Request &#123;context.TraceIdentifier&#125; End: Status Code is &#123;context.Response.StatusCode&#125;,Elapsed &#123;elapsedMs&#125;ms&quot;);</span><br><span class="line">            startTimes.TryRemove(context.TraceIdentifier, out _);</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下，大功告成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Request 0HM37UNERKGF0:00000001 Begin:https:&#x2F;&#x2F;localhost:44330</span><br><span class="line">Request 0HM37UNERKGF0:00000001 End: Status Code is 200,Elapsed 38ms</span><br></pre></td></tr></table></figure>

<p>上面有通过反射去获取诊断数据属性的代码（<code>var timestamp = pair.Value.GetType().GetTypeInfo().GetDeclaredProperty(&quot;timestamp&quot;)
        ?.GetValue(pair.Value) as long?;</code>），非常不优雅。但我们可以安装<strong><code>Microsoft.Extensions.DiagnosticAdapter</code></strong>包来简化诊断数据的消费。安装后，添加<code>HttpContextDiagnosticObserver</code>，通过添加<code>DiagnosticName</code>指定监听的诊断名称，即可进行诊断数据消费。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public sealed class HttpContextDiagnosticObserver</span><br><span class="line">&#123;</span><br><span class="line">    private ConcurrentDictionary&lt;string, long&gt; startTimes &#x3D; new ConcurrentDictionary&lt;string, long&gt;();</span><br><span class="line">    </span><br><span class="line">    [DiagnosticName(&quot;Microsoft.AspNetCore.Hosting.BeginRequest&quot;)]</span><br><span class="line">    public void BeginRequest(HttpContext httpContext,long timestamp)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;Request &#123;httpContext.TraceIdentifier&#125; Begin:&#123;httpContext.Request.GetUri()&#125;&quot;);</span><br><span class="line">        startTimes.TryAdd(httpContext.TraceIdentifier, timestamp);&#x2F;&#x2F;记录请求开始时间</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [DiagnosticName(&quot;Microsoft.AspNetCore.Hosting.EndRequest&quot;)]</span><br><span class="line">    public void EndRequest(HttpContext httpContext,long timestamp)</span><br><span class="line">    &#123;</span><br><span class="line">        startTimes.TryGetValue(httpContext.TraceIdentifier, out long startTime);</span><br><span class="line">        var elapsedMs &#x3D; (timestamp - startTime) &#x2F; TimeSpan.TicksPerMillisecond;&#x2F;&#x2F;计算耗时</span><br><span class="line">        Console.WriteLine(</span><br><span class="line">            $&quot;Request &#123;httpContext.TraceIdentifier&#125; End: Status Code is &#123;httpContext.Response.StatusCode&#125;,Elapsed &#123;elapsedMs&#125;ms&quot;);</span><br><span class="line">        startTimes.TryRemove(httpContext.TraceIdentifier, out _);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后使用<code>SubscribeWithAdapter</code>进行订阅即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void Configure(IApplicationBuilder app, IWebHostEnvironment env, DiagnosticListener diagnosticListener)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; diagnosticListener.Subscribe(new DiagnosticObserver());</span><br><span class="line">    diagnosticListener.SubscribeWithAdapter(new HttpContextDiagnosticObserver());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里可能也有小伙伴说，我用<code>ActionFilter</code>也可以实现，没错，但这两种方式是完全不同的，<code>DiagnosticSource</code>是完全异步的。</p>
<h2 id="4-3-应用场景思考"><a href="#4-3-应用场景思考" class="headerlink" title="4.3. 应用场景思考"></a>4.3. 应用场景思考</h2><p>根据DiagnosticSource的特性，可以运用于以下场景 ：</p>
<ol>
<li>AOP：因为Diagnostics命名事件一般是成对出现的，因此可以做些拦截操作。比如在Abp集成<a href="https://github.com/dotnetcore/CAP" target="_blank" rel="noopener">Cap</a>时，若想默认启用Uow，就可以消费<code>DotNetCore.CAP.WriteSubscriberInvokeBefore</code>命名事件，创建Uow，再在命名事件<code>DotNetCore.CAP.WriteSubscriberInvokeAfter</code>中提交事务，并Dispose。</li>
<li>APM：<a href="https://github.com/SkyAPM/SkyAPM-dotnet" target="_blank" rel="noopener">SkyAPM-dotnet</a>的<a href="https://github.com/SkyAPM/SkyAPM-dotnet/blob/master/src/SkyApm.Diagnostics.AspNetCore/HostingDiagnosticProcessor.cs" target="_blank" rel="noopener">实现</a>就是通过消费诊断日志，进行链路跟踪</li>
<li>EventBus：充分利用其发布订阅模式，可将其用于进程内事件的发布与消费。</li>
</ol>
<h1 id="5-Activity（活动）"><a href="#5-Activity（活动）" class="headerlink" title="5. Activity（活动）"></a>5. Activity（活动）</h1><h2 id="5-1-Activity-概述"><a href="#5-1-Activity-概述" class="headerlink" title="5.1. Activity 概述"></a>5.1. Activity 概述</h2><p>那Activity又是何方神圣，用于解决什么问题呢？关于Activity官方只有一句简要介绍：Represents an operation with context to be used for logging。（表示包含上下文的操作，用于日志记录。）</p>
<p>Activity用来存储和访问诊断上下文，并由日志系统进行消费。当应用程序开始处理操作时，例如HTTP请求或队列中的任务，它会在处理请求时创建Activity以在系统中跟踪该Activity。Activity中存储的上下文可以是HTTP请求路径，方法，用户代理或关联ID：所有重要信息都应与每个跟踪一起记录。当应用程序调用外部依赖关系以完成操作时，它可能需要传递一些上下文（例如，关联ID）以及依赖关系调用，以便能够关联来自多个服务的日志。</p>
<p>先来看下Activity主要以下核心属性：</p>
<ol>
<li><p>Tags（标签）<br><code>IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; Tags { get; }</code> - 表示与活动一起记录的信息。标签的好例子是实例/机器名称，传入请求HTTP方法，路径，用户/用户代理等。标签<strong>不传递</strong>给子活动。<br>典型的标签用法包括添加一些自定义标签，并通过它们进行枚举以填充日志事件的有效负载。可通过<code>Activity AddTag(string key, string value)</code>添加Tag，但不支持通过Key检索标签。</p>
</li>
<li><p>Baggage（行李）<br><code>IEnumerable&lt;KeyValuePair&lt;string, string&gt;&gt; Baggage { get; }</code> - 表示要与活动一起记录<strong>并传递给其子项</strong>的信息。行李的例子包括相关ID，采样和特征标记。<br>Baggage被序列化并与外部依赖项请求一起传递。<br>典型的Baggage用法包括添加一些Baggage属性，并通过它们进行枚举以填充日志事件的有效负载。<br>可通过<code>Activity AddBaggage(string key, string value)</code>添加Baggage。并通过<code>string GetBaggageItem(string key)</code>获取指定Key的Baggage。</p>
</li>
<li><p>OperationName（操作名称）<br><code>string OperationName { get; }</code> - 活动名称，必须在构造函数中指定。</p>
</li>
<li><p>StartTimeUtc<br><code>DateTime StartTimeUtc { get; private set; }</code>  - UTC格式的启动时间，如果不指定，则在启动时默认指定为<code>DateTime.UtcNow</code>。可通过<code>Activity SetStartTime(DateTime startTimeUtc)</code>指定。</p>
</li>
<li><p>Duration<br><code>TimeSpan Duration { get; private set; }</code> - 如果活动已停止，则代表活动持续时间，否则为0。</p>
</li>
<li><p>Id<br><code>string Id { get; private set; }</code> - 表示特定的活动标识符。过滤特定ID可确保您仅获得与操作中特定请求相关的日志记录。该Id在活动开始时生成。Id传递给外部依赖项，并被视为新的外部活动的[ParentId]。</p>
</li>
<li><p>ParentId<br><code>string ParentId { get; private set; }</code> - 如果活动是根据请求反序列化的，则该活动可能具有进程中的[Parent]或外部Parent。 ParentId和Id代表日志中的父子关系，并允许您关联传出和传入请求。</p>
</li>
<li><p>RootId<br><code>string RootId  { get; private set; }</code> - 代表根Id</p>
</li>
<li><p>Current<br><code>static Activity Current { get; }</code> - 返回在异步调用之间流动的当前Activity。</p>
</li>
<li><p>Parent<br><code>Activity Parent { get; private set; }</code> - 如果活动是在同一过程中从另一个活动创建的，则可以使用<code>Partent</code>获得该活动。但是，如果“活动”是根活动或父项来自流程外部，则此字段可能为null。</p>
</li>
<li><p>Start()<br><code>Activity Start()</code> - 启动活动：设置活动的Activity.Current和Parent，生成唯一的ID并设置StartTimeUtc（如果尚未设置）。</p>
</li>
<li><p>Stop()<br><code>void Stop()</code> - 停止活动：设置活动的Activity.Current，并使用<code>Activity SetEndTime(DateTime endTimeUtc)</code>或DateTime.UtcNow中提供的时间戳计算Duration。</p>
</li>
</ol>
<p>另外<code>DiagnosticSource</code>中也定义了两个相关方法：</p>
<ol>
<li>StartActivity<br><code>Activity StartActivity(Activity activity, object args)</code> - 启动给定的Activity，并将<code>DiagnosticSource</code>事件消息写入<code>OperationName.Start</code>格式的命名事件中。</li>
<li>StopActivity<br><code>void StopActivity(Activity activity, object args)</code> - 停止给定的Activity，并将<code>DiagnosticSource</code>事件消息写入<code>{OperationName}.Stop</code>格式的命名事件中。</li>
</ol>
<h2 id="5-2-Activity在ASP-NET-Core中的应用"><a href="#5-2-Activity在ASP-NET-Core中的应用" class="headerlink" title="5.2. Activity在ASP.NET Core中的应用"></a>5.2. Activity在ASP.NET Core中的应用</h2><p>要想弄懂Activity，我们还是得向源码学习，看一下<a href="https://github.com/dotnet/aspnetcore/blob/master/src/Hosting/Hosting/src/Internal/HostingApplicationDiagnostics.cs" target="_blank" rel="noopener">HostingApplicationDiagnostics</a>的实现。首先来看下<code>BeginRequst</code>中的<code>StartActivity</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Activity StartActivity(HttpContext httpContext, out bool hasDiagnosticListener)</span><br><span class="line">&#123;</span><br><span class="line">  Activity activity &#x3D; new Activity(&quot;Microsoft.AspNetCore.Hosting.HttpRequestIn&quot;);</span><br><span class="line">  hasDiagnosticListener &#x3D; false;</span><br><span class="line">  IHeaderDictionary headers &#x3D; httpContext.Request.Headers;</span><br><span class="line">  StringValues stringValues1;</span><br><span class="line">  if (!headers.TryGetValue(HeaderNames.TraceParent, out stringValues1))</span><br><span class="line">    headers.TryGetValue(HeaderNames.RequestId, out stringValues1);</span><br><span class="line">  if (!StringValues.IsNullOrEmpty(stringValues1))</span><br><span class="line">  &#123;</span><br><span class="line">    activity.SetParentId((string) stringValues1);</span><br><span class="line">    StringValues stringValues2;</span><br><span class="line">    if (headers.TryGetValue(HeaderNames.TraceState, out stringValues2))</span><br><span class="line">      activity.TraceStateString &#x3D; (string) stringValues2;</span><br><span class="line">    string[] commaSeparatedValues &#x3D; headers.GetCommaSeparatedValues(HeaderNames.CorrelationContext);</span><br><span class="line">    if (commaSeparatedValues.Length !&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">      foreach (string str in commaSeparatedValues)</span><br><span class="line">      &#123;</span><br><span class="line">        NameValueHeaderValue parsedValue;</span><br><span class="line">        if (NameValueHeaderValue.TryParse((StringSegment) str, out parsedValue))</span><br><span class="line">          activity.AddBaggage(parsedValue.Name.ToString(), parsedValue.Value.ToString());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  this._diagnosticListener.OnActivityImport(activity, (object) httpContext);</span><br><span class="line">  if (this._diagnosticListener.IsEnabled(&quot;Microsoft.AspNetCore.Hosting.HttpRequestIn.Start&quot;))</span><br><span class="line">  &#123;</span><br><span class="line">    hasDiagnosticListener &#x3D; true;</span><br><span class="line">    this.StartActivity(activity, httpContext);</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">    activity.Start();</span><br><span class="line">  return activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从中可以看出，在ASP.NET Core 开始处理请求之前：</p>
<ol>
<li>首先，创建了名为<code>Microsoft.AspNetCore.Hosting.HttpRequestIn</code>的Activity，该Activity首先尝试从HTTP请求头中获取TraceParent/euqstId作为当前Activity的ParentId，这个很显然，是用来链路跟踪的。</li>
<li>其次，尝试从<code>CorrelationContext</code>中获取关联上下文信息，然后将其添加到创建的Activity的Baggage中，进行关联上下文的继续传递。</li>
<li>然后，启动Activity，然后向Name为<code>Microsoft.AspNetCore.Hosting.HttpRequestIn.Start</code>中写入诊断日志。</li>
</ol>
<p>这里大家可能有个疑问，这个关联上下文信息<code>CorrelationContext</code>又是何时添加到Http请求头中的呢？在<code>System.Net.Http</code>中的<a href="https://github.com/dotnet/runtime/blob/master/src/libraries/System.Net.Http/src/System/Net/Http/DiagnosticsHandler.cs" target="_blank" rel="noopener">DiagnosticsHandler</a>中添加的。<br>因此我们应该明白了，整个关联上下文的传递机制。</p>
<p>紧接着再来看一看<code>RequestEnd</code>中的<code>StopActivity</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void StopActivity(Activity activity, HttpContext httpContext)</span><br><span class="line">&#123;</span><br><span class="line">  if (activity.Duration &#x3D;&#x3D; TimeSpan.Zero)</span><br><span class="line">    activity.SetEndTime(DateTime.UtcNow);</span><br><span class="line">  this._diagnosticListener.Write(&quot;Microsoft.AspNetCore.Hosting.HttpRequestIn.Stop&quot;, (object) httpContext);</span><br><span class="line">  activity.Stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从中可以看出主要是先<code>SetEndTime</code>，再写入<code>Microsoft.AspNetCore.Hosting.HttpRequestIn.Stop</code>命名事件；最后调用<code>Stop</code>方法停止当前Activity。</p>
<p>简单总结一下，借助Activity中附加的Baggage信息可以实现请求链路上上下文数据的共享。</p>
<h2 id="5-3-应用场景思考"><a href="#5-3-应用场景思考" class="headerlink" title="5.3. 应用场景思考"></a>5.3. 应用场景思考</h2><p>从上面的命名事件中可以看出，其封送的数据类型是特定的，因此可以借助Activity的Tags或Baggage添加自定义的数据进行共享。</p>
<p>按照上面我们的耗时统计，只能统计到整个http请求的耗时，但对于我们定位问题来说还是有困难，比如，某个api即有调用redis，又操作了消息队列，同时又访问了数据库，那到底是那一段超时了呢？显然不好直接定位，借助Activity，我们就可以很好的实现细粒度的链路跟踪。通过Activity携带的信息，可以将一系列的操作关联起来，记录日志，再借助APM进行可视化快速定位跟踪。</p>
<h1 id="6-参考资料"><a href="#6-参考资料" class="headerlink" title="6. 参考资料"></a>6. 参考资料</h1><ol>
<li><a href="https://www.cnblogs.com/savorboard/p/diagnostics.html" target="_blank" rel="noopener">在 .NET Core 中使用 Diagnostics (Diagnostic Source) 记录跟踪信息</a></li>
<li><a href="https://andrewlock.net/logging-using-diagnosticsource-in-asp-net-core/" target="_blank" rel="noopener">Logging using DiagnosticSource in ASP.NET Core</a></li>
<li><a href="https://www.cnblogs.com/wucy/p/13532534.html" target="_blank" rel="noopener">.Net Core中的诊断日志DiagnosticSource讲解</a></li>
<li><a href="https://docs.microsoft.com/en-us/dotnet/standard/events/observer-design-pattern" target="_blank" rel="noopener">Observer Design Pattern</a></li>
<li><a href="https://github.com/dotnet/runtime/blob/master/src/libraries/System.Diagnostics.DiagnosticSource/src/DiagnosticSourceUsersGuide.md" target="_blank" rel="noopener">DiagnosticSource User Guide</a></li>
<li><a href="https://github.com/dotnet/runtime/blob/master/src/libraries/System.Diagnostics.DiagnosticSource/src/ActivityUserGuide.md" target="_blank" rel="noopener">Activity User Guide</a></li>
<li><a href="[https://www.youtube.com/watch?v=g3SZxsskZE0](https://www.youtube.com/watch?v=g3SZxsskZE0)">DiagnosticSourcery 101 - Mark Rendle</a></li>
<li><a href="https://devblogs.microsoft.com/aspnet/improvements-in-net-core-3-0-for-troubleshooting-and-monitoring-distributed-apps/" target="_blank" rel="noopener">Improvements in .NET Core 3.0 for troubleshooting and monitoring distributed apps
</a></li>
</ol>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>诊断日志</tag>
        <tag>发布订阅模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Istio 知多少 | 下一代微服务守护者</title>
    <url>/post/how-much-you-know-about-istio/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>在写完<a href="https://www.jianshu.com/p/e27f0f1dd8ab" target="_blank" rel="noopener">eShopOnContainers 知多少[12]：Envoy gateways</a>后，就一直想进一步探索Service Mesh，最近刚在极客时间上学完《Service Mesh入门》，又大致浏览了一遍官方文档，对Istio也算有了基本的认识。下面就根据自己的理解对Istio进行简单的梳理，算是对知识的总结吧。</p>
<h1 id="2-Cloud-Native（云原生）"><a href="#2-Cloud-Native（云原生）" class="headerlink" title="2. Cloud Native（云原生）"></a>2. Cloud Native（云原生）</h1><p>在介绍Istio之前，我们得先了解下Service Mesh，而Service Mesh 又是云原生的产物。因此，本着追本溯源的精神，我们得先了解下云原生。云原生（Cloud Native）这个概念是在2015年提出的，听的人多，真正能讲清楚的人少，我也一样。综合多方资料，下面尝试解读一下。</p>
<p>云原生，虽然字都认识，但真不好解释。一般讲云原生，其实是讲云原生应用，多了应用二字，就更具象了。从字面上直译：云，代表云端；原生：原本就生长在那里；连起来就是<strong>原本就生长在云端的应用</strong>。</p>
<p>应用怎么会原本就生长在云端呢？云又是怎么发展而来呢？别急，我们先来看下云计算的发展来解答下云的由来。</p>
<p>我们知道传统的应用都是跑在本地服务器上，随着虚拟化技术的发展，拉开了云计算的序幕，一大批云计算厂商基于虚拟机技术，提供了IaaS，PaaS和SaaS等产品心态，极大的提高资源的利用率。企业本着降本增效的目的，逐步将应用迁移到云上的Paas平台上。而这一阶段，被称为云计算的虚拟机时代，而这个时间节点在2013年之前，运行在云端虚拟机上的应用，还不叫云原生应用。</p>
<p>2013年，Docker开源，正式开启了容器技术时代，重新定义了 PaaS 的全新容器化思路。在容器技术的基础上，“云”得到了极大的发展，2014年谷歌开源Kubernetes，旨在解决容器的编排问题（部署、伸缩和管理）。2017年容器编排大战尘埃落定，Kubernetes成为最大赢家，标志着K8S成为分布式资源调度和自动化运维的事实标准。Kubernetes 也逐渐体现出云原生时代底层操作系统的特征，向下封装资源、向上支撑应用。这个阶段，可以称为云计算的容器时代。也正是在这个阶段，云原生的概念被提出，其标志事件就是2015年CNCF（云原生计算基金会）的成立，云原生这个词才被大家熟知。</p>
<p>现在我们知道，云原生是在容器时代提出的概念。那为什么会提出云原生这个概念呢？别急我们来看下云计算发展过程中后端架构的演进。</p>
<p><img src="/images/how-much-you-know-about-istio/2799767-468fa4b0fdf93d2e.png" alt=""></p>
<p>从上图可知，后端架构从单体到分布式，再逐步演进到微服务架构。采用微服务架构，就必须解决服务治理、流量控制、应用观察等问题。其中2014年由Netflix 推出的Spring Cloud体系就是通过提供服务发现、负载均衡、失效转移、动态扩容、数据分片、调用链路监控等分布式系统的核心功能，一度成为微服务的最佳实践。但是却有一个很大的缺点就是其对应用有很强的<strong>侵入性</strong>，应用代码中会包含大量的 SpringCloud 模块。这时的应用模型如下图所示：<br><img src="/images/how-much-you-know-about-istio/2799767-37c166cdb37da808.png" alt=""></p>
<p>那如何解决侵入性的问题呢？这个问题在容器编排技术成熟之前，似乎没有好的答案。但随着K8S的成熟，这个问题有了新的解法。Kubernetes的出现就是为了解决 SpringCloud 的问题，不侵入应用层，在容器层解决问题。这就是理想的应用开发模型，应用依托于“云”，最大化发挥“云”的优势，专注于业务需求的实现。</p>
<p><img src="/images/how-much-you-know-about-istio/2799767-b078ed95710d8719.png" alt=""></p>
<p>那应用如何依托于“云”，最大化发挥“云”的优势呢？云原生就是为了解决这一问题而提出的。其建立在“未来的软件一定生长于云”的核心假设之上提出的，<strong>云原生本质上是一套指导软件架构设计的思想，依托该思想而设计的应用：首先，应用本身“生于云、长于云”；其次，这样的应用能够天然集成“云”环境，进而释放“云”的最大价值。</strong> 云原生定义了一条能够让应用最大程度利用云能力、发挥云价值的最佳路径。具体来说，参考云原生计算基金会（CNCF）对<a href="https://github.com/cncf/toc/blob/master/DEFINITION.md#中文版本" target="_blank" rel="noopener">云原生的定义</a>，<strong>云原生包括容器化封装、自动化管理、面向微服务、服务网格、声明式 API。符合云原生架构的应用程序应该是：采用开源堆栈（Kubernetes+Docker）进行容器化，基于微服务架构提高灵活性和可维护性，借助敏捷方法、DevOps 支持持续迭代和运维自动化，利用云平台设施实现弹性伸缩、动态调度、优化资源利用率。</strong></p>
<p>那如何实现云原生呢？Service Mesh交出了自己的答卷。</p>
<h1 id="3-Service-Mesh（服务网格）"><a href="#3-Service-Mesh（服务网格）" class="headerlink" title="3. Service Mesh（服务网格）"></a>3. Service Mesh（服务网格）</h1><p>先来看下Service Mesh的提出者，也就是第一代Service Mesh 产品Linkerd的CEO，对Service Mesh的定义：<br><img src="/images/how-much-you-know-about-istio/2799767-496fbb1676a4c670.png" alt="Service Mesh的定义"></p>
<blockquote>
<p>Service Mesh 通常被译为服务网格，其是一个<strong>基础设施层</strong>，用于处理服务间通信。云原生应用有着复杂的服务拓扑，服务网格负责在这些拓扑中<strong>实现请求的可靠传递</strong>。在实践中，服务网格通常实现为一组<strong>轻量级网络代理</strong>，它们与应用程序部署在一起，而<strong>对应用程序透明</strong>。</p>
</blockquote>
<p><em>PS: eShopOnContainers就是采用了Linkerd作为Service Mesh，基于其易于安装和设置的特性。感兴趣的同学，可访问<a href="https://github.com/dotnet-architecture/eShopOnContainers/wiki/Resiliency-and-Service-Mesh" target="_blank" rel="noopener">链接</a>一探究竟。</em></p>
<p>Service Mesh 通过在请求调用的路径中增加Sidecar，将原本由客户端完成的复杂功能下沉到Sidecar 中，实现对客户端的简化和服务间通信控制权的转移，当系统中存在大量服务时，服务间的调用关系表现为网状，这也是服务网格名称的由来。</p>
<p><strong>Service Mesh就是通过Sidecar模式将业务需求与非业务需求进行隔离，解决侵入性问题</strong>。其中Sidecar主要就是用来处理诸如服务发现、负载均衡、请求熔断等一系列非业务需求，应用在部署时动态插入Sidecar，以<strong>对用户透明的方式改变应用行为</strong>。以下是Service Mesh的核心流程：<br><img src="/images/how-much-you-know-about-istio/2799767-8d4d1d42ed1d0696.png" alt="Service Mesh"></p>
<h1 id="4-Istio-（帆）"><a href="#4-Istio-（帆）" class="headerlink" title="4. Istio （帆）"></a>4. Istio （帆）</h1><p>主流的 Service Mesh 开源软件包括 Linkerd、Envoy 和 Istio。Linkerd 和 Envoy 都 直 接 体 现 了Service Mesh 的核心理念，在功能上较为相似，即实现服务发现、请求路由、负载均衡等功能，解决服务之间的通信问题，使得应用对服务通信无感知。<strong>而 Istio 站在了更高的角度，将 Service Mesh 分为了 Data Plane 和 Control Plane， 由 Data Plane负责微服务间的所有网络通信，而 Control Plane负 责 管 理 Data Plane Proxy</strong>， 且 Istio 天 然 支 持Kubernetes，这也弥合了应用调度框架与 ServiceMesh 之间的空隙。</p>
<p><img src="/images/how-much-you-know-about-istio/2799767-dbae54dc31dfbb1c.png" alt="Istio"></p>
<blockquote>
<p><a href="https://istio.io/latest/zh/docs/concepts/what-is-istio/" target="_blank" rel="noopener">Istio的官方定义</a>:<br>它是一个完全开源的服务网格，作为透明的一层接入到现有的分布式应用程序里。它也是一个平台，拥有可以集成任何日志、遥测和策略系统的 API 接口。Istio 多样化的特性使您能够成功且高效地运行分布式微服务架构，并提供保护、连接和监控微服务的统一方法。</p>
</blockquote>
<p>从定义中可以梳理出Istio提供了以下核心特性：</p>
<ol>
<li>连接：请求路由、服务发现、负载均衡、流量管理、灰度发布及A/B测试</li>
<li>保护：托管的认证授权，及通信加密</li>
<li>控制：策略定义</li>
<li>观测：日志、追踪、指标及监控</li>
</ol>
<p>目前的Istio已经更新到1.8版本了，其架构也从最开始的复杂版本逐渐简化。现在的架构图如下所示：</p>
<p><img src="/images/how-much-you-know-about-istio/2799767-e492da29670e8b73.png" alt="Istio Architecture"></p>
<p>从图中可以看出主要包含两大平面：</p>
<ol>
<li>数据平面（Data plane）：由Envoy Proxy 充当的Sidecar组成。</li>
<li>控制平面（Control plane）：主要包含三大核心组件，Pilot、Citadel、Galley组成。</li>
<li><ol>
<li>Pilot：主要是管理部署在Istio服务网格中的Envoy代理实例，为它们提供服务发现、流量管理以及弹性功能，比如：A/B测试、金丝雀发布、超时、重试、熔断等。</li>
</ol>
</li>
<li><ol start="2">
<li>Citadel：Istio的核心安全组件，负责服务的密钥和数字证书管理，用于提供自动生成、分发、轮换及撤销密钥和数据证书的功能。</li>
</ol>
</li>
<li><ol start="3">
<li>Galley：负责向Istio的其它组件提供支撑功能，可以理解为Istio的配置中心，它用于校验进入网络配置信息的格式内容正确性，并将这些配置信息提供给Pilot。</li>
</ol>
</li>
</ol>
<p>以上就是Istio的核心概念，关于Istio流量控制、安全及可观察性的应用，这里就先不展开了，后续就结合Demo，再和大家分享了。</p>
<h1 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h1><p>讲真，通过翻阅资料，完成了对云计算、云原生、Service Mesh等概念的追本溯源，加深了云原生理念的认知，拓展了自己的架构视野，也大致了解了后续自己的学习和研究方向。希望本文对你或多或少也有所帮助，感谢阅读！</p>
<p><em>写就本文，参考了很多资料，参考资料见文末，在此对原作者表示感谢！另外这里再向大家推荐两份关于云原生和Service Mesh的PPT，梳理的非常完整，感兴趣的同学可关注【微服务知多少】公众号，回复”云原生“即可获取。</em></p>
<blockquote>
<p>参考资料</p>
<ol>
<li><a href="https://kb.cnblogs.com/page/643110/" target="_blank" rel="noopener">未来已来：云原生 Cloud Native</a></li>
<li><a href="https://www.infoq.cn/article/fA42rfjV*dYGAvRANFqE" target="_blank" rel="noopener">畅谈云原生（上）：云原生应用应该是什么样子？</a></li>
<li><a href="https://juejin.cn/post/6844903508261470215" target="_blank" rel="noopener">Service Mesh：下一代微服务？</a></li>
<li><a href="https://istio.io/latest/docs/concepts/what-is-istio/" target="_blank" rel="noopener">What’s Istio?</a></li>
<li><a href="https://www.infoq.cn/minibook/GaaadEVc7hFNLpRAiBU7" target="_blank" rel="noopener">InfoQ：云原生的技术探索与落地实践 | 研究报告</a></li>
<li><a href="https://github.com/cncf/toc/blob/master/DEFINITION.md" target="_blank" rel="noopener">CNCF Cloud Native Definition v1.0</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>云原生</category>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>Service Mesh</tag>
        <tag>Istio</tag>
      </tags>
  </entry>
  <entry>
    <title>MediatR 知多少</title>
    <url>/post/how-much-you-know-about-the-MediatR/</url>
    <content><![CDATA[<p><img src="/images/how-much-you-know-about-the-MediatR/2799767-81f47b8d28199687.png" alt=""></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>首先不用查字典了，词典查无此词。猜测是作者笔误将<strong>Mediator</strong>写成MediatR了。废话少说，转入正题。</p>
<p>先来简单了解下这个开源项目<a href="https://github.com/jbogard/MediatR" target="_blank" rel="noopener">MediatR</a>（作者Jimmy Bogard，也是开源项目AutoMapper的创建者，在此表示膜拜）：</p>
<blockquote>
<p>Simple mediator implementation in .NET. In-process messaging with no dependencies. Supports request/response, commands, queries, notifications and events, synchronous and async with intelligent dispatching via C# generic variance.<br><em>.NET中的简单中介者模式实现，一种进程内消息传递机制（无其他外部依赖）。 支持以同步或异步的形式进行请求/响应，命令，查询，通知和事件的消息传递，并通过C#泛型支持消息的智能调度。</em></p>
</blockquote>
<p>如上所述，其核心是一个中介者模式的.NET实现，其目的是消息发送和消息处理的解耦。它支持以单播和多播形式使用同步或异步的模式来发布消息，创建和侦听事件。</p>
<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p>既然是对中介者模式的一种实现，那么我们就有必要简要介绍下中介者这个设计模式，以便后续展开。<br><img src="/images/how-much-you-know-about-the-MediatR/2799767-6165cec43764d9cd.png" alt="中介者模式类图"></p>
<blockquote>
<p>中介者模式：用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互。</p>
</blockquote>
<p>看上面的官方定义可能还是有点绕，那么下面这张图应该能帮助你对中介者模式有个直观了解。<br><img src="/images/how-much-you-know-about-the-MediatR/2799767-306109184e4beaa6.png" alt=""></p>
<p>使用中介模式，对象之间的交互将封装在中介对象中。对象不再直接相互交互（解耦），而是通过中介进行交互。这减少了对象之间的依赖性，从而减少了耦合。</p>
<p>那其优缺点也在图中很容易看出：</p>
<blockquote>
<p><strong>优点</strong>：中介者模式的优点就是减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者，减少了依赖，当然同时也降低了类间的耦合<br><strong>缺点</strong>：中介者模式的缺点就是中介者会膨胀得很大，而且逻辑复杂，原本N个对象直接的相互依赖关系转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越复杂。</p>
</blockquote>
<h1 id="Hello-MeidatR"><a href="#Hello-MeidatR" class="headerlink" title="Hello MeidatR"></a>Hello MeidatR</h1><p>在开始之前，我们先来了解下其基本用法。</p>
<h2 id="单播消息传输"><a href="#单播消息传输" class="headerlink" title="单播消息传输"></a>单播消息传输</h2><p>单播消息传输，也就是一对一的消息传递，一个消息对应一个消息处理。其通过<code>IRequest</code>来抽象单播消息，用<code>IRequestHandler</code>进行消息处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;构建 消息请求</span><br><span class="line">public class Ping : IRequest&lt;string&gt; &#123; &#125;</span><br><span class="line">&#x2F;&#x2F;构建 消息处理</span><br><span class="line">public class PingHandler : IRequestHandler&lt;Ping, string&gt; &#123;</span><br><span class="line">    public Task&lt;string&gt; Handle(Ping request, CancellationToken cancellationToken) &#123;</span><br><span class="line">        return Task.FromResult(&quot;Pong&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;发送 请求</span><br><span class="line">var response &#x3D; await mediator.Send(new Ping());</span><br><span class="line">Debug.WriteLine(response); &#x2F;&#x2F; &quot;Pong&quot;</span><br></pre></td></tr></table></figure>

<h2 id="多播消息传输"><a href="#多播消息传输" class="headerlink" title="多播消息传输"></a>多播消息传输</h2><p>多播消息传输，也就是一对多的消息传递，一个消息对应多个消息处理。其通过<code>INotification</code>来抽象多播消息，对应的消息处理类型为<code>INotificationHandler</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;构建 通知消息</span><br><span class="line">public class Ping : INotification &#123; &#125;</span><br><span class="line">&#x2F;&#x2F;构建 消息处理器1</span><br><span class="line">public class Pong1 : INotificationHandler&lt;Ping&gt; &#123;</span><br><span class="line">    public Task Handle(Ping notification, CancellationToken cancellationToken) &#123;</span><br><span class="line">        Debug.WriteLine(&quot;Pong 1&quot;);</span><br><span class="line">        return Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;构建 消息处理器2</span><br><span class="line">public class Pong2 : INotificationHandler&lt;Ping&gt; &#123;</span><br><span class="line">    public Task Handle(Ping notification, CancellationToken cancellationToken) &#123;</span><br><span class="line">        Debug.WriteLine(&quot;Pong 2&quot;);</span><br><span class="line">        return Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;发布消息</span><br><span class="line">await mediator.Publish(new Ping());</span><br></pre></td></tr></table></figure>

<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>对MediatR有了基本认识后，我们来看看源码，研究下其如何实现的。</p>
<p><img src="/images/how-much-you-know-about-the-MediatR/2799767-00b8410a546d62e4.png" alt="类图"></p>
<p>从代码图中我们可以看到其核心的对象主要包括：</p>
<ol>
<li>IRequest Vs IRequestHandler</li>
<li>INotification Vs INoticifaitonHandler</li>
<li>IMediator Vs Mediator</li>
<li>Unit</li>
<li>IPipelineBehavior</li>
</ol>
<h2 id="IRequest-Vs-IRequestHandler"><a href="#IRequest-Vs-IRequestHandler" class="headerlink" title="IRequest Vs IRequestHandler"></a>IRequest Vs IRequestHandler</h2><p>其中<code>IRequest</code>和<code>INotification</code>分别对应单播和多播消息的抽象。<br>对于单播消息可以决定是否需要返回值选用不同的接口：</p>
<ul>
<li>IRequest<T> - 有返回值</li>
<li>IRequest - 无返回值</li>
</ul>
<p>这里就不得不提到其中巧妙的设计，通过引入结构类型<code>Unit</code>来代表无返回的情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 代表无需返回值的请求</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public interface IRequest : IRequest&lt;Unit&gt; &#123; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 代表有返回值的请求</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TResponse&quot;&gt;Response type&lt;&#x2F;typeparam&gt;</span><br><span class="line">public interface IRequest&lt;out TResponse&gt; : IBaseRequest &#123; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; Allows for generic type constraints of objects implementing IRequest or IRequest&#123;TResponse&#125;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public interface IBaseRequest &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>同样对于<code>IRequestHandler</code>也是通过结构类型<code>Unit</code>来处理不需要返回值的情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IRequestHandler&lt;in TRequest, TResponse&gt;</span><br><span class="line">    where TRequest : IRequest&lt;TResponse&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Task&lt;TResponse&gt; Handle(TRequest request, CancellationToken cancellationToken);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface IRequestHandler&lt;in TRequest&gt; : IRequestHandler&lt;TRequest, Unit&gt;</span><br><span class="line">    where TRequest : IRequest&lt;Unit&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面我们可以看出定义了一个方法名为<code>Handle</code>返回值为<code>Task</code>的包装类型，而因此赋予了其具有以同步和异步的方式进行消息处理的能力。我们再看一下其以异步方式进行消息处理（无返回值）的默认实现<code>AsyncRequestHandler</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AsyncRequestHandler&lt;TRequest&gt; : IRequestHandler&lt;TRequest&gt;</span><br><span class="line">    where TRequest : IRequest</span><br><span class="line">&#123;</span><br><span class="line">    async Task&lt;Unit&gt; IRequestHandler&lt;TRequest, Unit&gt;.Handle(TRequest request, CancellationToken cancellationToken)</span><br><span class="line">    &#123;</span><br><span class="line">        await Handle(request, cancellationToken).ConfigureAwait(false);</span><br><span class="line">        return Unit.Value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract Task Handle(TRequest request, CancellationToken cancellationToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码来看，我们很容易看出这是装饰模式的实现方式，是不是很巧妙的解决了无需返回值的场景。</p>
<p>最后我们来看下结构类型<code>Unit</code>的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public struct Unit : IEquatable&lt;Unit&gt;, IComparable&lt;Unit&gt;, IComparable</span><br><span class="line">&#123;</span><br><span class="line">    public static readonly Unit Value &#x3D; new Unit();</span><br><span class="line"></span><br><span class="line">    public static readonly Task&lt;Unit&gt; Task &#x3D; System.Threading.Tasks.Task.FromResult(Value);</span><br><span class="line">    &#x2F;&#x2F; some other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IMediator-Vs-Mediator"><a href="#IMediator-Vs-Mediator" class="headerlink" title="IMediator Vs Mediator"></a>IMediator Vs Mediator</h2><p><img src="/images/how-much-you-know-about-the-MediatR/2799767-19d4eebd2a6dda89.png" alt="MediatR 类图"></p>
<p><code>IMediator</code>主要定义了两个方法<code>Send</code>和<code>Publish</code>，分别用于发送消息和发布通知。其默认实现Mediator中定义了两个集合，分别用来保存请求与请求处理的映射关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Mediator.cs</span><br><span class="line">&#x2F;&#x2F;保存request和requesthandler的映射关系，1对1。</span><br><span class="line">private static readonly ConcurrentDictionary&lt;Type, object&gt; _requestHandlers &#x3D; new ConcurrentDictionary&lt;Type, object&gt;();</span><br><span class="line">&#x2F;&#x2F;保存notification与notificationhandler的映射关系，</span><br><span class="line">private static readonly ConcurrentDictionary&lt;Type, NotificationHandlerWrapper&gt; _notificationHandlers &#x3D; new ConcurrentDictionary&lt;Type, NotificationHandlerWrapper&gt;();</span><br></pre></td></tr></table></figure>
<p>这里面其又引入了两个包装类：<code>RequestHandlerWrapper</code>和<code>NotificationHandlerWrapper</code>。这两个包装类的作用就是用来传递<code>ServiceFactory</code>委托进行依赖解析。</p>
<p>所以说<code>Mediator</code>借助<code>public delegate object ServiceFactory(Type serviceType);</code>完成对Ioc容器的一层抽象。这样就可以对接任意你喜欢用的Ioc容器，比如：Autofac、Windsor或ASP.NET Core默认的Ioc容器，只需要在注册<code>IMediator</code>时指定<code>ServiceFactory</code>类型的委托即可，比如ASP.NET Core中的做法：<br><img src="/images/how-much-you-know-about-the-MediatR/2799767-609f3008b14751ec.png" alt="ASP.NET Core注册IMediatr"></p>
<p><em>在使用ASP.NET Core提供的原生Ioc容器有些问题：<a href="https://github.com/jbogard/MediatR.Extensions.Microsoft.DependencyInjection/issues/12" target="_blank" rel="noopener">Service registration crashes when registering generic handlers</a></em></p>
<h2 id="IPipelineBehavior"><a href="#IPipelineBehavior" class="headerlink" title="IPipelineBehavior"></a>IPipelineBehavior</h2><p><img src="/images/how-much-you-know-about-the-MediatR/2799767-42380e9ad9028a7e.png" alt="处理管道"></p>
<p>MeidatR支持按需配置请求管道进行消息处理。即支持在请求处理前和请求处理后添加额外行为。仅需实现以下两个接口，并注册到Ioc容器即可。</p>
<ul>
<li>IRequestPreProcessor<in TRequest> 请求处理前接口</li>
<li>IRequestPostProcessor&lt;in TRequest, in TResponse&gt; 请求处理后接口</li>
</ul>
<p>其中<code>IPipelineBehavior</code>的默认实现：<code>RequestPreProcessorBehavior</code>和<code>RequestPostProcessorBehavior</code>分别用来处理所有实现<code>IRequestPreProcessor</code>和<code>IRequestPostProcessor</code>接口定义的管道行为。</p>
<p>而处理管道是如何构建的呢？我们来看下<code>RequestHandlerWrapperImpl</code>的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal class RequestHandlerWrapperImpl&lt;TRequest, TResponse&gt; : RequestHandlerWrapper&lt;TResponse&gt;</span><br><span class="line">    where TRequest : IRequest&lt;TResponse&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public override Task&lt;TResponse&gt; Handle(IRequest&lt;TResponse&gt; request, CancellationToken cancellationToken,</span><br><span class="line">        ServiceFactory serviceFactory)</span><br><span class="line">    &#123;</span><br><span class="line">        Task&lt;TResponse&gt; Handler() &#x3D;&gt; GetHandler&lt;IRequestHandler&lt;TRequest, TResponse&gt;&gt;(serviceFactory).Handle((TRequest) request, cancellationToken);</span><br><span class="line"></span><br><span class="line">        return serviceFactory</span><br><span class="line">            .GetInstances&lt;IPipelineBehavior&lt;TRequest, TResponse&gt;&gt;()</span><br><span class="line">            .Reverse()</span><br><span class="line">            .Aggregate((RequestHandlerDelegate&lt;TResponse&gt;) Handler, (next, pipeline) &#x3D;&gt; () &#x3D;&gt; pipeline.Handle((TRequest)request, cancellationToken, next))();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就这样一个简单的函数，涉及的知识点还真不少，说实话我花了不少时间来理清这个逻辑。<br>那都涉及到哪些知识点呢？我们一个一个的来理一理。</p>
<ol>
<li>C# 7.0的新特性 - 局部函数</li>
<li>C# 6.0的新特性 - 表达式形式的成员函数</li>
<li>Linq高阶函数 - <code>Aggregate</code></li>
<li>匿名委托</li>
<li>构造委托函数链</li>
</ol>
<p>关于第1、2个知识点，请看下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public delegate int SumDelegate();&#x2F;&#x2F;定义委托</span><br><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;局部函数(在函数内部定义函数)</span><br><span class="line">    &#x2F;&#x2F;表达式形式的成员函数， 相当于 int Sum() &#123; return 1 + 2;&#125;</span><br><span class="line">    int Sum() &#x3D;&gt; 1 + 2;</span><br><span class="line"></span><br><span class="line">    var sumDelegate &#x3D; (SumDelegate)Sum;&#x2F;&#x2F;转换为委托</span><br><span class="line">    Console.WriteLine(sumDelegate());&#x2F;&#x2F;委托调用，输出：3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看第4个知识点，匿名委托：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public delegate int SumDelegate();</span><br><span class="line"></span><br><span class="line">SumDelegate delegater1 &#x3D; delegate()&#123; return 1+2; &#125;</span><br><span class="line">&#x2F;&#x2F;也相当于</span><br><span class="line">SumDelegate delegater2 &#x3D;&gt; 1+2;</span><br></pre></td></tr></table></figure>

<p>下面再来介绍一下<code>Aggregate</code>这个Linq高阶函数。<code>Aggregate</code>是对一个集合序列进行累加操作，通过指定初始值，累加函数，以及结果处理函数完成计算。</p>
<p>函数定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt;</span><br><span class="line">(this IEnumerable&lt;TSource&gt; source, </span><br><span class="line">TAccumulate seed, </span><br><span class="line">Func&lt;TAccumulate,TSource,TAccumulate&gt; func, </span><br><span class="line">Func&lt;TAccumulate,TResult&gt; resultSelector);</span><br></pre></td></tr></table></figure>

<p>根据函数定义我们来写个简单的demo：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var nums &#x3D; Enumerable.Range(2, 3);&#x2F;&#x2F;[2,3,4]</span><br><span class="line">&#x2F;&#x2F; 计算1到5的累加之和，再将结果乘以2</span><br><span class="line">var sum &#x3D; nums.Aggregate(1, (total, next) &#x3D;&gt; total + next, result &#x3D;&gt; result * 2);&#x2F;&#x2F; 相当于 (((1+2)+3)+4)*2&#x3D;20</span><br><span class="line">Console.WriteLine(sum);&#x2F;&#x2F;20</span><br></pre></td></tr></table></figure>
<p>和函数参数进行一一对应：</p>
<ol>
<li>seed : 1</li>
<li>Func&lt;TAccumulate,TSource,TAccumulate&gt; func : (total, next) =&gt; total + next</li>
<li>Func&lt;TAccumulate,TResult&gt; resultSelector : result =&gt; result * 2</li>
</ol>
<p>基于上面的认识，我们再来回过头梳理一下<code>RequestHandlerWrapperImpl</code>。<br>其主要是借助委托：<code>public delegate Task&lt;TResponse&gt; RequestHandlerDelegate&lt;TResponse&gt;();</code>来构造委托函数链来构建处理管道。</p>
<p>对<code>Aggregate</code>函数了解后，我们就不难理解处理管道的构建了。请看下图中的代码解读：</p>
<p><img src="/images/how-much-you-know-about-the-MediatR/2799767-4f2985f53e955b6b.png" alt="请求处理管道代码解读"></p>
<p><img src="/images/how-much-you-know-about-the-MediatR/2799767-ea1971598e09240a.png" alt="构建流程解析"></p>
<p>那如何保证先执行<code>IRequestPreProcessor</code>再执行<code>IRequestPostProcessor</code>呢？<br>就是在注册到Ioc容器时必须保证顺序，先注册<code>IRequestPreProcessor</code>再注册<code>IRequestPostProcessor</code>。（这一点很重要！！！）</p>
<p><em>看到这里有没有想到ASP.NET Core中请求管道中中间件的构建呢？是不是很像俄罗斯套娃？先由内而外构建管道，再由外而内执行！</em></p>
<p>至此，MediatR的实现思路算是理清了。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>如文章开头提到：MediatR是一种进程内消息传递机制。 支持以同步或异步的形式进行请求/响应，命令，查询，通知和事件的消息传递，并通过C#泛型支持消息的智能调度。</p>
<p>那么我们就应该明白，其核心是<strong>消息的解耦</strong>。因为我们几乎都是在与消息打交道，那因此它的应用场景就很广泛，比如我们可以基于MediatR实现CQRS、EventBus等。</p>
<p>另外，还有一种应用场景：我们知道借助依赖注入的好处是，就是解除依赖，但我们又不得不思考一个问题，随着业务逻辑复杂度的增加，构造函数可能要注入更多的服务，当注入的依赖太多时，其会导致构造函数膨胀。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public DashboardController(</span><br><span class="line">    ICustomerRepository customerRepository,</span><br><span class="line">    IOrderService orderService,</span><br><span class="line">    ICustomerHistoryRepository historyRepository,</span><br><span class="line">    IOrderRepository orderRepository,</span><br><span class="line">    IProductRespoitory productRespoitory,</span><br><span class="line">    IRelatedProductsRepository relatedProductsRepository,</span><br><span class="line">    ISupportService supportService,</span><br><span class="line">    ILog logger</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>如果借助<code>MediatR</code>进行改造，也许仅需注入<code>IMediatR</code>就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public DashboardController(IMediatR mediatr)</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看到这里，也许你应该明白MediatR实质上并不是严格意义上的中介者模式实现，我更倾向于其是基于Ioc容器的一层抽象，根据请求定位相应的请求处理器进行消息处理，也就是服务定位。<br>那到这里似乎也恍然大悟MediatR这个笔误可能是有意为之了。序员，你怎么看？</p>
<blockquote>
<p>参考资料：<br><a href="https://lostechies.com/jimmybogard/2016/10/27/cqrsmediatr-implementation-patterns/" target="_blank" rel="noopener">CQRS/MediatR implementation patterns</a><br><a href="https://stackoverflow.com/questions/50663501/mediatr-when-and-why-i-should-use-it-vs-2017-webapi" target="_blank" rel="noopener">MediatR when and why I should use it? vs 2017 webapi</a><br><a href="https://www.jianshu.com/p/c28500ec9439?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">ABP CQRS 实现案例:基于 MediatR 实现</a></p>
</blockquote>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>发布订阅模式</tag>
        <tag>中介者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>事件总线知多少(1)</title>
    <url>/post/how-much-you-know-about-the-eventbus-1/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>事件总线这个概念对你来说可能很陌生，但提到观察者（发布-订阅）模式，你也许就很熟悉。事件总线是对发布-订阅模式的一种实现。它是一种集中式事件处理机制，允许不同的组件之间进行彼此通信而又不需要相互依赖，达到一种解耦的目的。</p>
<p>我们来看看事件总线的处理流程：</p>
<p><img src="/images/how-much-you-know-about-the-eventbus-1/2799767-6f44bdefa88a23a2.png" alt="图1：EventBus流程"></p>
<p>了解了事件总线的基本概念和处理流程，下面我们就来分析下如何去实现事件总线。</p>
<h1 id="2-回归本质"><a href="#2-回归本质" class="headerlink" title="2.回归本质"></a>2.回归本质</h1><p>在动手实现事件总线之前，我们还是要追本溯源，探索一下事件的本质和发布订阅模式的实现机制。</p>
<h2 id="2-1-事件的本质"><a href="#2-1-事件的本质" class="headerlink" title="2.1.事件的本质"></a>2.1.事件的本质</h2><p>我们先来探讨一下事件的概念。都是读过书的，应该都还记得记叙文的六要素：时间、地点、人物、事件（起因、经过、结果）。</p>
<blockquote>
<p>我们拿注册的案例，来解释一下。<br>用户输入用户名、邮箱、密码后，点击注册，输入无误校验通过后，注册成功并发送邮件给用户，要求用户进行邮箱验证激活。</p>
</blockquote>
<p>这里面就涉及了两个主要事件：</p>
<ol>
<li>注册事件：起因是用户点击了注册按钮，经过是输入校验，结果是是否注册成功。</li>
<li>发送邮件事件：起因是用户使用邮箱注册成功需要验证邮箱，经过是邮件发送，结果是邮件是否发送成功。</li>
</ol>
<p>其实这六要素也适用于我们程序中事件的处理过程。开发过WinForm程序的都知道，我们在做UI设计的时候，从工具箱拖入一个注册按钮（btnRegister），双击它，VS就会自动帮我们生成如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void btnRegister_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line"> &#x2F;&#x2F; 事件的处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>object sender</code>指代发出事件的对象，这里也就是button对象；<code>EventArgs e</code> 事件参数，可以理解为对事件的描述 ，它们可以统称为<strong>事件源</strong>。其中的代码逻辑，就是对事件的处理。我们可以统称为<strong>事件处理</strong>。</p>
<p>说了这么多，无非是想透过现象看本质：<strong>事件是由事件源触发并由事件处理消费（An event is raised by an event source and consumed by an event handler</strong>）。</p>
<h2 id="2-2-发布订阅模式"><a href="#2-2-发布订阅模式" class="headerlink" title="2.2. 发布订阅模式"></a>2.2. 发布订阅模式</h2><blockquote>
<p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 ——发布订阅模式</p>
</blockquote>
<p>发布订阅模式主要有两个角色：</p>
<ul>
<li>发布方（Publisher）：也称为被观察者，当状态改变时负责通知所有订阅者。</li>
<li>订阅方（Subscriber）：也称为观察者，订阅事件并对接收到的事件进行处理。</li>
</ul>
<p>发布订阅模式有两种实现方式：</p>
<ul>
<li>简单的实现方式：由Publisher维护一个订阅者列表，当状态改变时循环遍历列表通知订阅者。</li>
<li>委托的实现方式：由Publisher定义事件委托，Subscriber实现委托。</li>
</ul>
<p>总的来说，发布订阅模式中有两个关键字，通知和更新。<br>被观察者状态改变通知观察者做出相应更新。<br>解决的是当对象改变时需要通知其他对象做出相应改变的问题。</p>
<p>如果画一个图来表示这个流程的画，图形应该是这样的：</p>
<p><img src="/images/how-much-you-know-about-the-eventbus-1/2799767-8a17f6e834278167.png" alt="图2：发布订阅模式流程"></p>
<h1 id="3-实现发布订阅模式"><a href="#3-实现发布订阅模式" class="headerlink" title="3. 实现发布订阅模式"></a>3. 实现发布订阅模式</h1><p>相信通过上面的解释，对事件和发布订阅模式有了一个大概的印象。都说理论要与实践相结合，所以我们还是动动手指敲敲代码比较好。<br>我将以<a href="http://www.jianshu.com/p/45675c73296d" target="_blank" rel="noopener">『观察者模式』来钓鱼</a>这个例子为基础，通过重构的方式来完善一个更加通用的发布订阅模式。<br>先上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 鱼的品类枚举</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public enum FishType</span><br><span class="line">&#123;</span><br><span class="line">    鲫鱼,</span><br><span class="line">    鲤鱼,</span><br><span class="line">    黑鱼,</span><br><span class="line">    青鱼,</span><br><span class="line">    草鱼,</span><br><span class="line">    鲈鱼</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>钓鱼竿的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F;     鱼竿（被观察者）</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public class FishingRod</span><br><span class="line">&#123;</span><br><span class="line">    public delegate void FishingHandler(FishType type); &#x2F;&#x2F;声明委托</span><br><span class="line">    public event FishingHandler FishingEvent; &#x2F;&#x2F;声明事件</span><br><span class="line"></span><br><span class="line">    public void ThrowHook(FishingMan man)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;开始下钩！&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;用随机数模拟鱼咬钩，若随机数为偶数，则为鱼咬钩</span><br><span class="line">        if (new Random().Next() % 2 &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            var type &#x3D; (FishType) new Random().Next(0, 5);</span><br><span class="line">            Console.WriteLine(&quot;铃铛：叮叮叮，鱼儿咬钩了&quot;);</span><br><span class="line">            if (FishingEvent !&#x3D; null)</span><br><span class="line">                FishingEvent(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>垂钓者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F;     垂钓者（观察者）</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public class FishingMan</span><br><span class="line">&#123;</span><br><span class="line">    public FishingMan(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        Name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public int FishCount &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 垂钓者自然要有鱼竿啊</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    public FishingRod FishingRod &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public void Fishing()</span><br><span class="line">    &#123;</span><br><span class="line">        this.FishingRod.ThrowHook(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Update(FishType type)</span><br><span class="line">    &#123;</span><br><span class="line">        FishCount++;</span><br><span class="line">        Console.WriteLine(&quot;&#123;0&#125;：钓到一条[&#123;2&#125;]，已经钓到&#123;1&#125;条鱼了！&quot;, Name, FishCount, type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>场景类也很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1、初始化鱼竿</span><br><span class="line">var fishingRod &#x3D; new FishingRod();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、声明垂钓者</span><br><span class="line">var jeff &#x3D; new FishingMan(&quot;圣杰&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.分配鱼竿</span><br><span class="line">jeff.FishingRod &#x3D; fishingRod;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;4、注册观察者</span><br><span class="line">fishingRod.FishingEvent +&#x3D; jeff.Update;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;5、循环钓鱼</span><br><span class="line">while (jeff.FishCount &lt; 5)</span><br><span class="line">&#123;</span><br><span class="line">    jeff.Fishing();</span><br><span class="line">    Console.WriteLine(&quot;-------------------&quot;);</span><br><span class="line">    &#x2F;&#x2F;睡眠5s</span><br><span class="line">    Thread.Sleep(5000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，相信你一看就明白。但很显然这个代码实现仅适用于当前这个钓鱼场景，假如有其他场景也想使用这个模式，我们还需要重新定义委托，重新定义事件处理，岂不很累。本着”Don’t repeat yourself“的原则，我们要对其进行重构。</p>
<p>结合我们对事件本质的探讨，事件是由事件源和事件处理组成。针对我们上面的案例来说，<code>public delegate void FishingHandler(FishType type);</code>这句代码就已经说明了事件源和事件处理。事件源就是<code>FishType type</code>，事件处理自然是注册到<code>FishingHandler</code>上面的委托实例。<br>问题找到了，很显然是我们的事件源和事件处理不够抽象，所以不能通用，下面咱们就来动手改造。</p>
<h2 id="3-1-提取事件源"><a href="#3-1-提取事件源" class="headerlink" title="3.1. 提取事件源"></a>3.1. 提取事件源</h2><p>事件源应该至少包含事件发生的时间和触发事件的对象。<br>我们提取<code>IEventData</code>接口来封装事件源：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 定义事件源接口，所有的事件源都要实现该接口</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public interface IEventData</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 事件发生的时间</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    DateTime EventTime &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 触发事件的对象</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    object EventSource &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自然我们应该给一个默认的实现<code>EventData</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 事件源：描述事件信息，用于参数传递</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public class EventData : IEventData</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 事件发生的时间</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    public DateTime EventTime &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 触发事件的对象</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    public Object EventSource &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public EventData()</span><br><span class="line">    &#123;</span><br><span class="line">        EventTime &#x3D; DateTime.Now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对Demo，扩展事件源如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FishingEventData : EventData</span><br><span class="line">&#123;</span><br><span class="line">    public FishType FishType &#123; get; set; &#125;</span><br><span class="line">    public FishingMan FisingMan &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成后，我们就可以去把在<code>FishingRod</code>声明的委托参数类型改为<code>FishingEventData</code>类型了，即<code>public delegate void FishingHandler(FishingEventData eventData); //声明委托</code>；<br>然后修改<code>FishingMan</code>的<code>Update</code>方法按委托定义的参数类型修改即可，代码我就不放了，大家自行脑补。</p>
<p>到这一步我们就统一了事件源的定义方式。</p>
<h2 id="3-2-提取事件处理器"><a href="#3-2-提取事件处理器" class="headerlink" title="3.2.提取事件处理器"></a>3.2.提取事件处理器</h2><p>事件源统一了，那事件处理也得加以限制。比如如果随意命名事件处理方法名，那在进行事件注册的时候还要去按照委托定义的参数类型去匹配，岂不麻烦。</p>
<p>我们提取一个<code>IEventHandler</code>接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 定义事件处理器公共接口，所有的事件处理都要实现该接口</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public interface IEventHandler</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件处理要与事件源进行绑定，所以我们再来定义一个泛型接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 泛型事件处理器接口</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TEventData&quot;&gt;&lt;&#x2F;typeparam&gt;</span><br><span class="line">public interface IEventHandler&lt;TEventData&gt; : IEventHandler where TEventData : IEventData</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 事件处理器实现该方法来处理事件</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventData&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">    void HandleEvent(TEventData eventData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会纳闷，为什么先定义了一个空接口？这里就留给自己思考吧。</p>
<p>至此我们就完成了事件处理的抽象。我们再继续去改造我们的Demo。我们让<code>FishingMan</code>实现<code>IEventHandler</code>接口，然后修改场景类中将<code>fishingRod.FishingEvent += jeff.Update;</code>改为<code>fishingRod.FishingEvent += jeff.HandleEvent;</code>即可。代码改动很简单，同样在此略去。</p>
<p>至此你可能觉得我们完成了对Demo的改造。但事实上呢，我们还要弄清一个问题——如果这个<code>FishingMan</code>订阅的有其他的事件，我们该如何处理？<br>聪颖如你，你立马想到了可以<strong>通过事件源来进行区分处理</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FishingMan : IEventHandler&lt;IEventData&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他代码</span><br><span class="line">    public void HandleEvent(IEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        if (eventData is FishingEventData)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;do something</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(eventData is XxxEventData)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;do something else</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，这个模式实现到这个地步基本已经可以通用了。</p>
<h1 id="4-实现事件总线"><a href="#4-实现事件总线" class="headerlink" title="4. 实现事件总线"></a>4. 实现事件总线</h1><p>通用的发布订阅模式不是我们的目的，我们的目的是一个集中式的事件处理机制，且各个模块之间相互不产生依赖。那我们如何做到呢？同样我们还是一步一步的进行分析改造。</p>
<h2 id="4-1-分析问题"><a href="#4-1-分析问题" class="headerlink" title="4.1.分析问题"></a>4.1.分析问题</h2><p>思考一下，每次为了实现这个模式，都要完成以下三步：</p>
<ol>
<li>事件发布方定义事件委托</li>
<li>事件订阅方定义事件处理逻辑</li>
<li>显示的订阅事件</li>
</ol>
<p>虽然只有三步，但这三步已经很繁琐了。而且事件发布方和事件订阅方还存在着依赖（体现在订阅者要显示的进行事件的注册和注销上）。而且当事件过多时，直接在订阅者中实现<code>IEventHandler</code>接口处理多个事件逻辑显然不太合适，违法单一职责原则。这里就暴露了三个问题：</p>
<ol>
<li>如何精简步骤？</li>
<li>如何解除发布方与订阅方的依赖？</li>
<li>如何避免在订阅者中同时处理多个事件逻辑？</li>
</ol>
<p>带着问题思考，我们就会更接近真相。</p>
<p>想要精简步骤，那我们需要寻找共性。共性就是事件的本质，也就是我们针对事件源和事件处理提取出来的两个接口。</p>
<p>想要解除依赖，那就要在发布方和订阅方之间添加一个中介。</p>
<p>想要避免订阅者同时处理过多事件逻辑，那我们就把事件逻辑的处理提取到订阅者外部。</p>
<p>思路有了，下面我们就来实施吧。</p>
<h2 id="4-2-解决问题"><a href="#4-2-解决问题" class="headerlink" title="4.2.解决问题"></a>4.2.解决问题</h2><p>本着先易后难的思想，我们下面就来解决以上问题。</p>
<h3 id="4-2-1-实现IEventHandler"><a href="#4-2-1-实现IEventHandler" class="headerlink" title="4.2.1. 实现IEventHandler"></a>4.2.1. 实现IEventHandler</h3><p>我们先解决上面的第三个问题：如何避免在订阅者中同时处理多个事件逻辑？</p>
<p>自然是针对不同的事件源<code>IEventData</code>实现不同的<code>IEventHandler</code>。改造后的钓鱼事件处理逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 钓鱼事件处理</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public class FishingEventHandler : IEventHandler&lt;FishingEventData&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public void HandleEvent(FishingEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        eventData.FishingMan.FishCount++;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(&quot;&#123;0&#125;：钓到一条[&#123;2&#125;]，已经钓到&#123;1&#125;条鱼了！&quot;,</span><br><span class="line">            eventData.FishingMan.Name, eventData.FishingMan.FishCount, eventData.FishType);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时我们就可以移除在<code>FishingMan</code>中实现的<code>IEventHandler</code>接口了。<br>然后将事件注册改为<code>fishingRod.FishingEvent += new FishingEventHandler().HandleEvent;</code>即可。</p>
<h3 id="4-2-2-统一注册事件"><a href="#4-2-2-统一注册事件" class="headerlink" title="4.2.2. 统一注册事件"></a>4.2.2. 统一注册事件</h3><p>上一个问题的解决，有助于我们解决第一个问题：如何精简流程？<br>为什么呢，因为我们是根据事件源定义相应的事件处理的。也就是我们之前说的可以根据事件源来区分事件。<br>然后呢？反射，我们可以通过反射来进行事件的统一注册。<br>在<code>FishingRod</code>的构造函数中使用反射，统一注册实现了<code>IEventHandler&lt;FishingEventData&gt;</code>类型的实例方法<code>HandleEvent</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public FishingRod()</span><br><span class="line">&#123;</span><br><span class="line">    Assembly assembly &#x3D; Assembly.GetExecutingAssembly();</span><br><span class="line"></span><br><span class="line">    foreach (var type in assembly.GetTypes())</span><br><span class="line">    &#123;</span><br><span class="line">        if (typeof(IEventHandler).IsAssignableFrom(type))&#x2F;&#x2F;判断当前类型是否实现了IEventHandler接口</span><br><span class="line">        &#123;</span><br><span class="line">            Type handlerInterface &#x3D; type.GetInterface(&quot;IEventHandler&#96;1&quot;);&#x2F;&#x2F;获取该类实现的泛型接口</span><br><span class="line">            Type eventDataType &#x3D; handlerInterface.GetGenericArguments()[0]; &#x2F;&#x2F; 获取泛型接口指定的参数类型</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;如果参数类型是FishingEventData，则说明事件源匹配</span><br><span class="line">            if (eventDataType.Equals(typeof(FishingEventData)))</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;创建实例</span><br><span class="line">                var handler &#x3D; Activator.CreateInstance(type) as IEventHandler&lt;FishingEventData&gt;;</span><br><span class="line">                &#x2F;&#x2F;注册事件</span><br><span class="line">                FishingEvent +&#x3D; handler.HandleEvent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就可以移出场景类中的显示注册代码<code>fishingRod.FishingEvent += new FishingEventHandler().HandleEvent;</code>。</p>
<h3 id="4-2-3-解除依赖"><a href="#4-2-3-解除依赖" class="headerlink" title="4.2.3. 解除依赖"></a>4.2.3. 解除依赖</h3><p>如何解除依赖呢？其实答案就在本文的两张图上，仔细对比我们可以很直观的看到，Event Bus就相当于一个介于Publisher和Subscriber中间的桥梁。它隔离了Publlisher和Subscriber之间的直接依赖，接管了所有事件的发布和订阅逻辑，并负责事件的中转。</p>
<p><strong>Event Bus终于要粉墨登场了！！！</strong><br>分析一下，如果EventBus要接管所有事件的发布和订阅，那它则需要有一个容器来记录事件源和事件处理。那又如何触发呢？有了事件源，我们就自然能找到绑定的事件处理逻辑，通过反射触发。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 事件总线</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public class EventBus</span><br><span class="line">&#123;</span><br><span class="line">    public static EventBus Default &#x3D;&gt; new EventBus();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 定义线程安全集合</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    private readonly ConcurrentDictionary&lt;Type, List&lt;Type&gt;&gt; _eventAndHandlerMapping;</span><br><span class="line"></span><br><span class="line">    public EventBus()</span><br><span class="line">    &#123;</span><br><span class="line">        _eventAndHandlerMapping &#x3D; new ConcurrentDictionary&lt;Type, List&lt;Type&gt;&gt;();</span><br><span class="line">        MapEventToHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;通过反射，将事件源与事件处理绑定</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    private void MapEventToHandler()</span><br><span class="line">    &#123;</span><br><span class="line">        Assembly assembly &#x3D; Assembly.GetEntryAssembly();</span><br><span class="line">        foreach (var type in assembly.GetTypes())</span><br><span class="line">        &#123;</span><br><span class="line">            if (typeof(IEventHandler).IsAssignableFrom(type))&#x2F;&#x2F;判断当前类型是否实现了IEventHandler接口</span><br><span class="line">            &#123;</span><br><span class="line">                Type handlerInterface &#x3D; type.GetInterface(&quot;IEventHandler&#96;1&quot;);&#x2F;&#x2F;获取该类实现的泛型接口</span><br><span class="line">                if (handlerInterface !&#x3D; null)</span><br><span class="line">                &#123;</span><br><span class="line">                    Type eventDataType &#x3D; handlerInterface.GetGenericArguments()[0]; &#x2F;&#x2F; 获取泛型接口指定的参数类型</span><br><span class="line"></span><br><span class="line">                    if (_eventAndHandlerMapping.ContainsKey(eventDataType))</span><br><span class="line">                    &#123;</span><br><span class="line">                        List&lt;Type&gt; handlerTypes &#x3D; _eventAndHandlerMapping[eventDataType];</span><br><span class="line">                        handlerTypes.Add(type);</span><br><span class="line">                        _eventAndHandlerMapping[eventDataType] &#x3D; handlerTypes;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        var handlerTypes &#x3D; new List&lt;Type&gt; &#123; type &#125;;</span><br><span class="line">                        _eventAndHandlerMapping[eventDataType] &#x3D; handlerTypes;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 手动绑定事件源与事件处理</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TEventData&quot;&gt;&lt;&#x2F;typeparam&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventHandler&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">    public void Register&lt;TEventData&gt;(Type eventHandler)</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Type&gt; handlerTypes &#x3D; _eventAndHandlerMapping[typeof(TEventData)];</span><br><span class="line">        if (!handlerTypes.Contains(eventHandler))</span><br><span class="line">        &#123;</span><br><span class="line">            handlerTypes.Add(eventHandler);</span><br><span class="line">            _eventAndHandlerMapping[typeof(TEventData)] &#x3D; handlerTypes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 手动解除事件源与事件处理的绑定</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TEventData&quot;&gt;&lt;&#x2F;typeparam&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventHandler&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">    public void UnRegister&lt;TEventData&gt;(Type eventHandler)</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Type&gt; handlerTypes &#x3D; _eventAndHandlerMapping[typeof(TEventData)];</span><br><span class="line">        if (handlerTypes.Contains(eventHandler))</span><br><span class="line">        &#123;</span><br><span class="line">            handlerTypes.Remove(eventHandler);</span><br><span class="line">            _eventAndHandlerMapping[typeof(TEventData)] &#x3D; handlerTypes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 根据事件源触发绑定的事件处理</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TEventData&quot;&gt;&lt;&#x2F;typeparam&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventData&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">    public void Trigger&lt;TEventData&gt;(TEventData eventData) where TEventData : IEventData</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Type&gt; handlers &#x3D; _eventAndHandlerMapping[eventData.GetType()];</span><br><span class="line"></span><br><span class="line">        if (handlers !&#x3D; null &amp;&amp; handlers.Count &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            foreach (var handler in handlers)</span><br><span class="line">            &#123;</span><br><span class="line">                MethodInfo methodInfo &#x3D; handler.GetMethod(&quot;HandleEvent&quot;);</span><br><span class="line">                if (methodInfo !&#x3D; null)</span><br><span class="line">                &#123;</span><br><span class="line">                    object obj &#x3D; Activator.CreateInstance(handler);</span><br><span class="line">                    methodInfo.Invoke(obj, new object[] &#123; eventData &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件总线主要定义三个方法，注册、取消注册、事件触发。还有一点就是我们在构造函数中通过反射去进行事件源和事件处理的绑定。<br>代码注释已经很清楚了，这里就不过多解释了。</p>
<p>下面我们就来修改Demo，修改<code>FishingRod</code>的事件触发：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 下钩</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public void ThrowHook(FishingMan man)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;开始下钩！&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;用随机数模拟鱼咬钩，若随机数为偶数，则为鱼咬钩</span><br><span class="line">    if (new Random().Next() % 2 &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        var a &#x3D; new Random(10).Next();</span><br><span class="line">        var type &#x3D; (FishType)new Random().Next(0, 5);</span><br><span class="line">        Console.WriteLine(&quot;铃铛：叮叮叮，鱼儿咬钩了&quot;);</span><br><span class="line">        if (FishingEvent !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            var eventData &#x3D; new FishingEventData() &#123; FishType &#x3D; type, FishingMan &#x3D; man &#125;;</span><br><span class="line">            &#x2F;&#x2F;FishingEvent(eventData);&#x2F;&#x2F;不再需要通过事件委托触发</span><br><span class="line">            EventBus.Default.Trigger&lt;FishingEventData&gt;(eventData);&#x2F;&#x2F;直接通过事件总线触发即可</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，事件总线的雏形已经形成！</p>
<h1 id="5-事件总线的总结"><a href="#5-事件总线的总结" class="headerlink" title="5.事件总线的总结"></a>5.事件总线的总结</h1><p>通过上面一步一步的分析和实践，发现事件总线也不是什么高深的概念，只要我们自己善于思考，勤于动手，也能实现自己的事件总线。<br>根据我们的实现，大概总结出以下几条：</p>
<ol>
<li>事件总线维护一个事件源与事件处理的映射字典；</li>
<li>通过单例模式，确保事件总线的唯一入口；</li>
<li>利用反射完成事件源与事件处理的初始化绑定；</li>
<li>提供统一的事件注册、取消注册和触发接口。</li>
</ol>
<p>最后，以上事件总线的实现只是一个雏形，还有很多潜在的问题。有兴趣的不妨思考完善一下，我也会继续更新，尽情期待。<a href="https://github.com/yanshengjie/EventBus" target="_blank" rel="noopener">源码路径：Github-EventBus</a></p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="https://github.com/aspnetboilerplate/aspnetboilerplate/tree/dev/src/Abp/Events/Bus" target="_blank" rel="noopener">ABP EventBus</a><br><a href="http://www.cnblogs.com/lori/p/3476703.html" target="_blank" rel="noopener">DDD~领域事件与事件总线</a><br><a href="http://www.cnblogs.com/dehai/p/4887998.html" target="_blank" rel="noopener">DDD事件总线的实现</a></p>
</blockquote>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>发布订阅模式</tag>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title>事件总线知多少(2)</title>
    <url>/post/how-much-you-know-about-the-eventbus-2/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><p>之前的一篇文章<a href="/how-much-you-know-about-the-eventbus-1/">事件总线知多少(1)</a>，介绍了什么是事件总线，并通过发布订阅模式一步一步的分析重构，形成了事件总线的Alpha版本，这篇文章也得到了大家的肯定和积极的反馈和建议，在此谢谢大家。本着继续学习和回馈大家的思想，我决定继续完善。本文将继续延续上一篇循序渐进的写作风格，来完成对事件总线的分析和优化。<br><img src="/images/how-much-you-know-about-the-eventbus-2/2799767-6f44bdefa88a23a2.png" alt=""></p>
<h1 id="2-回顾事件总线"><a href="#2-回顾事件总线" class="headerlink" title="2.回顾事件总线"></a>2.回顾事件总线</h1><p>在进行具体分析之前，我们还是先对我们实现的事件总线进行一个简单的回顾：</p>
<ol>
<li>针对事件源，抽象<code>IEventData</code>接口；</li>
<li>针对事件处理，抽象<code>IEventHandler&lt;TEventData&gt;</code>接口，定义唯一事件处理方法<code>void HandleEvent(IEventData eventData)</code>；</li>
<li>事件总线维护一个事件源和事件处理的类型映射字典<code>ConcurrentDictionary&lt;Type, List&lt;Type&gt;&gt; _eventAndHandlerMapping</code>；</li>
<li>通过单例模式，确保事件总线的唯一入口；</li>
<li>利用反射完成事件源与事件处理的动态初始化绑定；</li>
<li>提供入口支持事件的手动注册/取消注册；</li>
<li>提供统一的事件触发接口，通过反射动态创建<code>IEventHandler</code>实例完成具体事件处理逻辑的调用。</li>
</ol>
<h1 id="3-发现反射问题"><a href="#3-发现反射问题" class="headerlink" title="3.发现反射问题"></a>3.发现反射问题</h1><p>基于以上的简单回顾，我们可以发现Alpha版本事件总线的成功离不开反射的支持。从动态绑定到动态触发，都是反射在默默的处理着业务逻辑。如果我们只是简单学习了解事件总线，使用反射无可厚非。但如果在实际的项目中，使用反射却不是一个很明智的行为，因为其性能问题。尤其是事件总线要集中处理整个应用程序的所有事件，更易导致程序性能瓶颈。<br>既然说到了反射性能，那就顺便解释下为什么反射性能差？</p>
<ol>
<li>类型绑定（元数据字符串匹配）</li>
<li>参数校验</li>
<li>安全校验</li>
<li>基于运行时</li>
<li>反射产生大量临时对象，增加GC负担</li>
</ol>
<p>那既然反射有性能瓶颈，我们该如何是好呢？<br>你可能会说，既然反射有问题，那就对反射进行性能优化，比如增加缓存机制。出发点是好的，但最终还是在反射问题的阴影之下。对于反射我们应该持以这样一种态度：能不用反射，则不用反射。</p>
<p>那既然要推翻反射这条路，那如何解决动态绑定和动态触发的问题呢？<br>办法总比问题多。额，啊，嗯。就不饶圈子了，咱们上IOC。</p>
<h1 id="4-使用IOC解除依赖"><a href="#4-使用IOC解除依赖" class="headerlink" title="4.使用IOC解除依赖"></a>4.使用IOC解除依赖</h1><p>先看下面一张图，来了解下DIP、IOC、DI与SL之间的关系，详细可参考<a href="http://www.jianshu.com/p/96947ec3e508" target="_blank" rel="noopener">Asp.net mvc 知多少（十）</a>。<br><img src="/images/how-much-you-know-about-the-eventbus-2/2799767-5b46dd0a9842ddd5.png" alt="DIP&amp;IOC&amp;DI&amp;SL"></p>
<p>下面我们就以<a href="https://github.com/castleproject/Windsor" target="_blank" rel="noopener">Castle Windsor</a>作为我们的IOC容器为例，来讲解下如何解除依赖。</p>
<h2 id="4-1-了解Castle-Windsor"><a href="#4-1-了解Castle-Windsor" class="headerlink" title="4.1. 了解Castle Windsor"></a>4.1. 了解Castle Windsor</h2><p>使用Castle Windsor主要包含以下几步：</p>
<ol>
<li>初始化容器：<code>var container = new WindsorContainer();</code></li>
<li>使用WindsorInstallers从执行程序集添加和配置所有组件：<code>container.Install(FromAssembly.This());</code></li>
<li>实现<code>IWindsorInstaller</code>自定义安装器：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RepositoriesInstaller : IWindsorInstaller</span><br><span class="line">&#123;</span><br><span class="line">	public void Install(IWindsorContainer container, IConfigurationStore store)</span><br><span class="line">	&#123;</span><br><span class="line">		container.Register(Classes.FromThisAssembly()</span><br><span class="line">			                .Where(Component.IsInSameNamespaceAs&lt;King&gt;())</span><br><span class="line">			                .WithService.DefaultInterfaces()</span><br><span class="line">			                .LifestyleTransient());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注册和解析依赖</li>
<li>程序退出时，释放容器</li>
</ol>
<h2 id="4-2-使用Castle-Windsor"><a href="#4-2-使用Castle-Windsor" class="headerlink" title="4.2. 使用Castle Windsor"></a>4.2. 使用Castle Windsor</h2><p>使用IOC容器的目的很明确，一个是在注册事件时完成依赖的注入，一个是在触发事件时完成依赖的解析。从而完成事件的动态绑定和触发。</p>
<h3 id="4-2-1-初始化容器"><a href="#4-2-1-初始化容器" class="headerlink" title="4.2.1. 初始化容器"></a>4.2.1. 初始化容器</h3><p>要在<code>EventBus</code>这个类中完成事件依赖的注入和解析，就需要在本类中持有一个对<code>IWindsorContainer</code>的引用。<br>可以直接定义一个只读属性，并在构造函数中进行初始化即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public IWindsorContainer IocContainer &#123; get; private set; &#125;&#x2F;&#x2F;定义IOC容器</span><br><span class="line">private readonly ConcurrentDictionary&lt;Type, List&lt;Type&gt;&gt; _eventAndHandlerMapping;</span><br><span class="line">public EventBus()</span><br><span class="line">&#123;</span><br><span class="line">      IocContainer &#x3D; new WindsorContainer();</span><br><span class="line">      _eventAndHandlerMapping &#x3D; new ConcurrentDictionary&lt;Type, List&lt;Type&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-注册和取消注册依赖"><a href="#4-2-2-注册和取消注册依赖" class="headerlink" title="4.2.2.注册和取消注册依赖"></a>4.2.2.注册和取消注册依赖</h3><p>初始化完容器，我们需要在手动注册和取消注册事件API上分别完成依赖的注册和取消注册。因为Castle Windsor在3.0版本取消了UnRegister方法，所以在进行事件注册时，就不再手动卸载IOC容器中已注册的依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 手动绑定事件源与事件处理</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventType&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;handlerType&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line"> public void Register(Type eventType, Type handlerType)</span><br><span class="line"> &#123;</span><br><span class="line">     &#x2F;&#x2F;注册IEventHandler&lt;T&gt;到IOC容器</span><br><span class="line">     var handlerInterface &#x3D; handlerType.GetInterface(&quot;IEventHandler&#96;1&quot;);</span><br><span class="line">     if (!IocContainer.Kernel.HasComponent(handlerInterface))</span><br><span class="line">     &#123;</span><br><span class="line">         IocContainer.Register(Component.For(handlerInterface, handlerType));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;注册到事件总线</span><br><span class="line">     &#x2F;&#x2F;省略其他代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 手动解除事件源与事件处理的绑定</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TEventData&quot;&gt;&lt;&#x2F;typeparam&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;handlerType&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">public void UnRegister&lt;TEventData&gt;(Type handlerType)</span><br><span class="line">&#123;</span><br><span class="line">    _eventAndHandlerMapping.GetOrAdd(typeof(TEventData), (type) &#x3D;&gt; new List&lt;Type&gt;())</span><br><span class="line">        .RemoveAll(t &#x3D;&gt; t &#x3D;&#x3D; handlerType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-3-动态事件绑定"><a href="#4-2-3-动态事件绑定" class="headerlink" title="4.2.3. 动态事件绑定"></a>4.2.3. 动态事件绑定</h3><p>要实现事件的动态绑定，我们要拿到所有<code>IEventHandler&lt;T&gt;</code>的实现。而遍历所有类型最好的办法就是拿到程序集（Assembly）。拿到程序集后就可以将所有<code>IEventHandler&lt;T&gt;</code>的实现注册到IOC容器，然后再基于IOC容器注册的<code>IEventHandler&lt;T&gt;</code>动态映射事件源和事件处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 提供入口支持注册其它程序集中实现的IEventHandler</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;assembly&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">public void RegisterAllEventHandlerFromAssembly(Assembly assembly)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;1.将IEventHandler注册到Ioc容器</span><br><span class="line">    IocContainer.Register(Classes.FromAssembly(assembly)</span><br><span class="line">        .BasedOn(typeof(IEventHandler&lt;&gt;))</span><br><span class="line">        .WithService.AllInterfaces()</span><br><span class="line">        .LifestyleSingleton());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2.从IOC容器中获取注册的所有IEventHandler</span><br><span class="line">    var handlers &#x3D; IocContainer.Kernel.GetHandlers(typeof(IEventHandler));</span><br><span class="line">    foreach (var handler in handlers)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;循环遍历所有的IEventHandler&lt;T&gt;</span><br><span class="line">        var interfaces &#x3D; handler.ComponentModel.Implementation.GetInterfaces();</span><br><span class="line">        foreach (var @interface in interfaces)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!typeof(IEventHandler).IsAssignableFrom(@interface))</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;获取泛型参数类型</span><br><span class="line">            var genericArgs &#x3D; @interface.GetGenericArguments();</span><br><span class="line">            if (genericArgs.Length &#x3D;&#x3D; 1)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;注册到事件源与事件处理的映射字典中</span><br><span class="line">                Register(genericArgs[0], handler.ComponentModel.Implementation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式，我们就可以再其他需要使用事件总线的项目中，添加引用后，通过调用以下代码，来完成程序集中<code>IEventHandler&lt;T&gt;</code>的动态绑定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注册当前程序集中实现的所有IEventHandler&lt;T&gt;</span><br><span class="line">EventBus.Default.RegisterAllEventHandlerFromAssembly(Assembly.GetExecutingAssembly());</span><br></pre></td></tr></table></figure>

<h3 id="4-2-4-动态事件触发"><a href="#4-2-4-动态事件触发" class="headerlink" title="4.2.4. 动态事件触发"></a>4.2.4. 动态事件触发</h3><p>触发事件时主要分三步，第一步从事件源与事件处理的字典中取出映射的<code>IEventHandler</code>集合，第二步使用IOC容器解析依赖，第三步调用<code>HandleEvent</code>方法。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 根据事件源触发绑定的事件处理</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TEventData&quot;&gt;&lt;&#x2F;typeparam&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventData&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">public void Trigger&lt;TEventData&gt;(TEventData eventData) where TEventData : IEventData</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取所有映射的EventHandler</span><br><span class="line">    List&lt;Type&gt; handlerTypes &#x3D; _eventAndHandlerMapping[typeof(TEventData)];</span><br><span class="line"></span><br><span class="line">    if (handlerTypes !&#x3D; null &amp;&amp; handlerTypes.Count &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        foreach (var handlerType in handlerTypes)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;从Ioc容器中获取所有的实例</span><br><span class="line">            var handlerInterface &#x3D; handlerType.GetInterface(&quot;IEventHandler&#96;1&quot;);</span><br><span class="line">            var eventHandlers &#x3D; IocContainer.ResolveAll(handlerInterface);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;循环遍历，仅当解析的实例类型与映射字典中事件处理类型一致时，才触发事件</span><br><span class="line">            foreach (var eventHandler in eventHandlers)</span><br><span class="line">            &#123;</span><br><span class="line">                if (eventHandler.GetType() &#x3D;&#x3D; handlerType)</span><br><span class="line">                &#123;</span><br><span class="line">                    var handler &#x3D; eventHandler as IEventHandler&lt;TEventData&gt;;</span><br><span class="line">                    handler.HandleEvent(eventData);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-用例完善"><a href="#5-用例完善" class="headerlink" title="5.用例完善"></a>5.用例完善</h1><p>我们上面使用IOC容器替换了反射，在程序的易用性和性能上都有所提升。但很显然，用例不够完善且存在一些潜在问题，比如：</p>
<ol>
<li>支持Action EventHandler的绑定和触发</li>
<li>异步触发</li>
<li>触发指定的EventHandler</li>
<li>线程安全</li>
<li>等等等</li>
</ol>
<p>下面我们就来先一一完善以上几个问题。</p>
<h2 id="5-1-支持Action事件处理器"><a href="#5-1-支持Action事件处理器" class="headerlink" title="5.1.支持Action事件处理器"></a>5.1.支持Action事件处理器</h2><p>如果每一个事件处理都要定义一个类去实现<code>IEventHandler&lt;T&gt;</code>接口，很显然会造成类急剧膨胀。且在一些简单场景，定义一个类又大才小用。这时我们应该立刻想到Action。<br>使用Action，第一步我们要对其进行封装，提供一个公共的<code>ActionEventHandler</code>来统一处理所有的Action事件处理器。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 支持Action的事件处理器</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TEventData&quot;&gt;&lt;&#x2F;typeparam&gt;</span><br><span class="line">internal class ActionEventHandler&lt;TEventData&gt; : IEventHandler&lt;TEventData&gt; where TEventData : IEventData</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 定义Action的引用，并通过构造函数传参初始化</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    public Action&lt;TEventData&gt; Action &#123; get; private set; &#125;</span><br><span class="line"></span><br><span class="line">    public ActionEventHandler(Action&lt;TEventData&gt; handler)</span><br><span class="line">    &#123;</span><br><span class="line">        Action &#x3D; handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 调用具体的Action来处理事件逻辑</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventData&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">    public void HandleEvent(TEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        Action(eventData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了<code>ActionEventHandler</code>做封装，下一步就是注入IOC容器并注册到事件总线了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 注册Action事件处理器</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TEventData&quot;&gt;&lt;&#x2F;typeparam&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;action&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">public void Register&lt;TEventData&gt;(Action&lt;TEventData&gt; action) where TEventData : IEventData</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;1.构造ActionEventHandler</span><br><span class="line">    var actionHandler &#x3D; new ActionEventHandler&lt;TEventData&gt;(action);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2.将ActionEventHandler的实例注入到Ioc容器</span><br><span class="line">    IocContainer.Register(</span><br><span class="line">        Component.For&lt;IEventHandler&lt;TEventData&gt;&gt;()</span><br><span class="line">        .UsingFactoryMethod(() &#x3D;&gt; actionHandler)</span><br><span class="line">        .LifestyleSingleton());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;3.注册到事件总线</span><br><span class="line">    Register&lt;TEventData&gt;(actionHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用起来就很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注册Action事件处理器</span><br><span class="line">EventBus.Default.Register&lt;EventData&gt;(</span><br><span class="line">    actionEventData &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Trace.TraceInformation(actionEventData.EventTime.ToLongDateString());</span><br><span class="line">    &#125;);</span><br><span class="line">&#x2F;&#x2F;触发</span><br><span class="line">EventBus.Default.Trigger(new EventData());</span><br></pre></td></tr></table></figure>

<h2 id="5-2-支持异步触发"><a href="#5-2-支持异步触发" class="headerlink" title="5.2. 支持异步触发"></a>5.2. 支持异步触发</h2><p>异步触发很简单直接使用<code>Task.Run</code>包装一下就ok了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 异步触发</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TEventData&quot;&gt;&lt;&#x2F;typeparam&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventData&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;</span><br><span class="line">public Task TriggerAsync&lt;TEventData&gt;(TEventData eventData) where TEventData : IEventData</span><br><span class="line">&#123;</span><br><span class="line">    return Task.Run(() &#x3D;&gt; Trigger&lt;TEventData&gt;(eventData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-触发指定EventHandler"><a href="#5-3-触发指定EventHandler" class="headerlink" title="5.3.触发指定EventHandler"></a>5.3.触发指定EventHandler</h2><p>在我们的<code>Trigger</code>方法中我们会将某一个事件源绑定的事件处理全部触发。但在某些场景下，我们可能并不需要全部触发，仅需要触发指定的EventHandler。这个需求很实际，我们来实现一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 触发指定EventHandler</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventHandlerType&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventData&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line"></span><br><span class="line">public void Trigger&lt;TEventData&gt;(Type eventHandlerType, TEventData eventData) </span><br><span class="line">    where TEventData : IEventData</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取类型实现的泛型接口</span><br><span class="line">    var handlerInterface &#x3D; eventHandlerType.GetInterface(&quot;IEventHandler&#96;1&quot;);</span><br><span class="line"></span><br><span class="line">    var eventHandlers &#x3D; IocContainer.ResolveAll(handlerInterface);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;循环遍历，仅当解析的实例类型与映射字典中事件处理类型一致时，才触发事件</span><br><span class="line">    foreach (var eventHandler in eventHandlers)</span><br><span class="line">    &#123;</span><br><span class="line">        if (eventHandler.GetType() &#x3D;&#x3D; eventHandlerType)</span><br><span class="line">        &#123;</span><br><span class="line">            var handler &#x3D; eventHandler as IEventHandler&lt;TEventData&gt;;</span><br><span class="line">            handler?.HandleEvent(eventData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 异步触发指定EventHandler</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventHandlerType&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventData&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;</span><br><span class="line">public Task TriggerAsycn&lt;TEventData&gt;(Type eventHandlerType, TEventData eventData)</span><br><span class="line">    where TEventData : IEventData</span><br><span class="line">&#123;</span><br><span class="line">    return Task.Run(() &#x3D;&gt; Trigger(eventHandlerType, eventData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上个测试用例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> [Fact]</span><br><span class="line">public async void Should_Call_Specified_Handler_Async()</span><br><span class="line">&#123;</span><br><span class="line">    TestEventBus.Register&lt;TestEventData&gt;(new TestEventHandler());</span><br><span class="line"></span><br><span class="line">    var count &#x3D; 0;</span><br><span class="line">    TestEventBus.Register&lt;TestEventData&gt;(</span><br><span class="line">        actionEventData &#x3D;&gt; &#123; count++; &#125;</span><br><span class="line">    );</span><br><span class="line">    await TestEventBus.TriggerAsycn&lt;TestEventData&gt;</span><br><span class="line">        (typeof(TestEventHandler), new TestEventData(999));</span><br><span class="line"></span><br><span class="line">    TestEventHandler.TestValue.ShouldBe(999);</span><br><span class="line">    count.ShouldBe(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-线程安全问题"><a href="#5-4-线程安全问题" class="headerlink" title="5.4.线程安全问题"></a>5.4.线程安全问题</h2><p>在事件总线中，维护的事件源和事件处理的映射字典是整个程序中的重中之重。我们选择了使用<code>ConcurrentDictionary</code>线程安全字典来规避线程安全问题。但实际我们真正做到线程安全了吗？我们看下映射字典申明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 定义线程安全集合</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">private readonly ConcurrentDictionary&lt;Type, List&lt;Type&gt;&gt; _eventAndHandlerMapping;</span><br></pre></td></tr></table></figure>
<p>聪慧如你，我们的事件源支持绑定多个事件处理，<code>ConcurrentDictionary</code>确保了对key值（事件源）修改的线程安全，但无法确保事件处理的列表<code>List&lt;Type&gt;</code>的线程安全。那我们就来动手改造吧。同样代码很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 定义锁对象</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">private static object lockObj&#x3D; new object();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 获取事件总线映射字典中指定事件源的事件列表</span><br><span class="line">&#x2F;&#x2F;&#x2F; 若有，返回列表</span><br><span class="line">&#x2F;&#x2F;&#x2F; 若无，构造空列表返回</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventType&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;</span><br><span class="line">private List&lt;Type&gt; GetOrCreateHandlers(Type eventType)</span><br><span class="line">&#123;</span><br><span class="line">    return _eventAndHandlerMapping.GetOrAdd(eventType, (type) &#x3D;&gt; new List&lt;Type&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void Register(Type eventType, Type handlerType)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他代码</span><br><span class="line">    &#x2F;&#x2F;注册到事件总线</span><br><span class="line">    lock (lockObj)</span><br><span class="line">    &#123;</span><br><span class="line">        GetOrCreateHandlers(eventType).Add(handlerType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public void UnRegister&lt;TEventData&gt;(Type handlerType)</span><br><span class="line">&#123;</span><br><span class="line">    lock (lockObj)</span><br><span class="line">    &#123;</span><br><span class="line">        GetOrCreateHandlers(typeof(TEventData)).RemoveAll(t &#x3D;&gt; t &#x3D;&#x3D; handlerType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-单元测试"><a href="#6-单元测试" class="headerlink" title="6.单元测试"></a>6.单元测试</h1><p>为了确保重构的正确性和业务的完整性，以上的改进都是基于单元测试进行改进的，使用的是Xunit+Shouldly。虽然不能保证单元测试的覆盖度，但至少确保了正常业务的流转。</p>
<p><img src="/images/how-much-you-know-about-the-eventbus-2/2799767-37bc5bdd93f0445c.png" alt="UnitTest"></p>
<h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h1><p>这一次，通过单元测试，一步一步的推进事件总线的重构和完善。主要完成了使用IOC替换反射来解耦和一些用例的完善。源码已上传至Github（<a href="https://github.com/yanshengjie/EventBus" target="_blank" rel="noopener">源码路径：Github-EventBus</a>）。<br><img src="/images/how-much-you-know-about-the-eventbus-2/2799767-4106f2960f6ff8aa.png" alt=""><br>至此，事件总线进入Beta版本。但很显然还有许多细节有待完善，比如异常处理等，后续就不再继续这个系列，我会直接维护Github的源码，感兴趣的可自行参阅。<a href="https://github.com/yanshengjie/EventBus" target="_blank" rel="noopener">源码路径：Github-EventBus</a></p>
<hr>
<blockquote>
<p>参考资料：<br><a href="https://github.com/aspnetboilerplate/aspnetboilerplate/tree/dev/src/Abp/Events/Bus" target="_blank" rel="noopener">ABP EventBus</a><br><a href="http://www.cnblogs.com/lwhkdash/archive/2012/09/28/2707549.html" target="_blank" rel="noopener">[c#] 反射真的很可怕吗？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>发布订阅模式</tag>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title>IdentityServer4 知多少</title>
    <url>/post/how-much-you-know-about-the-identityserver4/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a><img src="/images/how-much-you-know-about-the-identityserver4/2799767-c17b64e06a2d4f71-1588585455631.png" alt=""></h1><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>现在的应用开发层出不穷，基于浏览器的网页应用，基于微信的公众号、小程序，基于IOS、Android的App，基于Windows系统的桌面应用和UWP应用等等，这么多种类的应用，就给应用的开发带来的挑战，我们除了分别实现各个应用外，我们还要考虑各个应用之间的交互，通用模块的提炼，其中身份的认证和授权就是每个应用必不可少的的一部分。而现在的互联网，对于信息安全要求又十分苛刻，所以一套统一的身份认证和授权就至关重要。</p>
<p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-edb5904a988bb3a6.png" alt="IdentityServer 4"></p>
<blockquote>
<p>IdentityServer4就是这样一个框架，IdentityServer4是为ASP.NET CORE量身定制的实现了OpenId Connect和OAuth2.0协议的认证授权中间件。</p>
</blockquote>
<p>下面我们就来介绍一下相关概念，并梳理下如何集成IdentityServer4。<br>也可浏览自行整理的<strong><a href="http://naotu.baidu.com/file/75b251257ce27cfa62e0ad7f47b75576?token=e2db617be22b6274" target="_blank" rel="noopener">IdentityServer4 百度脑图</a></strong>快速了解。</p>
<h1 id="2-OAuth2-0-amp-amp-OpenId-Connect"><a href="#2-OAuth2-0-amp-amp-OpenId-Connect" class="headerlink" title="2.OAuth2.0 &amp;&amp; OpenId Connect"></a>2.OAuth2.0 &amp;&amp; OpenId Connect</h1><p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-4cd2e40d9b5d84b5.png" alt=""></p>
<h2 id="2-1-OpenId"><a href="#2-1-OpenId" class="headerlink" title="2.1. OpenId"></a>2.1. OpenId</h2><blockquote>
<p>OpenID 是一个<strong>以用户为中心的数字身份识别框架</strong>，它具有开放、分散性。OpenID 的创建基于这样一个概念：我们可以通过 URI （又叫 URL 或网站地址）来认证一个网站的唯一身份，同理，我们也可以通过这种方式来作为用户的身份认证。</p>
</blockquote>
<p>简而言之：<strong>OpenId用于身份认证（Authentication）</strong>。</p>
<h2 id="2-2-OAuth-2-0"><a href="#2-2-OAuth-2-0" class="headerlink" title="2.2. OAuth 2.0"></a>2.2. OAuth 2.0</h2><blockquote>
<p>OAuth（<strong>开放授权</strong>）是一个开放标准，目前的版本是2.0。允许用户授权第三方移动应用访问他们存储在其他服务商上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。<br>OAuth允许用户提供一个<strong>令牌</strong>而不是用户名和密码来访问他们存放在特定服务商上的数据。每一个令牌授权一个特定的网站内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth可以允许用户授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。<br>OAuth是OpenID的一个补充，但是完全不同的服务。</p>
</blockquote>
<p>简而言之：<strong>OAuth2.0 用于授权（Authorization）</strong>。<br>关于OAuth2.0也可参考我的另一篇博文<a href="https://www.cnblogs.com/sheng-jie/p/6564520.html" target="_blank" rel="noopener">OAuth2.0 知多少</a>。</p>
<h2 id="2-3-OpenId-Connect"><a href="#2-3-OpenId-Connect" class="headerlink" title="2.3. OpenId Connect"></a>2.3. OpenId Connect</h2><blockquote>
<p>OpenID Connect 1.0 是基于OAuth 2.0协议之上的简单身份层，它允许客户端根据授权服务器的认证结果最终确认终端用户的身份，以及获取基本的用户信息；它支持包括Web、移动、JavaScript在内的所有客户端类型去请求和接收终端用户信息和身份认证会话信息；它是可扩展的协议，允许你使用某些可选功能，如身份数据加密、OpenID提供商发现、会话管理等。</p>
</blockquote>
<p>简而言之：<strong>OpenId Connect = OIDC = Authentication + Authorization + OAuth2.0</strong>。</p>
<p>比如，Facebook、Google、QQ、微博都是比较知名的OpenId  Connect提供商。</p>
<h1 id="3-术语解释"><a href="#3-术语解释" class="headerlink" title="3. 术语解释"></a>3. 术语解释</h1><p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-00eec4bc3482dd66.png" alt=""></p>
<p>了解完OpenId Connect和OAuth2.0的基本概念，我们再来梳理下涉及到的相关术语：</p>
<ol>
<li>User：用户</li>
<li>Client：客户端</li>
<li>Resources：Identity Data（身份数据）、Apis</li>
<li>Identity Server：认证授权服务器</li>
<li>Token：Access Token（访问令牌）和 Identity Token（身份令牌）</li>
</ol>
<p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-3f778baddaf58043.png" alt=""></p>
<h1 id="4-JwtBearer-认证"><a href="#4-JwtBearer-认证" class="headerlink" title="4. JwtBearer 认证"></a>4. JwtBearer 认证</h1><h2 id="4-1-HTTP身份验证流程"><a href="#4-1-HTTP身份验证流程" class="headerlink" title="4.1. HTTP身份验证流程"></a>4.1. HTTP身份验证流程</h2><blockquote>
<p>HTTP提供了一套标准的身份验证框架：服务器可以用来针对客户端的请求发送质询(challenge)，客户端根据质询提供身份验证凭证。质询与应答的工作流程如下：服务器端向客户端返回401（Unauthorized，未授权）状态码，并在WWW-Authenticate头中添加如何进行验证的信息，其中至少包含有一种质询方式。然后客户端可以在请求中添加Authorization头进行验证，其Value为身份验证的凭证信息。</p>
</blockquote>
<p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-6d9e1014fd3bca72.png" alt="HTTP身份验证流程"></p>
<p>Bearer认证（也叫做令牌认证）是一种HTTP认证方案，其中包含的安全令牌的叫做Bearer Token。因此Bearer认证的核心是Token。那如何确保Token的安全是重中之重。一种方式是使用Https，另一种方式就是对Token进行加密签名。而JWT就是一种比较流行的Token编码方式。</p>
<h2 id="4-2-JWT（Json-Web-Token"><a href="#4-2-JWT（Json-Web-Token" class="headerlink" title="4.2. JWT（Json Web Token)"></a>4.2. JWT（Json Web Token)</h2><blockquote>
<p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（<a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">RFC 7519</a>）。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p>
</blockquote>
<p>JWT有三部分组成：</p>
<blockquote>
<header>.<payload>.<signature>
</blockquote>
<ol>
<li>Header：由<code>alg</code>和<code>typ</code>组成，<code>alg</code>是algorithm的缩写，<code>typ</code>是type的缩写，指定token的类型。该部分使用<code>Base64Url</code>编码。</li>
<li>Payload：主要用来存储信息，包含各种声明，同样该部分也由<code>BaseURL</code>编码。</li>
<li>Signature：签名，使用服务器端的密钥进行签名。以确保Token未被篡改。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>

<h1 id="5-授权模式"><a href="#5-授权模式" class="headerlink" title="5. 授权模式"></a>5. 授权模式</h1><p>OAuth2.0 定义了四种授权模式：</p>
<ol>
<li>Implicit：简化模式；直接通过浏览器的链接跳转申请令牌。</li>
<li>Client Credentials：客户端凭证模式；该方法通常用于服务器之间的通讯；该模式仅发生在Client与Identity Server之间。</li>
<li>Resource Owner Password Credentials：密码模式</li>
<li>Authorization Code：授权码模式； </li>
</ol>
<h2 id="5-1-Client-Credentials"><a href="#5-1-Client-Credentials" class="headerlink" title="5.1. Client Credentials"></a>5.1. Client Credentials</h2><p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-b8f1275cda8b204d.png" alt="客户端凭证模式"></p>
<p>客户端凭证模式，是最简单的授权模式，因为授权的流程仅发生在Client与Identity Server之间。</p>
<p>该模式的适用场景为服务器与服务器之间的通信。比如对于一个电子商务网站，将订单和物流系统分拆为两个服务分别部署。订单系统需要访问物流系统进行物流信息的跟踪，物流系统需要访问订单系统的快递单号信息进行物流信息的定时刷新。而这两个系统之间服务的授权就可以通过这种模式来实现。</p>
<h2 id="5-2-Resource-Owner-Password-Credentials"><a href="#5-2-Resource-Owner-Password-Credentials" class="headerlink" title="5.2. Resource Owner Password Credentials"></a>5.2. Resource Owner Password Credentials</h2><p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-934f091397d7234b.png" alt="密码模式"></p>
<p>Resource Owner其实就是User，所以可以直译为用户名密码模式。密码模式相较于客户端凭证模式，多了一个参与者，就是User。通过User的用户名和密码向Identity Server申请访问令牌。这种模式下要求客户端不得储存密码。但我们并不能确保客户端是否储存了密码，所以该模式仅适用于受信任的客户端。否则会发生密码泄露的危险。<strong>该模式不推荐使用</strong>。</p>
<h2 id="5-3-Authorization-Code"><a href="#5-3-Authorization-Code" class="headerlink" title="5.3. Authorization Code"></a>5.3. Authorization Code</h2><p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-15e218058b896231.png" alt="image.png"></p>
<p>授权码模式是一种混合模式，是目前功能最完整、流程最严密的授权模式。它主要分为两大步骤：认证和授权。<br>其流程为：</p>
<ol>
<li>用户访问客户端，客户端将用户导向Identity Server。</li>
<li>用户填写凭证信息向客户端授权，认证服务器根据客户端指定的重定向URI，并返回一个【Authorization Code】给客户端。</li>
<li>客户端根据【Authorization Code】向Identity Server申请【Access Token】</li>
</ol>
<h2 id="5-4-Implicit"><a href="#5-4-Implicit" class="headerlink" title="5.4. Implicit"></a>5.4. Implicit</h2><p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-890a555d2a3922d3.png" alt="简化模式"></p>
<p>简化模式是相对于授权码模式而言的。其不再需要【Client】的参与，所有的认证和授权都是通过浏览器来完成的。</p>
<h1 id="6-IdentityServer4-集成"><a href="#6-IdentityServer4-集成" class="headerlink" title="6. IdentityServer4 集成"></a>6. IdentityServer4 集成</h1><p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-6708925e096c8510.png" alt="如何集成Identity Server"></p>
<p>通过以上知识点的梳理，我们对OpenId Connect 和OAuth2.0的一些相关概念有了大致认识。而IdentityServer4是为ASP.NET CORE量身定制的实现了OpenId Connect和OAuth2.0协议的认证授权中间件。<br>所以自然而然我们对IdentityServer4有了基础的认识。下面就来介绍如何集成IdentityServer4。其主要分为三步：</p>
<ol>
<li>IdentityServer如何配置和启用IdentityServer中间件</li>
<li>Resources如何配置和启用认证授权中间件</li>
<li>Client如何认证和授权</li>
</ol>
<h2 id="6-1-Identity-Server-中间件的配置和启用"><a href="#6-1-Identity-Server-中间件的配置和启用" class="headerlink" title="6.1. Identity Server 中间件的配置和启用"></a>6.1. Identity Server 中间件的配置和启用</h2><p>作为一个独立的Identity Server，它必须知道哪些资源需要保护，必须知道哪些客户端能够允许访问，这是配置的基础。<br>所以IdentityServer中间件的配置的核心就是：</p>
<ol>
<li>配置受保护的资源列表</li>
<li>配置允许验证的Client</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Startup</span><br><span class="line">&#123;</span><br><span class="line">    public void ConfigureServices(IServiceCollection services)</span><br><span class="line">    &#123;</span><br><span class="line">        services.AddMvc();</span><br><span class="line">        &#x2F;&#x2F; configure identity server with in-memory stores, keys, clients and scopes</span><br><span class="line">        services.AddIdentityServer()</span><br><span class="line">            .AddDeveloperSigningCredential()</span><br><span class="line">             &#x2F;&#x2F;配置身份资源</span><br><span class="line">            .AddInMemoryIdentityResources(Config.GetIdentityResources())</span><br><span class="line">              &#x2F;&#x2F;配置API资源</span><br><span class="line">            .AddInMemoryApiResources(Config.GetApiResources())</span><br><span class="line">             &#x2F;&#x2F;预置允许验证的Client</span><br><span class="line">            .AddInMemoryClients(Config.GetClients())</span><br><span class="line">            .AddTestUsers(Config.GetUsers());</span><br><span class="line">        services.AddAuthentication()</span><br><span class="line">              &#x2F;&#x2F;添加Google第三方身份认证服务（按需添加）</span><br><span class="line">            .AddGoogle(&quot;Google&quot;, options &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                options.SignInScheme &#x3D; IdentityServerConstants.ExternalCookieAuthenticationScheme;</span><br><span class="line">                options.ClientId &#x3D; &quot;434483408261-55tc8n0cs4ff1fe21ea8df2o443v2iuc.apps.googleusercontent.com&quot;;</span><br><span class="line">                options.ClientSecret &#x3D; &quot;3gcoTrEDPPJ0ukn_aYYT6PWo&quot;;</span><br><span class="line">            &#125;)</span><br><span class="line">            &#x2F;&#x2F;如果当前IdentityServer不提供身份认证服务，还可以添加其他身份认证服                务提供商</span><br><span class="line">            .AddOpenIdConnect(&quot;oidc&quot;, &quot;OpenID Connect&quot;, options &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                options.SignInScheme &#x3D; IdentityServerConstants.ExternalCookieAuthenticationScheme;</span><br><span class="line">                options.SignOutScheme &#x3D; IdentityServerConstants.SignoutScheme;</span><br><span class="line">                options.Authority &#x3D; &quot;https:&#x2F;&#x2F;demo.identityserver.io&#x2F;&quot;;</span><br><span class="line">                options.ClientId &#x3D; &quot;implicit&quot;;</span><br><span class="line">                options.TokenValidationParameters &#x3D; new TokenValidationParameters</span><br><span class="line">                &#123;</span><br><span class="line">                    NameClaimType &#x3D; &quot;name&quot;,</span><br><span class="line">                    RoleClaimType &#x3D; &quot;role&quot;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void Configure(IApplicationBuilder app, IHostingEnvironment env)</span><br><span class="line">    &#123;</span><br><span class="line">        if (env.IsDevelopment())</span><br><span class="line">        &#123;</span><br><span class="line">            app.UseDeveloperExceptionPage();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;添加IdentityServer中间件到Pipeline</span><br><span class="line">        app.UseIdentityServer();</span><br><span class="line">        app.UseStaticFiles();</span><br><span class="line">        app.UseMvcWithDefaultRoute();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>配置完，添加IdentityServer到Pipeline即可。</p>
<p>如果要支持第三方登录服务或自己实现的OpenId Connect服务，则需要额外配置下身份认证中间件。</p>
<h2 id="6-2-Resources的保护配置"><a href="#6-2-Resources的保护配置" class="headerlink" title="6.2. Resources的保护配置"></a>6.2. Resources的保护配置</h2><p>配置完Identity Server，接下来我们该思考如何来保护Resources，以及如何将所有的认证和授权请求导流到Identity Server呢？<br>在此之前，我们还是要梳理下Client访问Resources的请求顺序：</p>
<ol>
<li>Client请求资源，资源如果需要进行身份认证和授权，则将请求导流到Identity Server。</li>
<li>Identity Server根据Client配置的授权类型，返回【Token】。</li>
<li>Client携带【Token】请求资源。</li>
<li>受保护的资源服务器要能够验证【Token】的正确性。</li>
</ol>
<p>所以针对要保护的资源，我们需要以下配置：</p>
<ol>
<li>指定资源是否需要保护；</li>
<li>指定IdentityServer用来进行认证和授权跳转；</li>
<li>指定Token验证；</li>
</ol>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用[Authorize]特性，来显式指定受保护的资源</span><br><span class="line">[Route(&quot;[controller]&quot;)]</span><br><span class="line">[Authorize]</span><br><span class="line">public class IdentityController : ControllerBase</span><br><span class="line">&#123;</span><br><span class="line">    [HttpGet]</span><br><span class="line">    public IActionResult Get()</span><br><span class="line">    &#123;</span><br><span class="line">        return new JsonResult(from c in User.Claims select new &#123; c.Type, c.Value &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Startup</span><br><span class="line">&#123;</span><br><span class="line">    public void ConfigureServices(IServiceCollection services)</span><br><span class="line">    &#123;</span><br><span class="line">        services.AddMvcCore()</span><br><span class="line">            .AddAuthorization()</span><br><span class="line">            .AddJsonFormatters();</span><br><span class="line">        &#x2F;&#x2F;指定认证方案</span><br><span class="line">        services.AddAuthentication(&quot;Bearer&quot;)</span><br><span class="line">              &#x2F;&#x2F;添加Token验证服务到DI</span><br><span class="line">            .AddIdentityServerAuthentication(options &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;指定授权地址</span><br><span class="line">                options.Authority &#x3D; &quot;http:&#x2F;&#x2F;localhost:5000&quot;;</span><br><span class="line">                options.RequireHttpsMetadata &#x3D; false;</span><br><span class="line">                options.ApiName &#x3D; &quot;api1&quot;;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void Configure(IApplicationBuilder app)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;添加认证中间件到Pipeline</span><br><span class="line">        app.UseAuthentication();</span><br><span class="line">        app.UseMvc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-Client的请求配置"><a href="#6-3-Client的请求配置" class="headerlink" title="6.3. Client的请求配置"></a>6.3. Client的请求配置</h2><p>资源和认证服务器都配置完毕，接下来客户端就可以直接访问了。<br>如果针对控制台客户端应用，三步走就可以访问Api：</p>
<ol>
<li>使用DiscoverClient发现Token Endpoint</li>
<li>使用TokenClient请求Access Token</li>
<li>使用HttpClient访问Api<br>代码示例如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; discover endpoints from metadata</span><br><span class="line">var disco &#x3D; await DiscoveryClient.GetAsync(&quot;http:&#x2F;&#x2F;localhost:5000&quot;);</span><br><span class="line">&#x2F;&#x2F; request token（使用的是ClientCredentials授权类型）</span><br><span class="line">var tokenClient &#x3D; new TokenClient(disco.TokenEndpoint, &quot;client&quot;, &quot;secret&quot;);</span><br><span class="line">var tokenResponse &#x3D; await tokenClient.RequestClientCredentialsAsync(&quot;api1&quot;)</span><br><span class="line">if (tokenResponse.IsError)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(tokenResponse.Error);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(tokenResponse.Json);</span><br><span class="line">Console.WriteLine(&quot;\n\n&quot;);</span><br><span class="line">&#x2F;&#x2F; call api</span><br><span class="line">var client &#x3D; new HttpClient();</span><br><span class="line">client.SetBearerToken(tokenResponse.AccessToken);</span><br></pre></td></tr></table></figure>

<p>如果针对ASP.NET Web控制台客户端，我们先来回答一个问题：</p>
<ol>
<li>如果Web应用是否需要登录？</li>
<li>如果需要登录，就需要进行身份认证。</li>
<li>身份认证成功后，也就需要会话状态的维持。</li>
</ol>
<p>回答完上面的问题，我们也就梳理出了配置要点：</p>
<ol>
<li>添加身份认证中间件</li>
<li>启用Cookie进行会话保持</li>
<li>添加OIDC，使用我们自己定义的IdentityServer提供的认证服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void ConfigureServices(IServiceCollection services)</span><br><span class="line">&#123;</span><br><span class="line">    services.AddMvc();</span><br><span class="line">    JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();</span><br><span class="line">    services.AddAuthentication(options &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            options.DefaultScheme &#x3D; &quot;Cookies&quot;;</span><br><span class="line">            options.DefaultChallengeScheme &#x3D; &quot;oidc&quot;;</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddCookie(&quot;Cookies&quot;)</span><br><span class="line">        .AddOpenIdConnect(&quot;oidc&quot;, options &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            options.SignInScheme &#x3D; &quot;Cookies&quot;;</span><br><span class="line">            options.Authority &#x3D; &quot;http:&#x2F;&#x2F;localhost:5000&quot;;</span><br><span class="line">            options.RequireHttpsMetadata &#x3D; false;</span><br><span class="line">            options.ClientId &#x3D; &quot;mvc&quot;;</span><br><span class="line">            options.SaveTokens &#x3D; true;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">public void Configure(IApplicationBuilder app, IHostingEnvironment env</span><br><span class="line">&#123;</span><br><span class="line">    if (env.IsDevelopment())</span><br><span class="line">    &#123;</span><br><span class="line">        app.UseDeveloperExceptionPage();</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        app.UseExceptionHandler(&quot;&#x2F;Home&#x2F;Error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    app.UseAuthentication();</span><br><span class="line">    app.UseStaticFiles();</span><br><span class="line">    app.UseMvcWithDefaultRoute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-最后"><a href="#7-最后" class="headerlink" title="7. 最后"></a>7. 最后</h1><p>本文通过介绍IdentityServer4涉及到的术语和相关概念，再结合官方实例，梳理了集成IdentityServer4的大致思路。而关于如何与ASP.NET Identity、EF Core集成，本文并未涉及，详参官方文档。</p>
<blockquote>
<p><a href="http://docs.identityserver.io/en/release/index.html" target="_blank" rel="noopener">Identity Server 官方文档</a><br><a href="https://www.cnblogs.com/stulzq/p/8119928.html" target="_blank" rel="noopener">dentityServer4 中文文档与实战</a></p>
<p><a href="https://www.cnblogs.com/RainingNight/p/jwtbearer-authentication-in-asp-net-core.html" target="_blank" rel="noopener">JwtBearer认证</a></p>
<p><a href="https://swagger.io/docs/specification/authentication/bearer-authentication/" target="_blank" rel="noopener">Bearer Authentication</a><br><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">JSON Web Token</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">理解OAuth 2.0</a><br><a href="http://docs.identityserver.io/en/release/topics/grant_types.html" target="_blank" rel="noopener">Identity Server 授权类型</a></p>
</blockquote>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>id4</tag>
        <tag>OAuth2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>IO模型知多少 | 代码篇</title>
    <url>/post/how-much-you-know-about-the-io-model-demo/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>之前的一篇介绍IO 模型的文章比较偏理论，很多同学反应不是很好理解。这一篇咱们换一个角度，从代码角度来分析一下。</p>
<h1 id="socket-编程基础"><a href="#socket-编程基础" class="headerlink" title="socket 编程基础"></a>socket 编程基础</h1><p>开始之前，我们先来梳理一下，需要提前了解的几个概念：</p>
<blockquote>
<p>socket: 直译为“插座”，在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。我们把插头插到插座上就能从电网获得电力供应，同样，应用程序为了与远程计算机进行数据传输，需要连接到因特网，而 socket 就是用来连接到因特网的工具。</p>
</blockquote>
<p>另外还需要知道的是，socket 编程的基本流程。<br><img src="/images/how-much-you-know-about-the-io-model-demo/2799767-5f95e14aac563bce.png" alt="Socket 编程流程"></p>
<h1 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h1><p>先回顾下概念：阻塞IO是指，应用进程中线程在发起IO调用后至内核执行IO操作返回结果之前，若发起系统调用的线程一直处于等待状态，则此次IO操作为阻塞IO。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void Start()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;1. 创建Tcp Socket对象</span><br><span class="line">    var serverSocket &#x3D; new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">    var ipEndpoint &#x3D; new IPEndPoint(IPAddress.Loopback, 5001);</span><br><span class="line">    &#x2F;&#x2F;2. 绑定Ip端口</span><br><span class="line">    serverSocket.Bind(ipEndpoint);</span><br><span class="line">    &#x2F;&#x2F;3. 开启监听，指定最大连接数</span><br><span class="line">    serverSocket.Listen(10);</span><br><span class="line">    Console.WriteLine($&quot;服务端已启动(&#123;ipEndpoint&#125;)-等待连接...&quot;);</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;4. 等待客户端连接</span><br><span class="line">        var clientSocket &#x3D; serverSocket.Accept();&#x2F;&#x2F;阻塞</span><br><span class="line">        Console.WriteLine($&quot;&#123;clientSocket.RemoteEndPoint&#125;-已连接&quot;);</span><br><span class="line">        Span&lt;byte&gt; buffer &#x3D; new Span&lt;byte&gt;(new byte[512]);</span><br><span class="line">        Console.WriteLine($&quot;&#123;clientSocket.RemoteEndPoint&#125;-开始接收数据...&quot;);</span><br><span class="line">        int readLength &#x3D; clientSocket.Receive(buffer);&#x2F;&#x2F;阻塞</span><br><span class="line">        var msg &#x3D; Encoding.UTF8.GetString(buffer.ToArray(), 0, readLength);</span><br><span class="line">        Console.WriteLine($&quot;&#123;clientSocket.RemoteEndPoint&#125;-接收数据：&#123;msg&#125;&quot;);</span><br><span class="line">        var sendBuffer &#x3D; Encoding.UTF8.GetBytes($&quot;received:&#123;msg&#125;&quot;);</span><br><span class="line">        clientSocket.Send(sendBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/how-much-you-know-about-the-io-model-demo/2799767-c4034c0af2e3b32f.gif" alt=""></p>
<p>代码很简单，直接看注释就OK了，运行结果如上图所示，但有几个问题点需要着重说明下：</p>
<ol>
<li>等待连接处<code>serverSocket.Accept()</code>，线程阻塞！</li>
<li>接收数据处<code>clientSocket.Receive(buffer)</code>，线程阻塞！</li>
</ol>
<p>会导致什么问题呢：</p>
<ol>
<li>只有一次数据读取完成后，才可以接受下一个连接请求</li>
<li>一个连接，只能接收一次数据</li>
</ol>
<h1 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h1><p>看完，你可能会说，这两个问题很好解决啊，创建一个新线程去接收数据就是了。于是就有了下面的代码改进。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void Start2()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;1. 创建Tcp Socket对象</span><br><span class="line">    var serverSocket &#x3D; new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">    var ipEndpoint &#x3D; new IPEndPoint(IPAddress.Loopback, 5001);</span><br><span class="line">    &#x2F;&#x2F;2. 绑定Ip端口</span><br><span class="line">    serverSocket.Bind(ipEndpoint);</span><br><span class="line">    &#x2F;&#x2F;3. 开启监听，指定最大连接数</span><br><span class="line">    serverSocket.Listen(10);</span><br><span class="line">    Console.WriteLine($&quot;服务端已启动(&#123;ipEndpoint&#125;)-等待连接...&quot;);</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;4. 等待客户端连接</span><br><span class="line">        var clientSocket &#x3D; serverSocket.Accept();&#x2F;&#x2F;阻塞</span><br><span class="line">        Task.Run(() &#x3D;&gt; ReceiveData(clientSocket));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void ReceiveData(Socket clientSocket)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($&quot;&#123;clientSocket.RemoteEndPoint&#125;-已连接&quot;);</span><br><span class="line">    Span&lt;byte&gt; buffer &#x3D; new Span&lt;byte&gt;(new byte[512]);</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        if (clientSocket.Available &#x3D;&#x3D; 0) continue;</span><br><span class="line">        Console.WriteLine($&quot;&#123;clientSocket.RemoteEndPoint&#125;-开始接收数据...&quot;);</span><br><span class="line">        int readLength &#x3D; clientSocket.Receive(buffer);&#x2F;&#x2F;阻塞</span><br><span class="line">        var msg &#x3D; Encoding.UTF8.GetString(buffer.ToArray(), 0, readLength);</span><br><span class="line">        Console.WriteLine($&quot;&#123;clientSocket.RemoteEndPoint&#125;-接收数据：&#123;msg&#125;&quot;);</span><br><span class="line">        var sendBuffer &#x3D; Encoding.UTF8.GetBytes($&quot;received:&#123;msg&#125;&quot;);</span><br><span class="line">        clientSocket.Send(sendBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/how-much-you-know-about-the-io-model-demo/2799767-12046ce197b2f2b3.gif" alt="多线程"></p>
<p>是的，多线程解决了上述的问题，但如果你观察以上动图后，你应该能发现个问题：<strong>才建立4个客户端连接，CPU的占用率就开始直线上升了。</strong></p>
<p>而这个问题的本质就是，服务端的IO模型为阻塞IO模型，为了解决阻塞导致的问题，采用重复轮询，导致无效的系统调用，从而导致CPU持续走高。</p>
<h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><p>既然知道原因所在，咱们就来予以改造。适用异步方式来处理连接、接收和发送数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class NioServer</span><br><span class="line">&#123;</span><br><span class="line">    private static ManualResetEvent _acceptEvent &#x3D; new ManualResetEvent(true);</span><br><span class="line">    private static ManualResetEvent _readEvent &#x3D; new ManualResetEvent(true);</span><br><span class="line">    public static void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;1. 创建Tcp Socket对象</span><br><span class="line">        var serverSocket &#x3D; new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">        &#x2F;&#x2F; serverSocket.Blocking &#x3D; false;&#x2F;&#x2F;设置为非阻塞</span><br><span class="line">        var ipEndpoint &#x3D; new IPEndPoint(IPAddress.Loopback, 5001);</span><br><span class="line">        &#x2F;&#x2F;2. 绑定Ip端口</span><br><span class="line">        serverSocket.Bind(ipEndpoint);</span><br><span class="line">        &#x2F;&#x2F;3. 开启监听，指定最大连接数</span><br><span class="line">        serverSocket.Listen(10);</span><br><span class="line">        Console.WriteLine($&quot;服务端已启动(&#123;ipEndpoint&#125;)-等待连接...&quot;);</span><br><span class="line"></span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            _acceptEvent.Reset();&#x2F;&#x2F;重置信号量</span><br><span class="line">            serverSocket.BeginAccept(OnClientConnected, serverSocket);</span><br><span class="line">            _acceptEvent.WaitOne();&#x2F;&#x2F;阻塞</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void OnClientConnected(IAsyncResult ar)</span><br><span class="line">    &#123;</span><br><span class="line">        _acceptEvent.Set();&#x2F;&#x2F;当有客户端连接进来后，则释放信号量</span><br><span class="line">        var serverSocket &#x3D; ar.AsyncState as Socket;</span><br><span class="line">        Debug.Assert(serverSocket !&#x3D; null, nameof(serverSocket) + &quot; !&#x3D; null&quot;);</span><br><span class="line"></span><br><span class="line">        var clientSocket &#x3D; serverSocket.EndAccept(ar);</span><br><span class="line">        Console.WriteLine($&quot;&#123;clientSocket.RemoteEndPoint&#125;-已连接&quot;);</span><br><span class="line">        </span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            _readEvent.Reset();&#x2F;&#x2F;重置信号量</span><br><span class="line">            var stateObj &#x3D; new StateObject &#123; ClientSocket &#x3D; clientSocket &#125;;</span><br><span class="line">            clientSocket.BeginReceive(stateObj.Buffer, 0, stateObj.Buffer.Length, SocketFlags.None, OnMessageReceived, stateObj);</span><br><span class="line">            _readEvent.WaitOne();&#x2F;&#x2F;阻塞等待</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void OnMessageReceived(IAsyncResult ar)</span><br><span class="line">    &#123;</span><br><span class="line">        var state &#x3D; ar.AsyncState as StateObject;</span><br><span class="line">        Debug.Assert(state !&#x3D; null, nameof(state) + &quot; !&#x3D; null&quot;);</span><br><span class="line">        var receiveLength &#x3D; state.ClientSocket.EndReceive(ar);</span><br><span class="line"></span><br><span class="line">        if (receiveLength &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            var msg &#x3D; Encoding.UTF8.GetString(state.Buffer, 0, receiveLength);</span><br><span class="line">            Console.WriteLine($&quot;&#123;state.ClientSocket.RemoteEndPoint&#125;-接收数据：&#123;msg&#125;&quot;);</span><br><span class="line"></span><br><span class="line">            var sendBuffer &#x3D; Encoding.UTF8.GetBytes($&quot;received:&#123;msg&#125;&quot;);</span><br><span class="line">            state.ClientSocket.BeginSend(sendBuffer, 0, sendBuffer.Length, SocketFlags.None,</span><br><span class="line">                SendMessage, state.ClientSocket);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void SendMessage(IAsyncResult ar)</span><br><span class="line">    &#123;</span><br><span class="line">        var clientSocket &#x3D; ar.AsyncState as Socket;</span><br><span class="line">        Debug.Assert(clientSocket !&#x3D; null, nameof(clientSocket) + &quot; !&#x3D; null&quot;);</span><br><span class="line">        clientSocket.EndSend(ar);</span><br><span class="line">        _readEvent.Set(); &#x2F;&#x2F;发送完毕后，释放信号量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class StateObject</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Client  socket.  </span><br><span class="line">    public Socket ClientSocket &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; Size of receive buffer.  </span><br><span class="line">    public const int BufferSize &#x3D; 1024;</span><br><span class="line">    &#x2F;&#x2F; Receive buffer.  </span><br><span class="line">    public byte[] Buffer &#x3D; new byte[BufferSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先来看运行结果，从下图可以看到，除了建立连接时CPU出现抖动外，在消息接收和发送阶段，CPU占有率趋于平缓，且占用率低。</p>
<p><img src="/images/how-much-you-know-about-the-io-model-demo/2799767-bf36d3ea3c3ec980.gif" alt=""></p>
<p>分析代码后我们发现：</p>
<ol>
<li>CPU使用率是下来了，但代码复杂度上升了。</li>
<li>使用异步接口处理客户端连接：<code>BeginAccept</code>和<code>EndAccept</code></li>
<li>使用异步接口接收数据：<code>BeginReceive</code>和<code>EndReceive</code></li>
<li>使用异步接口发送数据：<code>BeginSend</code>和<code>EndSend</code></li>
<li>使用<code>ManualResetEvent</code>进行线程同步，避免线程空转</li>
</ol>
<p>那你可能好奇，以上模型是何种IO多路复用模型呢？<br>好问题，我们来一探究竟。</p>
<h1 id="验证I-O模型"><a href="#验证I-O模型" class="headerlink" title="验证I/O模型"></a>验证I/O模型</h1><p>要想验证应用使用的何种IO模型，只需要确定应用运行时发起了哪些系统调用即可。对于Linux系统来说，我们可以借助<code>strace</code>命令来跟踪指定应用发起的系统调用和信号。</p>
<h2 id="验证同步阻塞I-O发起的系统调用"><a href="#验证同步阻塞I-O发起的系统调用" class="headerlink" title="验证同步阻塞I/O发起的系统调用"></a>验证同步阻塞I/O发起的系统调用</h2><p>可以使用VSCode Remote 连接到自己的Linux系统上，然后新建项目<code>Io.Demo</code>，以上面非阻塞IO的代码进行测试，执行以下启动跟踪命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet$ ls</span><br><span class="line">Io.Demo</span><br><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet$ strace -ff -o Io.Demo&#x2F;strace&#x2F;io dotnet run --project Io.Demo&#x2F;</span><br><span class="line">Press any key to start!</span><br><span class="line">服务端已启动(127.0.0.1:5001)-等待连接...</span><br><span class="line">127.0.0.1:36876-已连接</span><br><span class="line">127.0.0.1:36876-开始接收数据...</span><br><span class="line">127.0.0.1:36876-接收数据：1</span><br></pre></td></tr></table></figure>

<p>另起命令行，执行’nc localhost 5001`模拟客户端连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ nc localhost 5001</span><br><span class="line">1</span><br><span class="line">received:1</span><br></pre></td></tr></table></figure>

<p>使用<code>netstat</code>命令查看建立的连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:&#x2F;proc&#x2F;3763$ netstat -natp | grep 5001</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 127.0.0.1:5001          0.0.0.0:*               LISTEN      3763&#x2F;Io.Demo        </span><br><span class="line">tcp        0      0 127.0.0.1:36920         127.0.0.1:5001          ESTABLISHED 3798&#x2F;nc             </span><br><span class="line">tcp        0      0 127.0.0.1:5001          127.0.0.1:36920         ESTABLISHED 3763&#x2F;Io.Demo </span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>

<p>另起命令行，执行<code>ps -h | grep dotnet</code>  抓取进程Id。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ ps -h | grep dotnet</span><br><span class="line"> 3694 pts&#x2F;1    S+     0:11 strace -ff -o Io.Demo&#x2F;strace&#x2F;io dotnet run --project Io.Demo&#x2F;</span><br><span class="line"> 3696 pts&#x2F;1    Sl+    0:01 dotnet run --project Io.Demo&#x2F;</span><br><span class="line"> 3763 pts&#x2F;1    Sl+    0:00 &#x2F;home&#x2F;shengjie&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;bin&#x2F;Debug&#x2F;netcoreapp3.0&#x2F;Io.Demo</span><br><span class="line"> 3779 pts&#x2F;2    S+     0:00 grep --color&#x3D;auto dotnet</span><br><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet$ ls Io.Demo&#x2F;strace&#x2F; # 查看生成的系统调用文件</span><br><span class="line">io.3696  io.3702  io.3708  io.3714  io.3720  io.3726  io.3732  io.3738  io.3744  io.3750  io.3766  io.3772  io.3782  io.3827</span><br><span class="line">io.3697  io.3703  io.3709  io.3715  io.3721  io.3727  io.3733  io.3739  io.3745  io.3751  io.3767  io.3773  io.3786  io.3828</span><br><span class="line">io.3698  io.3704  io.3710  io.3716  io.3722  io.3728  io.3734  io.3740  io.3746  io.3752  io.3768  io.3774  io.3787</span><br><span class="line">io.3699  io.3705  io.3711  io.3717  io.3723  io.3729  io.3735  io.3741  io.3747  io.3763  io.3769  io.3777  io.3797</span><br><span class="line">io.3700  io.3706  io.3712  io.3718  io.3724  io.3730  io.3736  io.3742  io.3748  io.3764  io.3770  io.3780  io.3799</span><br><span class="line">io.3701  io.3707  io.3713  io.3719  io.3725  io.3731  io.3737  io.3743  io.3749  io.3765  io.3771  io.3781  io.3800</span><br></pre></td></tr></table></figure>
<p>有上可知，进程Id为3763，依次执行以下命令可以查看该进程的线程和产生的文件描述符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ cd &#x2F;proc&#x2F;3763 # 进入进程目录</span><br><span class="line">shengjie@ubuntu:&#x2F;proc&#x2F;3763$ ls</span><br><span class="line">attr        cmdline          environ  io         mem         ns             pagemap      sched      smaps_rollup  syscall        wchan</span><br><span class="line">autogroup   comm             exe      limits     mountinfo   numa_maps      patch_state  schedstat  stack         task</span><br><span class="line">auxv        coredump_filter  fd       loginuid   mounts      oom_adj        personality  sessionid  stat          timers</span><br><span class="line">cgroup      cpuset           fdinfo   map_files  mountstats  oom_score      projid_map   setgroups  statm         timerslack_ns</span><br><span class="line">clear_refs  cwd              gid_map  maps       net         oom_score_adj  root         smaps      status        uid_map</span><br><span class="line">shengjie@ubuntu:&#x2F;proc&#x2F;3763$ ll task # 查看当前进程启动的线程</span><br><span class="line">total 0</span><br><span class="line">dr-xr-xr-x 9 shengjie shengjie 0 5月  10 16:36 .&#x2F;</span><br><span class="line">dr-xr-xr-x 9 shengjie shengjie 0 5月  10 16:34 ..&#x2F;</span><br><span class="line">dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3763&#x2F;</span><br><span class="line">dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3765&#x2F;</span><br><span class="line">dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3766&#x2F;</span><br><span class="line">dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3767&#x2F;</span><br><span class="line">dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3768&#x2F;</span><br><span class="line">dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3769&#x2F;</span><br><span class="line">dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3770&#x2F;</span><br><span class="line">shengjie@ubuntu:&#x2F;proc&#x2F;3763$ ll fd 查看当前进程系统调用产生的文件描述符</span><br><span class="line">total 0</span><br><span class="line">dr-x------ 2 shengjie shengjie  0 5月  10 16:36 .&#x2F;</span><br><span class="line">dr-xr-xr-x 9 shengjie shengjie  0 5月  10 16:34 ..&#x2F;</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 0 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 1 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 10 -&gt; &#39;socket:[44292]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 100 -&gt; &#x2F;dev&#x2F;random</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 11 -&gt; &#39;socket:[41675]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 13 -&gt; &#39;pipe:[45206]&#39;</span><br><span class="line">l-wx------ 1 shengjie shengjie 64 5月  10 16:37 14 -&gt; &#39;pipe:[45206]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 15 -&gt; &#x2F;home&#x2F;shengjie&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;bin&#x2F;Debug&#x2F;netcoreapp3.0&#x2F;Io.Demo.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 16 -&gt; &#x2F;home&#x2F;shengjie&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;bin&#x2F;Debug&#x2F;netcoreapp3.0&#x2F;Io.Demo.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 17 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Runtime.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 18 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Console.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 19 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Threading.dll</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 2 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 20 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Runtime.Extensions.dll</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 21 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 22 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Text.Encoding.Extensions.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 23 -&gt; &#x2F;dev&#x2F;urandom</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 24 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Net.Sockets.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 25 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Net.Primitives.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 26 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;Microsoft.Win32.Primitives.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 27 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Diagnostics.Tracing.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 28 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Threading.Tasks.dll</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 29 -&gt; &#39;socket:[43429]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 3 -&gt; &#39;pipe:[42148]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 30 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Threading.ThreadPool.dll</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 31 -&gt; &#39;socket:[42149]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 32 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Memory.dll</span><br><span class="line">l-wx------ 1 shengjie shengjie 64 5月  10 16:37 4 -&gt; &#39;pipe:[42148]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 42 -&gt; &#x2F;dev&#x2F;urandom</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 5 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 6 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 7 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 9 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Private.CoreLib.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 99 -&gt; &#x2F;dev&#x2F;urandom</span><br></pre></td></tr></table></figure>
<p>从上面的输出来看，.NET Core控制台应用启动时启动了多个线程，并在10、11、29、31号文件描述符启动了socket监听。那哪一个文件描述符监听的是5001端口呢。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ cat &#x2F;proc&#x2F;net&#x2F;tcp | grep 1389 # 查看5001端口号相关的tcp链接（0x1389 为5001十六进制)</span><br><span class="line">   4: 0100007F:1389 00000000:0000 0A 00000000:00000000 00:00000000 00000000  1000        0 43429 1 0000000000000000 100 0 0 10 0                     </span><br><span class="line">  12: 0100007F:9038 0100007F:1389 01 00000000:00000000 00:00000000 00000000  1000        0 44343 1 0000000000000000 20 4 30 10 -1                    </span><br><span class="line">  13: 0100007F:1389 0100007F:9038 01 00000000:00000000 00:00000000 00000000  1000        0 42149 1 0000000000000000 20 4 29 10 -1</span><br></pre></td></tr></table></figure>
<p>从中可以看到inode为[43429]的socket监听在5001端口号，所以可以找到上面的输出行<code>lrwx------ 1 shengjie shengjie 64 5月  10 16:37 29 -&gt; &#39;socket:[43429]&#39;</code>，进而判断监听5001端口号socket对应的文件描述符为29。</p>
<p>当然，也可以从记录到<code>strace</code>目录的日志文件找到线索。在文中我们已经提及，socket服务端编程的一般流程，都要经过socket-&gt;bind-&gt;accept-&gt;read-&gt;write流程。所以可以通过抓取关键字，查看相关系统调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ grep &#39;bind&#39; strace&#x2F; -rn</span><br><span class="line">strace&#x2F;io.3696:4570:bind(10, &#123;sa_family&#x3D;AF_UNIX, sun_path&#x3D;&quot;&#x2F;tmp&#x2F;dotnet-diagnostic-3696-327175-socket&quot;&#125;, 110) &#x3D; 0</span><br><span class="line">strace&#x2F;io.3763:2241:bind(11, &#123;sa_family&#x3D;AF_UNIX, sun_path&#x3D;&quot;&#x2F;tmp&#x2F;dotnet-diagnostic-3763-328365-socket&quot;&#125;, 110) &#x3D; 0</span><br><span class="line">strace&#x2F;io.3763:2949:bind(29, &#123;sa_family&#x3D;AF_INET, sin_port&#x3D;htons(5001), sin_addr&#x3D;inet_addr(&quot;127.0.0.1&quot;)&#125;, 16) &#x3D; 0</span><br><span class="line">strace&#x2F;io.3713:4634:bind(11, &#123;sa_family&#x3D;AF_UNIX, sun_path&#x3D;&quot;&#x2F;tmp&#x2F;dotnet-diagnostic-3713-327405-socket&quot;&#125;, 110) &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>从上可知，在主线程也就是<code>io.3763</code>线程的系统调用文件中，将29号文件描述符与监听在<code>127.0.0.1:5001</code>的socket进行了绑定。同时也明白了.NET Core自动建立的另外2个socket是与diagnostic相关。<br>接下来咱们重点看下3763号线程产生的系统调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ cd strace&#x2F;</span><br><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;strace$ cat io.3763 # 仅截取相关片段</span><br><span class="line">socket(AF_INET, SOCK_STREAM|SOCK_CLOEXEC, IPPROTO_TCP) &#x3D; 29</span><br><span class="line">setsockopt(29, SOL_SOCKET, SO_REUSEADDR, [1], 4) &#x3D; 0</span><br><span class="line">bind(29, &#123;sa_family&#x3D;AF_INET, sin_port&#x3D;htons(5001), sin_addr&#x3D;inet_addr(&quot;127.0.0.1&quot;)&#125;, 16) &#x3D; 0</span><br><span class="line">listen(29, 10)       </span><br><span class="line">write(21, &quot;\346\234\215\345\212\241\347\253\257\345\267\262\345\220\257\345\212\250(127.0.0.1:500&quot;..., 51) &#x3D; 51</span><br><span class="line">accept4(29, &#123;sa_family&#x3D;AF_INET, sin_port&#x3D;htons(36920), sin_addr&#x3D;inet_addr(&quot;127.0.0.1&quot;)&#125;, [16], SOCK_CLOEXEC) &#x3D; 31</span><br><span class="line">write(21, &quot;127.0.0.1:36920-\345\267\262\350\277\236\346\216\245\n&quot;, 26) &#x3D; 26</span><br><span class="line">write(21, &quot;127.0.0.1:36920-\345\274\200\345\247\213\346\216\245\346\224\266\346\225\260\346&quot;..., 38) &#x3D; 38</span><br><span class="line">recvmsg(31, &#123;msg_name&#x3D;NULL, msg_namelen&#x3D;0, msg_iov&#x3D;[&#123;iov_base&#x3D;&quot;1\n&quot;, iov_len&#x3D;512&#125;], msg_iovlen&#x3D;1, msg_controllen&#x3D;0, msg_flags&#x3D;0&#125;, 0) &#x3D; 2</span><br><span class="line">write(21, &quot;127.0.0.1:36920-\346\216\245\346\224\266\346\225\260\346\215\256\357\274\2321&quot;..., 34) &#x3D; 34</span><br><span class="line">sendmsg(31, &#123;msg_name&#x3D;NULL, msg_namelen&#x3D;0, msg_iov&#x3D;[&#123;iov_base&#x3D;&quot;received:1\n&quot;, iov_len&#x3D;11&#125;], msg_iovlen&#x3D;1, msg_controllen&#x3D;0, msg_flags&#x3D;0&#125;, 0) &#x3D; 11</span><br><span class="line">accept4(29, 0x7fecf001c978, [16], SOCK_CLOEXEC) &#x3D; ? ERESTARTSYS (To be restarted if SA_RESTART is set)</span><br><span class="line">--- SIGWINCH &#123;si_signo&#x3D;SIGWINCH, si_code&#x3D;SI_KERNEL&#125; ---</span><br></pre></td></tr></table></figure>
<p>从中我们可以发现几个关键的系统调用：</p>
<ol>
<li>socket</li>
<li>bind</li>
<li>listen</li>
<li>accept4</li>
<li>recvmsg</li>
<li>sendmsg<br>通过命令<code>man</code>命令可以查看下<code>accept4</code>和<code>recvmsg</code>系统调用的相关说明：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;strace$ man accept4</span><br><span class="line">If no pending connections are present on the queue, and the socket is not marked as nonblocking, accept() blocks the caller until a</span><br><span class="line">       connection  is  present.</span><br><span class="line"></span><br><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;strace$ man recvmsg</span><br><span class="line">If  no  messages are available at the socket, the receive calls wait for a message to arrive, unless the socket is nonblocking (see fcntl(2))</span><br></pre></td></tr></table></figure>
也就是说<code>accept4</code>和<code>recvmsg</code>是阻塞式系统调用。</li>
</ol>
<h2 id="验证I-O多路复用发起的系统调用"><a href="#验证I-O多路复用发起的系统调用" class="headerlink" title="验证I/O多路复用发起的系统调用"></a>验证I/O多路复用发起的系统调用</h2><p>同样以上面I/O多路复用的代码进行验证，验证步骤类似：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet$ strace -ff -o Io.Demo&#x2F;strace2&#x2F;io dotnet run --project Io.Demo&#x2F;</span><br><span class="line">Press any key to start!</span><br><span class="line">服务端已启动(127.0.0.1:5001)-等待连接...</span><br><span class="line">127.0.0.1:37098-已连接</span><br><span class="line">127.0.0.1:37098-接收数据：1</span><br><span class="line"></span><br><span class="line">127.0.0.1:37098-接收数据：2</span><br><span class="line"></span><br><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ nc localhost 5001</span><br><span class="line">1</span><br><span class="line">received:1</span><br><span class="line">2</span><br><span class="line">received:2</span><br><span class="line"></span><br><span class="line">shengjie@ubuntu:&#x2F;proc&#x2F;2449$ netstat -natp | grep 5001</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 127.0.0.1:5001          0.0.0.0:*               LISTEN      2449&#x2F;Io.Demo        </span><br><span class="line">tcp        0      0 127.0.0.1:5001          127.0.0.1:56296         ESTABLISHED 2449&#x2F;Io.Demo        </span><br><span class="line">tcp        0      0 127.0.0.1:56296         127.0.0.1:5001          ESTABLISHED 2499&#x2F;nc        </span><br><span class="line"></span><br><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ ps -h | grep dotnet</span><br><span class="line"> 2400 pts&#x2F;3    S+     0:10 strace -ff -o .&#x2F;Io.Demo&#x2F;strace2&#x2F;io dotnet run --project Io.Demo&#x2F;</span><br><span class="line"> 2402 pts&#x2F;3    Sl+    0:01 dotnet run --project Io.Demo&#x2F;</span><br><span class="line"> 2449 pts&#x2F;3    Sl+    0:00 &#x2F;home&#x2F;shengjie&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;bin&#x2F;Debug&#x2F;netcoreapp3.0&#x2F;Io.Demo</span><br><span class="line"> 2516 pts&#x2F;5    S+     0:00 grep --color&#x3D;auto dotnet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ cd &#x2F;proc&#x2F;2449&#x2F;</span><br><span class="line">shengjie@ubuntu:&#x2F;proc&#x2F;2449$ ll task</span><br><span class="line">total 0</span><br><span class="line">dr-xr-xr-x 11 shengjie shengjie 0 5月  10 22:15 .&#x2F;</span><br><span class="line">dr-xr-xr-x  9 shengjie shengjie 0 5月  10 22:15 ..&#x2F;</span><br><span class="line">dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2449&#x2F;</span><br><span class="line">dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2451&#x2F;</span><br><span class="line">dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2452&#x2F;</span><br><span class="line">dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2453&#x2F;</span><br><span class="line">dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2454&#x2F;</span><br><span class="line">dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2455&#x2F;</span><br><span class="line">dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2456&#x2F;</span><br><span class="line">dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2459&#x2F;</span><br><span class="line">dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2462&#x2F;</span><br><span class="line">shengjie@ubuntu:&#x2F;proc&#x2F;2449$ ll fd</span><br><span class="line">total 0</span><br><span class="line">dr-x------ 2 shengjie shengjie  0 5月  10 22:15 .&#x2F;</span><br><span class="line">dr-xr-xr-x 9 shengjie shengjie  0 5月  10 22:15 ..&#x2F;</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 0 -&gt; &#x2F;dev&#x2F;pts&#x2F;3</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 1 -&gt; &#x2F;dev&#x2F;pts&#x2F;3</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 10 -&gt; &#39;socket:[35001]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 100 -&gt; &#x2F;dev&#x2F;random</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 11 -&gt; &#39;socket:[34304]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 13 -&gt; &#39;pipe:[31528]&#39;</span><br><span class="line">l-wx------ 1 shengjie shengjie 64 5月  10 22:16 14 -&gt; &#39;pipe:[31528]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 15 -&gt; &#x2F;home&#x2F;shengjie&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;bin&#x2F;Debug&#x2F;netcoreapp3.0&#x2F;Io.Demo.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 16 -&gt; &#x2F;home&#x2F;shengjie&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;bin&#x2F;Debug&#x2F;netcoreapp3.0&#x2F;Io.Demo.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 17 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Runtime.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 18 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Console.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 19 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Threading.dll</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 2 -&gt; &#x2F;dev&#x2F;pts&#x2F;3</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 20 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Runtime.Extensions.dll</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 21 -&gt; &#x2F;dev&#x2F;pts&#x2F;3</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 22 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Text.Encoding.Extensions.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 23 -&gt; &#x2F;dev&#x2F;urandom</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 24 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Net.Sockets.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 25 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Net.Primitives.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 26 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;Microsoft.Win32.Primitives.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 27 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Diagnostics.Tracing.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 28 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Threading.Tasks.dll</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 29 -&gt; &#39;socket:[31529]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 3 -&gt; &#39;pipe:[32055]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 30 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Threading.ThreadPool.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 31 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Collections.Concurrent.dll</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 32 -&gt; &#39;anon_inode:[eventpoll]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 33 -&gt; &#39;pipe:[32059]&#39;</span><br><span class="line">l-wx------ 1 shengjie shengjie 64 5月  10 22:16 34 -&gt; &#39;pipe:[32059]&#39;</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 35 -&gt; &#39;socket:[35017]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 36 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Memory.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 37 -&gt; &#x2F;dev&#x2F;urandom</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 38 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Diagnostics.Debug.dll</span><br><span class="line">l-wx------ 1 shengjie shengjie 64 5月  10 22:16 4 -&gt; &#39;pipe:[32055]&#39;</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 5 -&gt; &#x2F;dev&#x2F;pts&#x2F;3</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 6 -&gt; &#x2F;dev&#x2F;pts&#x2F;3</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 7 -&gt; &#x2F;dev&#x2F;pts&#x2F;3</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 9 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Private.CoreLib.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 99 -&gt; &#x2F;dev&#x2F;urandom</span><br><span class="line">shengjie@ubuntu:&#x2F;proc&#x2F;2449$ cat &#x2F;proc&#x2F;net&#x2F;tcp | grep 1389</span><br><span class="line">   0: 0100007F:1389 00000000:0000 0A 00000000:00000000 00:00000000 00000000  1000        0 31529 1 0000000000000000 100 0 0 10 0                     </span><br><span class="line">   8: 0100007F:1389 0100007F:DBE8 01 00000000:00000000 00:00000000 00000000  1000        0 35017 1 0000000000000000 20 4 29 10 -1                    </span><br><span class="line">  12: 0100007F:DBE8 0100007F:1389 01 00000000:00000000 00:00000000 00000000  1000        0 28496 1 0000000000000000 20 4 30 10 -1</span><br></pre></td></tr></table></figure>
<p>过滤<code>strace2</code> 目录日志，抓取监听在<code>localhost:5001</code>socket对应的文件描述符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ grep &#39;bind&#39; strace2&#x2F; -rn</span><br><span class="line">strace2&#x2F;io.2449:2243:bind(11, &#123;sa_family&#x3D;AF_UNIX, sun_path&#x3D;&quot;&#x2F;tmp&#x2F;dotnet-diagnostic-2449-23147-socket&quot;&#125;, 110) &#x3D; 0</span><br><span class="line">strace2&#x2F;io.2449:2950:bind(29, &#123;sa_family&#x3D;AF_INET, sin_port&#x3D;htons(5001), sin_addr&#x3D;inet_addr(&quot;127.0.0.1&quot;)&#125;, 16) &#x3D; 0</span><br><span class="line">strace2&#x2F;io.2365:4568:bind(10, &#123;sa_family&#x3D;AF_UNIX, sun_path&#x3D;&quot;&#x2F;tmp&#x2F;dotnet-diagnostic-2365-19043-socket&quot;&#125;, 110) &#x3D; 0</span><br><span class="line">strace2&#x2F;io.2420:4634:bind(11, &#123;sa_family&#x3D;AF_UNIX, sun_path&#x3D;&quot;&#x2F;tmp&#x2F;dotnet-diagnostic-2420-22262-socket&quot;&#125;, 110) &#x3D; 0</span><br><span class="line">strace2&#x2F;io.2402:4569:bind(10, &#123;sa_family&#x3D;AF_UNIX, sun_path&#x3D;&quot;&#x2F;tmp&#x2F;dotnet-diagnostic-2402-22042-socket&quot;&#125;, 110) &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>从中可以看出同样是29号文件描述符，相关系统调用记录中<code>io.2449</code>文件中，打开文件，可以发现相关系统调用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ cat strace2&#x2F;io.2449 # 截取相关系统调用</span><br><span class="line">socket(AF_INET, SOCK_STREAM|SOCK_CLOEXEC, IPPROTO_TCP) &#x3D; 29</span><br><span class="line">setsockopt(29, SOL_SOCKET, SO_REUSEADDR, [1], 4) &#x3D; 0</span><br><span class="line">bind(29, &#123;sa_family&#x3D;AF_INET, sin_port&#x3D;htons(5001), sin_addr&#x3D;inet_addr(&quot;127.0.0.1&quot;)&#125;, 16) &#x3D; 0</span><br><span class="line">listen(29, 10) </span><br><span class="line">accept4(29, 0x7fa16c01b9e8, [16], SOCK_CLOEXEC) &#x3D; -1 EAGAIN (Resource temporarily unavailable)</span><br><span class="line">epoll_create1(EPOLL_CLOEXEC)            &#x3D; 32</span><br><span class="line">epoll_ctl(32, EPOLL_CTL_ADD, 29, &#123;EPOLLIN|EPOLLOUT|EPOLLET, &#123;u32&#x3D;0, u64&#x3D;0&#125;&#125;) &#x3D; 0</span><br><span class="line">accept4(29, 0x7fa16c01cd60, [16], SOCK_CLOEXEC) &#x3D; -1 EAGAIN (Resource temporarily unavailable)</span><br></pre></td></tr></table></figure>
<p>从中我们可以发现<code>accept4</code>直接返回-1而不阻塞，监听在<code>127.0.0.1:5001</code>的socket对应的29号文件描述符最终作为<code>epoll_ctl</code>的参数关联到<code>epoll_create1</code>创建的32号文件描述符上。最终32号文件描述符会被<code>epoll_wait</code>阻塞，以等待连接请求。我们可以抓取<code>epoll</code>相关的系统调用来验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ grep &#39;epoll&#39; strace2&#x2F; -rn</span><br><span class="line">strace2&#x2F;io.2459:364:epoll_ctl(32, EPOLL_CTL_ADD, 35, &#123;EPOLLIN|EPOLLOUT|EPOLLET, &#123;u32&#x3D;1, u64&#x3D;1&#125;&#125;) &#x3D; 0</span><br><span class="line">strace2&#x2F;io.2462:21:epoll_wait(32, [&#123;EPOLLIN, &#123;u32&#x3D;0, u64&#x3D;0&#125;&#125;], 1024, -1) &#x3D; 1</span><br><span class="line">strace2&#x2F;io.2462:42:epoll_wait(32, [&#123;EPOLLOUT, &#123;u32&#x3D;1, u64&#x3D;1&#125;&#125;], 1024, -1) &#x3D; 1</span><br><span class="line">strace2&#x2F;io.2462:43:epoll_wait(32, [&#123;EPOLLIN|EPOLLOUT, &#123;u32&#x3D;1, u64&#x3D;1&#125;&#125;], 1024, -1) &#x3D; 1</span><br><span class="line">strace2&#x2F;io.2462:53:epoll_wait(32, </span><br><span class="line">strace2&#x2F;io.2449:3033:epoll_create1(EPOLL_CLOEXEC)            &#x3D; 32</span><br><span class="line">strace2&#x2F;io.2449:3035:epoll_ctl(32, EPOLL_CTL_ADD, 33, &#123;EPOLLIN|EPOLLET, &#123;u32&#x3D;4294967295, u64&#x3D;18446744073709551615&#125;&#125;) &#x3D; 0</span><br><span class="line">strace2&#x2F;io.2449:3061:epoll_ctl(32, EPOLL_CTL_ADD, 29, &#123;EPOLLIN|EPOLLOUT|EPOLLET, &#123;u32&#x3D;0, u64&#x3D;0&#125;&#125;) &#x3D; 0</span><br></pre></td></tr></table></figure>

<p>因此我们可以断定同步非阻塞I/O的示例使用的时IO多路复用的epoll模型。</p>
<p>关于epoll相关命令，man命令可以查看下<code>epoll_create1</code>、<code>epoll_ctl</code>和、<code>epoll_wait</code>系统调用的相关说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;strace$ man epoll_create</span><br><span class="line">DESCRIPTION</span><br><span class="line">       epoll_create() creates a new epoll(7) instance.  Since Linux 2.6.8, the size argument is ignored, but must be</span><br><span class="line">       greater than zero; see NOTES below.</span><br><span class="line"></span><br><span class="line">       epoll_create() returns a file descriptor referring to the new epoll instance.  This file descriptor  is  used</span><br><span class="line">       for  all  the subsequent calls to the epoll interface.</span><br><span class="line"></span><br><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;strace$ man epoll_ctl</span><br><span class="line">DESCRIPTION</span><br><span class="line">       This  system  call  performs  control  operations on the epoll(7) instance referred to by the file descriptor</span><br><span class="line">       epfd.  It requests that the operation op be performed for the target file descriptor, fd.</span><br><span class="line"></span><br><span class="line">       Valid values for the op argument are:</span><br><span class="line"></span><br><span class="line">       EPOLL_CTL_ADD</span><br><span class="line">              Register the target file descriptor fd on the epoll instance referred to by the file  descriptor  epfd</span><br><span class="line">              and associate the event event with the internal file linked to fd.</span><br><span class="line"></span><br><span class="line">       EPOLL_CTL_MOD</span><br><span class="line">              Change the event event associated with the target file descriptor fd.</span><br><span class="line"></span><br><span class="line">       EPOLL_CTL_DEL</span><br><span class="line">              Remove  (deregister)  the  target file descriptor fd from the epoll instance referred to by epfd.  The</span><br><span class="line">              event is ignored and can be NULL (but see BUGS below).</span><br><span class="line"></span><br><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;strace$ man epoll_wait</span><br><span class="line">DESCRIPTION</span><br><span class="line">       The  epoll_wait()  system  call  waits for events on the epoll(7) instance referred to by the file descriptor</span><br><span class="line">       epfd.  The memory area pointed to by events will contain the events that will be available  for  the  caller.</span><br><span class="line">       Up to maxevents are returned by epoll_wait().  The maxevents argument must be greater than zero.</span><br><span class="line"></span><br><span class="line">       The  timeout  argument  specifies  the number of milliseconds that epoll_wait() will block.  Time is measured</span><br><span class="line">       against the CLOCK_MONOTONIC clock.  The call will block until either:</span><br><span class="line"></span><br><span class="line">       *  a file descriptor delivers an event;</span><br><span class="line"></span><br><span class="line">       *  the call is interrupted by a signal handler; or</span><br><span class="line"></span><br><span class="line">       *  the timeout expires.</span><br></pre></td></tr></table></figure>
<p>简而言之，epoll通过创建一个新的文件描述符来替换旧的文件描述符来完成阻塞工作，当有事件或超时时通知原有文件描述符进行处理，以实现非阻塞的线程模型。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>写完这篇文章，对I/O模型的理解有所加深，但由于对Linux系统的了解不深，所以难免有纰漏之处，大家多多指教。<br>同时也不仅感叹Linux的强大之处，一切皆文件的设计思想，让一切都有迹可循。现在.NET 已经完全实现跨平台了，那么Linux操作系统大家就有必要熟悉起来了。</p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>I/O</tag>
        <tag>EPOLL</tag>
      </tags>
  </entry>
  <entry>
    <title>IO模型知多少 | 理论篇</title>
    <url>/post/how-much-you-know-about-the-io-models/</url>
    <content><![CDATA[<p><img src="/images/how-much-you-know-about-the-io-models/2799767-3cd8adef311e9e24-1588340611809.png" alt=""></p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>同步异步I/O，阻塞非阻塞I/O是程序员老生常谈的话题了，也是自己一直以来懵懵懂懂的一个话题。比如：何为同步异步？何为阻塞与非阻塞？二者的区别在哪里？阻塞在何处？为什么会有多种IO模型，分别用来解决问题？常用的框架采用的是何种I/O模型？各种IO模型的优劣势在哪里，适用于何种应用场景？</p>
<p>简而言之，对于I/O的认知，不能仅仅停留在字面上认识，了解内部玄机，才能深刻理解I/O，才能看清I/O相关问题的本质。</p>
<h1 id="2-I-O-的定义"><a href="#2-I-O-的定义" class="headerlink" title="2. I/O 的定义"></a>2. I/O 的定义</h1><p>I/O 的全称是Input/Output。虽常谈及I/O，但想必你也一时不能给出一个完整的定义。搜索了谷歌，发现也尽是些冗长的论述。要想厘清I/O这个概念，我们需要从不同的视角去理解它。</p>
<h2 id="2-1-计算机视角"><a href="#2-1-计算机视角" class="headerlink" title="2.1. 计算机视角"></a>2.1. 计算机视角</h2><p> 冯•诺伊曼计算机的基本思想中有提到计算机硬件组成应为五大部分：控制器，运算器，存储器，输入和输出。其中输入是指将数据输入到计算机的设备，比如键盘鼠标；输出是指从计算机中获取数据的设备，比如显示器；以及既是输入又是输出设备，硬盘，网卡等。</p>
<p>用户通过操作系统才能完成对计算机的操作。计算机启动时，第一个启动的程序是操作系统的内核，它将负责计算机的资源管理和进程的调度。换句话说：操作系统负责从输入设备读取数据并将数据写入到输出设备。</p>
<p>所以I/O之于计算机，有两层意思：</p>
<ol>
<li>I/O设备</li>
<li>对I/O设备的数据读写</li>
</ol>
<p><em>对于一次I/O操作，必然涉及2个参与方，一个输入端，一个输出端，而又根据参与双方的设备类型，我们又可以分为磁盘I/O，网络I/O（一次网络的请求响应，网卡）等。</em></p>
<h2 id="2-2-程序视角"><a href="#2-2-程序视角" class="headerlink" title="2.2. 程序视角"></a>2.2. 程序视角</h2><p>应用程序作为一个文件保存在磁盘中，只有加载到内存到成为一个进程才能运行。应用程序运行在计算机内存中，必然会涉及到数据交换，比如读写磁盘文件，访问数据库，调用远程API等等。但我们编写的程序并不能像操作系统内核一样直接进行I/O操作。</p>
<p>因为为了确保操作系统的安全稳定运行，操作系统启动后，将会开启保护模式：将内存分为内核空间（内核对应进程所在内存空间）和用户空间，进行内存隔离。我们构建的程序将运行在用户空间，用户空间无法操作内核空间，也就意味着用户空间的程序不能直接访问由内核管理的I/O，比如：硬盘、网卡等。</p>
<p>但操作系统向外提供API，其由各种类型的系统调用（System Call）组成，以提供安全的访问控制。<br>所以应用程序要想访问内核管理的I/O，必须通过调用内核提供的系统调用(system call）进行间接访问。</p>
<p>所以I/O之于应用程序来说，强调的通过<strong>向内核发起系统调用完成对I/O的间接访问</strong>。换句话说应用程序发起的一次IO操作实际包含两个阶段：</p>
<ol>
<li>IO调用阶段：应用程序进程向内核发起系统调用</li>
<li>IO执行阶段：内核执行IO操作并返回<br>2.1. 准备数据阶段：内核等待I/O设备准备好数据<br>  2.2. 拷贝数据阶段：将数据从内核缓冲区拷贝到用户空间缓冲区</li>
</ol>
<p>怎么理解准备数据阶段呢？<br>对于写请求：等待系统调用的完整请求数据，并写入内核缓冲区；<br>对于读请求：等待系统调用的完整请求数据；（若请求数据不存在于内核缓冲区）则将外围设备的数据读入到内核缓冲区。</p>
<p> <img src="/images/how-much-you-know-about-the-io-models/2799767-8747395df72a42a1-1588340715108.png" alt="IO操作执行流程"></p>
<p>而应用程序进程在发起IO调用至内核执行IO返回之前，应用程序进程/线程所处状态，就是我们下面要讨论的第二个话题阻塞IO与非阻塞IO。</p>
<h1 id="3-IO-模型之阻塞I-O-BIO"><a href="#3-IO-模型之阻塞I-O-BIO" class="headerlink" title="3. IO 模型之阻塞I/O(BIO)"></a>3. IO 模型之阻塞I/O(BIO)</h1><p>应用程序中进程在发起IO调用后至内核执行IO操作返回结果之前，若发起系统调用的线程一直处于等待状态，则此次IO操作为阻塞IO。阻塞IO简称BIO，Blocking IO。其处理流程如下图所示：</p>
<p><img src="/images/how-much-you-know-about-the-io-models/2799767-69017b641db18e97.png" alt="BIO"></p>
<p>从上图可知当用户进程发起IO系统调用后，内核从准备数据到拷贝数据到用户空间的两个阶段期间<strong>用户调用线程选择阻塞等待</strong>数据返回。</p>
<p>因此BIO带来了一个问题：如果内核数据需要耗时很久才能准备好，那么用户进程将被阻塞，浪费性能。为了提升应用的性能，虽然可以通过多线程来提升性能，但线程的创建依然会借助系统调用，同时多线程会导致频繁的线程上下文的切换，同样会影响性能。所以要想解决BIO带来的问题，我们就得看到问题的本质，那就是<strong>阻塞</strong>二字。</p>
<h1 id="4-IO-模型之非阻塞I-O-NIO"><a href="#4-IO-模型之非阻塞I-O-NIO" class="headerlink" title="4. IO 模型之非阻塞I/O(NIO)"></a>4. IO 模型之非阻塞I/O(NIO)</h1><p>那解决方案自然也容易想到，将阻塞变为非阻塞，那就是用户进程在发起系统调用时指定为非阻塞，内核接收到请求后，就会立即返回，然后用户进程通过轮询的方式来拉取处理结果。也就是如下图所示：</p>
<p><img src="/images/how-much-you-know-about-the-io-models/2799767-bd1dc37ed4733004.png" alt="NIO"></p>
<p>应用程序中进程在发起IO调用后至内核执行IO操作返回结果之前，若发起系统调用的线程不会等待而是立即返回，则此次IO操作为非阻塞IO模型。非阻塞IO简称NIO，Non-Blocking IO。</p>
<p>然而，非阻塞IO虽然相对于阻塞IO大幅提升了性能，但依旧不是完美的解决方案，其依然存在性能问题，也就是频繁的轮询导致频繁的系统调用，会耗费大量的CPU资源。比如当并发很高时，假设有1000个并发，那么单位时间循环内将会有1000次系统调用去轮询执行结果，而实际上可能只有2个请求结果执行完毕，这就会有998次无效的系统调用，造成严重的性能浪费。有问题就要解决，那<strong>NIO问题的本质就是频繁轮询导致的无效系统调用</strong>。</p>
<h1 id="5-IO模型之IO多路复用"><a href="#5-IO模型之IO多路复用" class="headerlink" title="5. IO模型之IO多路复用"></a>5. IO模型之IO多路复用</h1><p>解决NIO的思路就是降解无效的系统调用，如何降解呢？我们一起来看看以下几种IO多路复用的解决思路。</p>
<h2 id="5-1-IO多路复用之select-poll"><a href="#5-1-IO多路复用之select-poll" class="headerlink" title="5.1. IO多路复用之select/poll"></a>5.1. IO多路复用之select/poll</h2><p>Select是内核提供的系统调用，它支持一次查询多个系统调用的可用状态，当任意一个结果状态可用时就会返回，用户进程再发起一次系统调用进行数据读取。换句话说，就是NIO中N次的系统调用，借助Select，只需要发起一次系统调用就够了。其IO流程如下所示：<br><img src="/images/how-much-you-know-about-the-io-models/2799767-48611e945482d71b.png" alt="I/O Multiplexing"></p>
<p>但是，select有一个限制，就是存在连接数限制，针对于此，又提出了poll。其与select相比，主要是解决了连接限制。</p>
<p>select/epoll 虽然解决了NIO重复无效系统调用用的问题，但同时又引入了新的问题。问题是：</p>
<ol>
<li>用户空间和内核空间之间，大量的数据拷贝</li>
<li>内核循环遍历IO状态，浪费CPU时间</li>
</ol>
<p>换句话说，select/poll虽然减少了用户进程的发起的系统调用，但内核的工作量只增不减。在高并发的情况下，内核的性能问题依旧。所以select/poll的问题本质是：内核存在无效的循环遍历。</p>
<h2 id="5-2-IO多路复用之epoll"><a href="#5-2-IO多路复用之epoll" class="headerlink" title="5.2. IO多路复用之epoll"></a>5.2. IO多路复用之epoll</h2><p>针对select/pool引入的问题，我们把解决问题的思路转回到内核上，如何减少内核重复无效的循环遍历呢？变主动为被动，基于事件驱动来实现。其流程图如下所示：</p>
<p><img src="/images/how-much-you-know-about-the-io-models/2799767-7732b124e1fec05b.png" alt="epoll"></p>
<p>epoll相较于select/poll，多了两次系统调用，其中epoll_create建立与内核的连接，epoll_ctl注册事件，epoll_wait阻塞用户进程，等待IO事件。</p>
<p><img src="/images/how-much-you-know-about-the-io-models/2799767-dd1831740358d111.png" alt="select,poll,epoll"></p>
<p>epoll，已经大大优化了IO的执行效率，但在IO执行的第一阶段：数据准备阶段都还是被阻塞的。所以这是一个可以继续优化的点。</p>
<h1 id="6-IO-模型之信号驱动IO-SIGIO"><a href="#6-IO-模型之信号驱动IO-SIGIO" class="headerlink" title="6. IO 模型之信号驱动IO(SIGIO)"></a>6. IO 模型之信号驱动IO(SIGIO)</h1><p>信号驱动IO与BIO和NIO最大的区别就在于，在IO执行的数据准备阶段，不会阻塞用户进程。<br>如下图所示：当用户进程需要等待数据的时候，会向内核发送一个信号，告诉内核我要什么数据，然后用户进程就继续做别的事情去了，而当内核中的数据准备好之后，内核立马发给用户进程一个信号，说”数据准备好了，快来查收“，用户进程收到信号之后，立马调用recvfrom，去查收数据。</p>
<p><img src="/images/how-much-you-know-about-the-io-models/2799767-dcc2492e5d47920b.png" alt="SIGIO"></p>
<p>乍一看，信号驱动式I/O模型有种异步操作的感觉，但是在IO执行的第二阶段，也就是将数据从内核空间复制到用户空间这个阶段，用户进程还是被阻塞的。</p>
<p>综上，你会发现，不管是BIO还是NIO还是SIGIO，它们最终都会被阻塞在IO执行的第二阶段。<br>那如果能将IO执行的第二阶段变成非阻塞，那就完美了。</p>
<h1 id="7-IO-模型之异步IO-AIO"><a href="#7-IO-模型之异步IO-AIO" class="headerlink" title="7. IO 模型之异步IO(AIO)"></a>7. IO 模型之异步IO(AIO)</h1><p>异步IO真正实现了IO全流程的非阻塞。用户进程发出系统调用后立即返回，内核等待数据准备完成，然后将数据拷贝到用户进程缓冲区，然后发送信号告诉用户进程<strong>IO操作执行完毕</strong>（与SIGIO相比，一个是发送信号告诉用户进程数据准备完毕，一个是IO执行完毕）。其流程如下：<br><img src="/images/how-much-you-know-about-the-io-models/2799767-5ad4ff656fac53d5.png" alt="AIO"></p>
<p>所以，之所以称为异步IO，取决于IO执行的第二阶段是否阻塞。因此前面讲的BIO，NIO和SIGIO均为同步IO。</p>
<p><img src="/images/how-much-you-know-about-the-io-models/2799767-b92b0e6f572ce8a5.png" alt=""></p>
<h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><p>梳理完这些IO模型后，之前一直处于懵懂状态的阻塞，非阻塞，同步异步IO，终于算是有个概念了。同时也纠正了自己一直以来的误解，所以一路走来，愈发觉得返璞归真的重要性，只有如此，才能在快速更迭的技术演进中，以不变应万变。</p>
<p><em>本片综合多方资料写就，难免纰漏，但只有写下来，才能得以指正。所以，烦请各位看官不吝赐教。</em></p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://www.jianshu.com/p/fa7bdc4f3de7" target="_blank" rel="noopener">程序员应该这样理解IO</a></li>
<li><a href="https://www.jianshu.com/p/511b9cffbdac" target="_blank" rel="noopener">IO复用模型同步，异步，阻塞，非阻塞及实例详解</a></li>
<li><a href="https://juejin.im/post/5ca4c044e51d4565372e47cf" target="_blank" rel="noopener">服务器网络编程之 IO 模型</a></li>
<li><a href="http://www.c-jump.com/CIS77/CPU/VonNeumann/lecture.html" target="_blank" rel="noopener">http://www.c-jump.com/CIS77/CPU/VonNeumann/lecture.html</a></li>
<li><a href="https://cllc.fun/2019/03/07/synchronous-asynchronous-io/" target="_blank" rel="noopener">同步I/O(阻塞I/O，非阻塞I/O)，异步I/O</a></li>
<li><a href="https://www.bilibili.com/video/BV11K4y1C7rm?p=2" target="_blank" rel="noopener">马士兵：权威讲解nio,epoll,多路复用</a></li>
<li><a href="https://blog.csdn.net/DLUTBruceZhang/article/details/9050467" target="_blank" rel="noopener">Linux 内核详解以及内核缓冲区技术</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>I/O</tag>
        <tag>EPOLL</tag>
      </tags>
  </entry>
  <entry>
    <title>OAtuth2.0 知多少</title>
    <url>/post/how-much-you-know-about-the-oauth2-0/</url>
    <content><![CDATA[<p><img src="/images/how-much-you-know-about-the-oauth2-0/2799767-a43df1862b414722.png" alt=""></p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>周末逛简书，看了一篇写的极好的文章，点击大红心点赞，就直接给我跳转到登录界面了，原来点赞是需要登录的。</p>
<p><img src="/images/how-much-you-know-about-the-oauth2-0/2799767-264c5378f5c255b1.png" alt="简书登录界面"></p>
<p>可是没有我并没有简书账号，一直使用的QQ的集成登录。下面有一排社交登录按钮，我们可以用第三方社交账号登陆即可。点击QQ图标，就给我跳转到了QQ登录授权页面，如下图：</p>
<p><img src="/images/how-much-you-know-about-the-oauth2-0/2799767-54cf4032678fe331.png" alt="QQ登录授权页面"></p>
<p>从图片上我们可以看到主要包括两个部分，一个是左边的用户登录，一个是右边告知简书将获取哪些权限。输入QQ账号和密码，点击授权并登录，就成功登录到简书了，并成功获取到了我QQ的账号和昵称，如下图：</p>
<p><img src="/images/how-much-you-know-about-the-oauth2-0/2799767-bce90f200d70a514.png" alt="简书成功获取到QQ昵称和头像"></p>
<p>简书集成的社交登录，大大简化了我们的注册登录流程，真是一号在手上网无忧啊。<br>这看似简单的集成，但背后的技术原理『OAuth2.0』可没那么简单，那我们废话不多说，一探究竟吧。</p>
<h1 id="2-OAuth-2-0"><a href="#2-OAuth-2-0" class="headerlink" title="2. OAuth 2.0"></a>2. OAuth 2.0</h1><blockquote>
<p><a href="https://oauth.net/2/" target="_blank" rel="noopener">OAuth 2.0</a>是用于授权的行业标准协议。OAuth 2.0取代了在2006年创建的原始OAuth协议上所做的工作。OAuth 2.0专注于客户端开发人员的简单性，同时为Web应用程序，桌面应用程序，手机和客厅设备提供特定的授权流程。</p>
</blockquote>
<p>在传统的client-server认证模型中，客户端请求访问服务器上受限的资源（protected resource），需要通过使用资源所有者（resource owner）的凭证在服务器上进行认证。为了支持第三方应用程序访问受限资源，资源所有者需要向第三方应用共享其凭证。这就会造成以下问题：</p>
<ol>
<li>第三方应用为了后续使用，会存储资源所有者的凭证主要是密码。</li>
<li>服务端需要支持密码认证，尽管密码认证不安全。</li>
<li>第三方应用获得对资源的过度访问而不仅局限于受限资源，且资源所有者没有办法对其进行限制。</li>
<li>资源所有者无法收回权限，除非修改密码。</li>
<li>如果第三方应用的密码被破解，就会导致所有被该密码保护的数据被泄露。</li>
</ol>
<p>想一想这样一个场景，如果简书是直接使用QQ用户名密码登录，简书就很有可能会为了后续业务的需要而擅自保存QQ用户名及密码，简书只要拿到了QQ用户名密码就可以访问不仅仅QQ昵称、头像等信息，甚至可以获取到QQ用户的所有通讯录列表。如果简书的账号密码泄露，就会直接影响到QQ数据的安全。这是一个可怕的问题。</p>
<p>所以OAuth应运而生，来解决这一问题。</p>
<h1 id="3-OAuth-2-0授权流程"><a href="#3-OAuth-2-0授权流程" class="headerlink" title="3. OAuth 2.0授权流程"></a>3. OAuth 2.0授权流程</h1><p>下面我们就以简书使用QQ授权登录为例，来捋一捋OAuth 2.0的流程。<br>先来看看OAuth 2.0的流程，如下图所示：<br><img src="/images/how-much-you-know-about-the-oauth2-0/2799767-27b3e30b6563dc2f.png" alt="OAuth 2.0授权流程"></p>
<p>这里面主要包含四个角色：</p>
<ol>
<li>Client：需要授权的客户端，本文中就是【简书】。</li>
<li>Resource Owner：资源所有者，在本文中你可能会以为是 QQ，但要想清楚，QQ是属于个人的，所以在本文中资源所有者是指【QQ用户】。</li>
<li>Authorization Server：认证服务器，本文中特指【QQ互联平台】。</li>
<li>Resource Server：资源服务器，顾名思义，用来专门保存资源的服务器，接受通过访问令牌进行访问。本文特指【QQ用户信息中心】。</li>
</ol>
<h2 id="3-1-第一步：引导用户到认证服务器"><a href="#3-1-第一步：引导用户到认证服务器" class="headerlink" title="3.1. 第一步：引导用户到认证服务器"></a>3.1. 第一步：引导用户到认证服务器</h2><p>圣杰打开简书网页，简书跳转到登录界面，要求用户登录。可是圣杰未在简书注册帐号，所以就点击了QQ图标，使用QQ帐号进行集成登录。跳转到QQ登录界面后，QQ要求用户授权。<br>这一步中简书主要做了这样一件事就是引导用户到认证服务器。<br>很显然【QQ互联平台】就是认证服务器。</p>
<p>如何引导？当然是页面跳转。<br>那认证服务器如何知道是简书过来的认证请求？<br>当然是传参。<br>那需要传递哪些参数呢？</p>
<ul>
<li>response_type：表示响应类型，必选项，此处的值固定为”code”；</li>
<li>client_id：表示客户端的ID，用来标志授权请求的来源，必选项；</li>
<li>redirect_uri：成功授权后的回调地址；</li>
<li>scope：表示申请的权限范围，可选项；</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>咱们看看简书实际发送的授权请求Url是：<br><code>https://graph.qq.com/oauth2.0/authorize?client_id=100410602
&amp;redirect_uri=http://www.jianshu.com/users/auth/qq_connect/callback
&amp;response_type=code
&amp;state=bb38108d1aaf567c72da0f1167e87142d0e20cb2bb24ec5a</code></p>
<p>无图无真相，咱们看看控制台的网络监控：</p>
<p><img src="/images/how-much-you-know-about-the-oauth2-0/2799767-b7dab004998d702d.png" alt="简书跳转到QQ登录的认证请求"></p>
<p>如图所示，除了scope参数外，其他四个参数均有传参。<br>此时你可能唯一对state参数比较迷惑，传递一个state参数，认证服务器会原封不动返回，那还干嘛要传递state参数呢？</p>
<p>我的理解是，简书用一个guid加长版字符串来唯一标识一个授权请求。这样才会正确获取授权服务器返回的授权码。</p>
<p>这里你可能会问了，既然我知道了这些参数，我岂不是可以伪造简书认证请求，修改<code>redirect_uri</code>参数跳转到个人的网站，然后不就可以获取QQ授权？</p>
<p>跟我一样太傻太天真，简书在QQ互联平台申请时肯定已经预留备案了要跳转返回的URL。QQ互联平台在收到简书的授权请求时肯定会验证回调Url的。</p>
<h2 id="3-2-第二步：用户同意为第三方客户端授权"><a href="#3-2-第二步：用户同意为第三方客户端授权" class="headerlink" title="3.2. 第二步：用户同意为第三方客户端授权"></a>3.2. 第二步：用户同意为第三方客户端授权</h2><p>这一步，对于用户来说，只需要使用资源所有者（QQ）的用户名密码登录，并同意授权即可。点击授权并登录后，授权服务器首先会post一个请求回服务器进行用户认证，认证通过后授权服务器会生成一个授权码，然后服务器根据授权请求的<code>redirect_uri</code>进行跳转，并返回授权码<code>code</code>和授权请求中传递的<code>state</code>。<br>这里要注意的是：<strong>授权码有一个短暂的时效</strong></p>
<p>无图无真相，咱们还是看一下控制台网络监控：</p>
<p><img src="/images/how-much-you-know-about-the-oauth2-0/2799767-2ad0271ee9af4618.png" alt="用户授权并登录"></p>
<p>从图中即可验证我们上面所说，最终跳转回简书的Url为：<br><code>http://www.jianshu.com/users/auth/qq_connect/callback?code=093B9307E38DC5A2C3AD147B150F2AB3
&amp;state=bb38108d1aaf567c72da0f1167e87142d0e20cb2bb24ec5a</code><br>和之前的授权请求URL进行对比，可以发现<code>redirect_uri</code>、<code>state</code>完全一致。<br>而<code>code=093B9307E38DC5A2C3AD147B150F2AB3</code>就是返回的授权码。</p>
<h2 id="3-3-第三步：使用授权码向认证服务器申请令牌"><a href="#3-3-第三步：使用授权码向认证服务器申请令牌" class="headerlink" title="3.3. 第三步：使用授权码向认证服务器申请令牌"></a>3.3. 第三步：使用授权码向认证服务器申请令牌</h2><p>从这一步开始，对于用户来说是察觉不到的。简书后台默默的在做后续的工作。</p>
<p>简书拿到QQ互联平台返回的授权码后，需要根据授权码再次向认证服务器申请令牌（access token）。<br>到这里有必要再理清两个概念：</p>
<ul>
<li>授权码（Authorization Code）：相当于授权服务器口头告诉简书，用户同意授权使用他的QQ登录简书了。</li>
<li>令牌（Access Token）：相当于临时身份证。</li>
</ul>
<p>那如何申请令牌呢？<br>简书需要后台发送一个get请求到认证服务器（QQ互联平台）。<br>那要携带哪些必要信息呢？<br>是的，要携带以下参数：</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为”authorization_code”，必选项；</li>
<li>client_id：表示从QQ互联平台申请到的客户端ID，用来标志请求的来源，必选项；</li>
<li>client_secret：这个是从QQ互联平台申请到的客户端认证密钥，机密信息十分重要，必选项；</li>
<li>redirect_uri：成功申请到令牌后的回调地址；</li>
<li>code：上一步申请到的授权码。</li>
</ul>
<p>根据以上信息我们可以模拟一个申请AccessToken的请求：<br><code>https://graph.qq.com/oauth2.0/token?client_id=100410602
&amp;client_secret=123456jianshu
&amp;redirect_uri=http://www.jianshu.com/users/auth/qq_connect/callback
&amp;grant_type=authorization_code
&amp;code=093B9307E38DC5A2C3AD147B150F2AB3</code></p>
<p>发送完该请求后，认证服务器验证通过后就会发放令牌，并跳转会简书，其中应该包含以下信息：</p>
<ul>
<li>access_token：令牌</li>
<li>expires_in：access token的有效期，单位为秒。</li>
<li>refresh_token：在授权自动续期步骤中，获取新的Access_Token时需要提供的参数。</li>
</ul>
<p>同样，我们可以模拟出一个返回的token：<br><code>http://www.jianshu.com/users/auth/qq_connect/callback?access_token=548ADF2D5E1C5E88H4JH15FKUN51F
&amp;expires_in=36000&amp;refresh_token=53AD68JH834HHJF9J349FJADF3</code></p>
<p>这个时候简书还有一件事情要做，就是把用户token写到cookie里，进行用户登录状态的维持。咱们还是打开控制器验证一下。</p>
<p><img src="/images/how-much-you-know-about-the-oauth2-0/2799767-714ba763cb80cd6e.png" alt="保存token到cookie"></p>
<p>从图中可以看出简书把用户token保存在名为<code>remember_user_token</code>的cookie里。<br>不用打cookie的歪主意了，肯定是加密了的。<br>可以尝试下手动把<code>remember_user_token</code>这条cookie删除，保证刷新界面后需要你重新登录简书。</p>
<h2 id="3-4-第四步：向资源服务器申请资源"><a href="#3-4-第四步：向资源服务器申请资源" class="headerlink" title="3.4. 第四步：向资源服务器申请资源"></a>3.4. 第四步：向资源服务器申请资源</h2><p>有了token，向资源服务器提供的资源接口发送一个get请求不就行了，资源服务器校验令牌无误，就会向简书返回资源（QQ用户信息）。</p>
<p>同样咱们也来模拟一个使用token请求QQ用户基本信息资源的URL：<br><code>https://graph.qq.com/user/get_user_info?client_id=100410602
&amp;qq=2098769873
&amp;access_token=548ADF2D5E1C5E88H4JH15FKUN51F</code></p>
<p>到这一步OAuth2.0的流程可以说是结束了，但是对于简书来说还有重要的事情要做。那就是：<br><strong>拿到token、reresh_token和用户数据这么重要的东西不存数据库傻呀？</strong></p>
<h2 id="3-5-第五步：令牌延期（刷新）"><a href="#3-5-第五步：令牌延期（刷新）" class="headerlink" title="3.5. 第五步：令牌延期（刷新）"></a>3.5. 第五步：令牌延期（刷新）</h2><p>你肯定对第四步返回的<code>refresh_token</code>比较好奇。<br>它是用来对令牌进行延期（刷新）的。为什么会有两种说法呢，因为可能认证服务器会重新生成一个令牌，也有可能<br>对过期的令牌进行延期。</p>
<p>比如说，QQ互联平台为了安全性考虑，返回的<code>access_token</code>是有时间限制的，假如用户某天不想授权了呢，总不能给了个<code>access_token</code>你几年后还能用吧。我们上面模拟返回的令牌有效期为10小时。10小时后，用户打开浏览器逛简书，浏览器中用户的token对应的cookie已过期。简书发现浏览器没有携带token信息过来，就明白token失效了，需要重新向认证平台申请授权。如果让用户再点击QQ进行登录授权，这明显用户体验不好。咋搞呢？<code>refresh_token</code>就派上了用场，可以直接跳过前面申请授权码的步骤，当发现token失效了，简书从浏览器携带的cookie中的sessionid找到存储在数据库中的<code>refresh_token</code>，然后再使用<code>refresh_token</code>进行token续期（刷新）。</p>
<p>那用refresh_token进行token续期需要怎么做呢？<br>同样需要向认证服务器发送一个get请求。<br>需要哪些参数？</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为”refresh_token”，必选项；</li>
<li>client_id：表示从QQ互联平台申请到的客户端ID，用来标志请求的来源，必选项；</li>
<li>client_secret：这个是从QQ互联平台申请到的客户端认证密钥，机密信息十分重要，必选项；</li>
<li>refresh_token：即申请令牌返回的refresh_token。</li>
</ul>
<p>根据上述信息，我们又可以模拟一个令牌刷新的URL：<br><code>https://graph.qq.com/oauth2.0/token?client_id=100410602
&amp;client_secret=123456jianshu
&amp;redirect_uri=http://www.jianshu.com/users/auth/qq_connect/callback
&amp;grant_type=refresh_token
&amp;refresh_token=53AD68JH834HHJF9J349FJADF3</code><br>那返回的结果呢?<br>和第四步返回的结果一样。</p>
<p>这里你可能又有疑问了，那既然每次进行令牌延期后都会重新返回一个<code>refresh_token</code>，那岂不是我可以使用<code>refresh_token</code>无限延期？<br>天真如我啊，<code>refresh_token</code>也是有过期时间的。而这个过期时间具体是由认证服务器决定的。<br>一般来说<code>refresh_token</code>的过期时间要大于<code>access_token</code>的过期时间。只有这样，<code>access_token</code>过期时，才可以使用<code>refresh_token</code>进行令牌延期（刷新）。</p>
<p>举个简单例子：<br>假设简书从QQ互联平台默认获取到的<code>access_token</code>的有效期是1天，<code>refresh_token</code>的有效期为一周。</p>
<p>用户今天使用QQ登录授权后，过了两天再去逛简书，简书发现token失效，立马用<code>refresh_token</code>刷新令牌，默默的完成了授权的延期。<br>假如用户隔了两周再去逛简书，简书一核对，<code>access_token</code>、<code>refresh_token</code>全都失效，就只能乖乖引导用户到授权页面重新授权，也就是回到OAuth2.0的第一步。</p>
<h1 id="4-0-总结"><a href="#4-0-总结" class="headerlink" title="4.0 总结"></a>4.0 总结</h1><p>本文以简书通过QQ进行授权登录为例，对OAuth2.0 的授权流程进行了梳理，希望通读此文，对你有所帮助。</p>
<p>如果对OAuth2.0有所了解的话，你应该明白本文其实是对OAuth2.0中<strong>授权码模式</strong>授权方式的讲解。</p>
<p>如果想了解OAuth2.0其他几种授权方式，建议参考<a href="http://www.baidu.com/link?url=j4_T_fCI4T_gWL2Snyg_xg9DfuYvjKupGPbyr6HnHRJRlpEFAUMPaIEUgszkDxfKUbf_r-dRmYYaFXm13C-BEK" target="_blank" rel="noopener">理解<em>OAuth 2.0</em> - 阮一峰的网络日志</a>。</p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>OAuth2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>Orleans 知多少 | .NET分布式框架</title>
    <url>/post/how-much-you-know-about-the-orleans/</url>
    <content><![CDATA[<p><img src="/images/how-much-you-know-about-the-orleans/2799767-ff59ad0a7485aa58.png" alt=""></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>公司物联网项目集成Orleans以支持高并发的分布式业务，对于Orleans也是第一次接触，本文就分享下个人对Orleans的理解。</p>
<p>这里先抛出自己的观点：<strong>Orleans 是一个支持有状态云生应用/服务水平伸缩的基于Virtual Actor 模型的.NET分布式框架。</strong></p>
<p>下面我会从以下几个关键点，进行阐述：</p>
<ol>
<li>云生应用的挑战</li>
<li>何为有状态/无状态</li>
<li>什么是 Actor 模型</li>
<li>什么是 Virtual Actor 模型</li>
</ol>
<h1 id="云生应用的挑战"><a href="#云生应用的挑战" class="headerlink" title="云生应用的挑战"></a>云生应用的挑战</h1><p>在讲云生应用之前，我们来先讲讲传统应用，对于传统应用常用的三层结构如下图所示。<br><img src="/images/how-much-you-know-about-the-orleans/2799767-48465d42659fe932.png" alt="传统应用三层结构"></p>
<p>随着业务的发展，数据库层通常存在瓶颈，为了缓解数据库的压力，一般会优先考虑增加一层缓存层。</p>
<p><img src="/images/how-much-you-know-about-the-orleans/2799767-4abc2a898285d382.png" alt="增加了缓存层的四层结构"></p>
<p>而随着业务的继续发展，高并发、大数据量的应用场景逐渐凸显。如果继续在单体应用的基础上进行扩展，能做的无非是增加消息队列、异步、读写分离等机制进行性能优化。总体而言，优化空间不大，但应用的整体复杂度却随着引入的新的技术框架而迅速增加，对于应用的维护，是一个潜在的定时炸弹。</p>
<p>这个时候你可能会想，既然单体应用单机部署不能满足需求，我可以做集群啊。通过将单体应用按照分层结构进行纵向分离，将数据库从应用服务器分离，将缓存从应用服务器分离。这样就可以对分离的各个部分进行分别部署，再借助负载均衡完成集群效应。到这一步，你的应用应该能撑一段时间了。</p>
<p>这个时候，如果回到业务本身去分析，对于一个复杂应用来说，通常的性能瓶颈就是几个核心服务上。如果能够对存在性能瓶颈的服务进行伸缩，既能大大提高应用的整体可用性又能提高资源的利用率。那怎么做呢？服务拆分。</p>
<p>云生应用就是服务拆分的结果，云生应用最大的特点就是：</p>
<ul>
<li><strong>并行</strong>：是指同一时刻能够处理多个任务。这无可厚非，云生应用以多个服务形式提供服务，自然是支持并行的。</li>
<li><strong>分布式</strong>：是指一个应用/服务多次部署，以应对高并发，提升应用/服务的整体性能。</li>
</ul>
<p>或者简单来说，云生应用通过服务拆分支持服务并行，同时各个服务能够快速伸缩以提升系统吞吐量来应对高并发的业务场景。</p>
<p>虽然通过服务拆分简化了整个应用的业务复杂度，但是实现的技术复杂度却只增不减。</p>
<h1 id="有状态-Vs-无状态"><a href="#有状态-Vs-无状态" class="headerlink" title="有状态 Vs 无状态"></a>有状态 Vs 无状态</h1><p>转向云生应用我们面对的第一个难题就是：<strong>如何进行服务拆分，才能确保其能分布式部署，或者说是水平伸缩？！</strong></p>
<p>有经验的同学，可能会立马想到，要将应用/服务设计为<strong>无状态</strong>的。但是这里我要向你讨教几个问题：</p>
<ol>
<li>这个状态是指什么？</li>
<li>何为有状态？</li>
<li>何为无状态？</li>
</ol>
<p>大家不妨先停下来思考一下。（欢迎大家在评论中阐述不同观点。）</p>
<p>这里，我尝试从以下两个角度来谈下自己的看法：</p>
<p><strong>1. 对象</strong></p>
<p>面向对象编程强调的是对现实事物的抽象和封装。通过对事物状态和行为进行抽象然后封装为对象（类），其中状态封装为类的属性、字段，将行为封装为类的方法。这个时候得到的对象是没有生命力的，因为它本质是一个抽象的结果。只有在程序运行中对类进行实例化得到一个对象的实例时，才可以说这个实例对象是有状态和行为的，因为这个状态和行为是其<strong>独自持有</strong>的，这是一个非常核心的条件。独自持有，换句话说，就是非共享成员。<br>独自持有非共享的成员就可以说这个对象实例是有状态的吗？<br>这里面你就要看清<strong>状态</strong>和<strong>有状态</strong>的区别！<br>举个简单例子，大街上你看到一大叔开着豪车，你觉得他很富有。“开着豪车”是你即时看到的状态属性。“富有”是你的状态断言。但这个状态断言是一个假设，毕竟可能是借的嘛。<br>怎样才能断定“富有”就是这位大叔拥有的状态呢？很简单，假设一年365天你天天见到他开豪车，那基本八九不离十了。</p>
<p><strong>所以，如果认定一个对象是否有状态，还要看其状态属性是否持久化！</strong></p>
<p>如果你同意这个观点，那么哪天你看我骑个共享单车，气喘吁吁从你面前经过，就不要简单认为我是苦逼工薪族。毕竟我也是身价上千万，只是偶尔骑个车锻炼锻炼。（身价上千万，昨晚梦到的。）</p>
<blockquote>
<p>所以，从对象角度看，一个对象是否有状态的充分必要条件是：</p>
<ol>
<li>对象已实例化（处于运行时）</li>
<li>拥有非共享的状态属性</li>
<li>状态持久化</li>
</ol>
</blockquote>
<p>那问题来了，我们经常写的类创建的实例，是有状态的吗？</p>
<p><strong>2. 应用</strong></p>
<p>基于上面的总结，我们再来从应用的角度来看分析这个问题。</p>
<p>那应用的状态和行为是什么？<br>首先，只有运行中的应用才有状态和行为。基于这个前提，个人理解运行时应用的状态是应用持有的数据，行为是应用提供的功能。<strong>那应用的有无/无状态界定就要看运行时应用持有的数据能否持久化。</strong></p>
<p>以简单的Web分层应用举例 。从逻辑架构上来讲应用一般分为三层，表示层、业务层和数据访问层。上层进行状态行为的封装，数据层提供数据的持久化。所以从整体的角度来看，其是一个有状态的应用。但单独来看，我们不能对每一层进行有/无状态的界定。第一，每一层不能单独运行；第二，分层的目的是为了职责的隔离，每一层负责相应职责的抽象和封装，其输出的是类文件，是对象的集合，没有生命力。</p>
<p>那从物理架构上来讲，Web应用可以分开两个部分进行部署：Web实例和MySQL实例。也就是说应用和数据库是可以分开部署的。这个时候Web实例就是无状态的。那我们一般常说的无状态服务其实是就是从这个拆分的角度来说的。</p>
<h1 id="Actor-模型"><a href="#Actor-模型" class="headerlink" title="Actor 模型"></a>Actor 模型</h1><p>理清完服务拆分的核心问题后，我们不得不来处理第二个棘手的问题：<strong>如何解决云生应用高并发的应用场景呢？</strong><br>那首先我们需要明确处理高并发的难点在哪？第一个是高性能，第二个就是：资源竞争导致的数据一致性问题。对于第一个难点，通过水平扩展服务可以化解；对于第二个难点，一般就是采用锁机制，而对于云生分布式的应用场景下，处理手段就更加复杂，可能需要使用分布式锁，而这种做法，大大降低了应用的整体响应性能。那有没有更好的解决方案，既兼顾性能又可以确保数据一致性呢？</p>
<p>有，借助Actor模型。</p>
<p>简单来讲：<strong>Actor模型 = 状态 + 行为 + 消息</strong>。一个应用/服务由多个Actor组成，每个Actor都是一个独立的运行单元，拥有隔离的运行空间，在隔离的空间内，其有独立的状态和行为，不被外界干预，Actor之间通过消息进行交互，而同一时刻，每个Actor只能被单个线程执行，这样既有效避免了数据共享和并发问题，又确保了应用的伸缩性。</p>
<p>另外Actor基于事件驱动模型进行异步通信，性能良好。且位置透明，无论Actor是在本机亦或是在集群中的其他机器，都可以直接进行透明调用。</p>
<p>因此Actor模型赋予了应用/服务的生命力（有状态）、高并发的处理能力和弹性伸缩能力。</p>
<p><img src="/images/how-much-you-know-about-the-orleans/2799767-001b915c61c84cb0.png" alt="Actor模型"></p>
<h1 id="Virtual-Actor-模型-与-Orleans"><a href="#Virtual-Actor-模型-与-Orleans" class="headerlink" title="Virtual Actor 模型 与 Orleans"></a>Virtual Actor 模型 与 Orleans</h1><p>对于Actor模型，业界已经有系列的实现框架，比如Erlang、Akka。然而Actor模型作为一个偏底层的技术框架，对于开发者来说，需要有一定分布式应用的开发经验，才能用好Actor（包括Actor的生命周期管理，状态管理等等）。为了进一步简化分布式编程，微软的研究人员引入了 Virtual Actor 模型概念，简单来讲Virtual Actor模型是对Actor模型的进一步封装和抽象。<br>其与Actor模型的最大的区别在于，Actor的物理实例完全被抽象出来，并由Virtual Actor所在的运行时自动管理。</p>
<p>Orleans 就是作为一款面向.NET的Virtual Actor模型的实现框架，提供了开发者友好的编程方式，简化了分布式应用的开发成本。<strong>在Orleans中Virtual Actor由Grain来体现。</strong></p>
<p>Orleans中核心优势：开发效率高、透明可伸缩。</p>
<p>开发效率高具体表现为：</p>
<ol>
<li>面向对象的编程范式去实现Grain</li>
<li>Grain单线程执行</li>
<li>Grain透明实例化：换句话说，应用无需关注Actor实例的创建、销毁，可以直接调用Actor提供的方法。Actor的生命周期由Virtual Actor 运行时进行管理，类似GC，可以把Actor理解为完全托管的状态。</li>
<li>Grain位置透明：Actor之间通过持有彼此的逻辑引用（非实例引用）进行相互调用，而不需要知道Actor所处的实际位置。</li>
<li>Grain状态透明存储</li>
<li>异常的自动传播</li>
</ol>
<p>透明可伸缩体现为：</p>
<ol>
<li>应用状态的隐式细粒度划分</li>
<li>自适应的资源管理：Grain的生命周期完全由Orleans 运行时托管。</li>
<li>多路通信：Grain的位置透明，Grain之间通过一组固定的TCP链接进行多路复用来进行消息传递。</li>
<li>高效调度</li>
<li>显式异步</li>
</ol>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这篇文章，就简单写到这里，对于Orleans的详细介绍后续会结合实际项目输出更系统的应用细节，下次再见。</p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>Orleans</tag>
        <tag>Distributed .NET</tag>
        <tag>Actor Model</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化知多少</title>
    <url>/post/how-much-you-know-about-the-performance-optimization/</url>
    <content><![CDATA[<p><img src="/images/how-much-you-know-about-the-performance-optimization/2799767-9372ac4442777015.png" alt=""></p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>最近一段时间，系统新版本要发布，在beta客户测试期间，暴露了很多问题，除了一些业务和异常问题外，其他都集中在性能上。有幸接触到这些性能调优的机会，当然要学习总结了。</p>
<p>性能优化是一个老生常谈的问题了，典型的性能问题如页面响应慢、接口超时，服务器负载高、并发数低，数据库频繁死锁等。而造成性能问题又有很多种，比如磁盘I/O、内存、网络、算法、大数据量等等。我们可以大致把性能问题分为四个层次：代码层次、数据库层次、算法层次、架构层次。<br>所以下面我会结合实际性能优化案例，和大家分享下性能调优的工具、方法和技巧。</p>
<h1 id="2-先说心态"><a href="#2-先说心态" class="headerlink" title="2. 先说心态"></a>2. 先说心态</h1><p>说到性能问题，你可能首先就想到的是麻烦或者头大，因为一般性能问题都比较紧急，轻则影响客户体验，重则宕机导致财务损失，而且性能问题比较隐蔽，不易发现。因此一时间无从下手，而这时我们就很容易从心底开始去排斥它，不愿接这烫手的山芋。</p>
<p>而恰巧，性能调优是体现程序员水平的一个重要指标。</p>
<blockquote>
<p>因为处理bug、崩溃、调优、入侵等突发事件比编程本身更能体现平庸程序员与理想程序员的差距。当面对一个未知的问题时，如何定位复杂条件下的核心问题、如何抽丝剥茧地分析问题的潜在原因、如何排除干扰还原一个最小的可验证场景、如何抓住关键数据验证自己的猜测与实验，都是体现程序员思考力的最好场景。是的，在衡量理想程序员的标准上，思考力比经验更加重要。</p>
</blockquote>
<p>所以，若你不甘平庸，请拥抱性能调优的每一个机会。当你拥有一个正确的心态，你所面对的性能问题就已经解决了一半。</p>
<h1 id="3-再说技巧"><a href="#3-再说技巧" class="headerlink" title="3. 再说技巧"></a>3. 再说技巧</h1><p>拿到一个性能问题，不要忙着先上工具，先了解问题出现的背景，问题的严重程度。然后大致根据自己的经验积累作出预估。比如客户来了个性能问题说系统宕机了，已经造成资金损失了。这种涉及到钱的问题，大家都比较敏感，根据自己的level，决定是否要接这个锅。这不是逃避，而是自知之明。</p>
<p>了解问题背景之后，下一步就来尝试问题重现。如果在测试环境能够重现，那这种问题就很好跟踪分析。如果问题不能稳定重现或仅能在生产环境重现，那问题就相对比较棘手，这时要立刻收集现场证据，包括但不限于抓dump、收集应用程序以及系统日志、关注CPU内存情况、数据库备份等等，之后不妨再尝试重现，比如恢复客户数据库到测试环境重现。</p>
<p>不管问题能否重现，下一步，我们就要大致对问题进行分类，是代码层次的业务逻辑问题还是数据库层次的操作耗时问题，又或是系统架构的吞吐量问题。那如何确定呢？而我倾向于先从数据库动手。我的习惯做法是，使用数据库监控工具，先跟踪下Sql耗时情况。如果监控到耗时较长的SQL语句，那基本上就是数据库层次的问题，否则就是代码层次。若为代码层次，再研究完代码后，再细化为算法或架构层次问题。</p>
<p>确定问题种类后，是时候上工具来精准定位问题点了：</p>
<ul>
<li>Sql耗时问题，推荐使用免费的<a href="https://www.sentryone.com/plan-explorer" target="_blank" rel="noopener">Plan Explorer </a>分析执行计划。</li>
<li>代码问题定位，优先推荐使用VS自带的Performance Analysis，其次是RedGate的性能分析套件<a href="http://www.red-gate.com/products/dotnet-development/dotnet-developer-bundle/" target="_blank" rel="noopener">.NET Developer Bundle</a>；然后还有Jet Brains的<a href="http://www.jetbrains.com/profiler/?fromMenu" target="_blank" rel="noopener">dotTrace – .NET performance profiler</a>，<a href="http://www.jetbrains.com/dotmemory/?fromMenu" target="_blank" rel="noopener">dotMemory– .NET memory profiler</a>；再然后就是反人类的Windbg；等等。</li>
</ul>
<p>精准定位问题点后，就是着手优化了。相信到这一步，就是优化策略的选择了，这里就不展开了。</p>
<p>优化后，最后当然要进行测试了，毕竟优化了多少，我们也要做到心里有谱才行。</p>
<p>以上啰啰嗦嗦有点多，下面我们直接上案例。</p>
<h1 id="4-案例分享"><a href="#4-案例分享" class="headerlink" title="4. 案例分享"></a>4. 案例分享</h1><p>下面就分享下我针对代码层面、数据库层面和算法层面的优化案例。</p>
<h2 id="4-1-SQL优化案例"><a href="#4-1-SQL优化案例" class="headerlink" title="4.1. SQL优化案例"></a>4.1. SQL优化案例</h2><blockquote>
<p>案例1：客户反馈某结算报表统计十天内的数据耗时10mins左右。</p>
</blockquote>
<p>由于前几天刚学会用RedGate的分析工具，拿到这个问题，本地尝试重现后，就直接想使用工具分析。然而，这工具在使用webdev模式起站点时，总是报错，而当时时一根筋，老是想解决这个工具的报错问题。结果，白白搞了半天也没搞定。最后不得已放弃工具，转而选择使用sql server profiler去监控sql语句耗时。一跟踪不要紧，问题就直接暴露了，整个全屏的重复sql语句，如下图。</p>
<p><img src="/images/how-much-you-know-about-the-performance-optimization/2799767-f2779b1cef7ffb3f.png" alt="Sql Profiler监控结果"></p>
<p>这下问题就很明显了，八成是代码在循环拼接sql执行语句。根据抓取到sql关键字往代码中去搜索，果然如此。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#region更新三张表数据结合的中间临时表数据，有上游单据的直接调拨单分多次下推时，只计算一次的调拨数量和价税合计</span><br><span class="line">string sSql &#x3D; string.Format(@</span><br><span class="line">&quot;SELECT FENTRYID FROM &#123;0&#125; GROUP BY FENTRYID HAVING COUNT(FENTRYID) &gt; 1&quot;, sJoinDataTempTable);</span><br><span class="line">using(IDataReader reader &#x3D; DBUtils.ExecuteReader(this.Context, sSql)) &#123;</span><br><span class="line">    while (reader.Read()) &#123;</span><br><span class="line">        sbSql.AppendFormat(@&quot;</span><br><span class="line">UPDATE &#123;0&#125; SET FDIRECTQTY &#x3D; 0,FALLAMOUNT &#x3D; 0 </span><br><span class="line">WHERE FSEQ NOT IN (</span><br><span class="line">SELECT TOP 1 FSEQ FROM &#123;0&#125; WHERE FENTRYID &#x3D; &#123;1&#125;) AND FENTRYID &#x3D; (&#123;1&#125;);&quot;</span><br><span class="line">, sJoinDataTempTable, Convert.ToInt32(reader[&quot;FENTRYID&quot;]));</span><br><span class="line">        listSqlObj.Add(new SqlObject(sbSql.ToString(), new List &lt; SqlParam &gt; ()));</span><br><span class="line">        sbSql.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#endregion</span><br></pre></td></tr></table></figure>

<p>看到这段代码，咱先不评判这段代码的优劣，因为毕竟代码注释清晰，省了我们理清业务的功夫。这段sql主要是想做去重处理，很显然选用了错误的方案。改后代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string sqlMerge &#x3D; string.Format(@&quot;</span><br><span class="line">merge into &#123;0&#125; t1</span><br><span class="line">using(</span><br><span class="line">select min(Fseq) fseq,Fentryid from &#123;0&#125; t2 group by fentryid</span><br><span class="line">) t3 on (t1.fentryid &#x3D; t3.fentryid and t1.fseq &lt;&gt; t3.fseq)</span><br><span class="line">when matched then</span><br><span class="line">update set t1.FDIRECTQTY &#x3D; 0, t1.FALLAMOUNT &#x3D; 0</span><br><span class="line">&quot;, sJoinDataTempTable);</span><br><span class="line"></span><br><span class="line">listSqlObj.Add(new SqlObject(sqlMerge, new List &lt; SqlParam &gt; ()));</span><br><span class="line">sbSql.Clear();</span><br></pre></td></tr></table></figure>

<p>改后测试相同数据量，耗时由10mins降到10s左右。</p>
<h2 id="4-2-代码优化案例"><a href="#4-2-代码优化案例" class="headerlink" title="4.2. 代码优化案例"></a>4.2. 代码优化案例</h2><blockquote>
<p>案例2：客户反馈销售订单100条分录行，保存进行可发量校验时，耗时7mins左右。</p>
</blockquote>
<p>拿到这个问题后，本地重现后，监控sql耗时没有异常，那就着重分析代码了。因为可发量校验的业务逻辑极其复杂，又加上又直接再一个类文件实现该功能，3500+行的代码，加上零星注释，真是让人避之不及。逃避不是办法，还是上工具分析一把。<br>这次我选用的时VS自带的<strong><a href="https://msdn.microsoft.com/en-us/library/ms182372.aspx" target="_blank" rel="noopener">Performance Profiler</a></strong>，开发环境下极其强大的性能调优工具。针对我们当前案例，我们仅需要跟踪指定服务对应的dll即可，使用步骤如下：</p>
<ol>
<li>Analyze–&gt;Profiler–&gt;New Performance Session</li>
<li>打开Performance Explorer</li>
<li>找到新添加的Performance Session，右键Targets，然后选择Add Target Binary，添加要跟踪的dll文件即可</li>
<li>将应用跑起来</li>
<li>选中Performance Session，右键Attach对应进程即可跟踪分析性能了</li>
<li>在跟踪过程中，可随时暂停跟踪和停止跟踪</li>
</ol>
<p><img src="/images/how-much-you-know-about-the-performance-optimization/2799767-581bab6651172c90.png" alt="图示步骤"></p>
<p>跟踪结束后本案例跟踪到的采样结果如下图：</p>
<p><img src="/images/how-much-you-know-about-the-performance-optimization/2799767-9bd074f58fbe605e.png" alt="VS Performance Profiler分析报告"></p>
<p>同时Performance Profiler也给出了问题的建议，如下图：<br><img src="/images/how-much-you-know-about-the-performance-optimization/2799767-5e091191b829b7da.png" alt="VS Performance Profiler分析提示"></p>
<p>其中第1、4条大致说明程序I/O消耗大，第一代的GC上存在未及时释放的垃圾占比过高。而根据上图的采样结果，我们可以直接看出是由于再代码中频繁操作DataTable引起的性能瓶颈。走读代码发现的确如此，所有的数量统计都是在代码中循环遍历DataTable进行处理的。而最终的优化策略，就相当于一次大的重构，将所有代码中通过遍历DataTable的计算逻辑全部挪到SQL中去做。由于代码过多，就不再放出。</p>
<blockquote>
<p>案例3：客户反馈批量引入1000张订单，耗时40mins左右，且容易中断。</p>
</blockquote>
<p>同样，我们还是先尝试本地重现。经测试批量引入101张单据，就耗时5mins左右。下一步打开Sql监控工具也未发现耗时语句。但考虑到是批量导入操作，虽然单个耗时不多，但乘以100这个基数，就明显了。下面我们就使用RedGate的<a href="http://www.red-gate.com/products/dotnet-development/ants-performance-profiler/" target="_blank" rel="noopener">Ants Performance Profiler</a>跟踪一下。</p>
<p>该工具比较直观，可以同时监控代码和SQL执行情况。第一步，New Profiler Session，第二步进行设置，如下图。根据自己的应用程序类别，选择相应的跟踪方式。</p>
<p><img src="/images/how-much-you-know-about-the-performance-optimization/2799767-6401487a7995b6dc.png" alt="跟踪设置"></p>
<p>针对这个问题，我们跟踪到的调用堆栈和SQL耗时结果如下图：</p>
<p><img src="/images/how-much-you-know-about-the-performance-optimization/2799767-aa1da6373d8fdfc3.png" alt="调用堆栈监控结果"></p>
<p><img src="/images/how-much-you-know-about-the-performance-optimization/2799767-93679e720a28eeb3.png" alt="SQL监控结果"></p>
<p>首先从调用堆栈中的Hit Count，我们可以首先看出它是一个批量过程，因为入口函数仅调用一次；第二个我们可以代码中是循环处理每一个单据，因为Hit Count与我们批量引入的单据数量相符；第三个，突然来了个10201，如果有一定的数字敏感性的话，这次性能问题的原因就被你找到了。这里就不卖关子了，101 x 101 = 10201。<br>是不是明白了什么，存在循环嵌套循环的情况。我们走读代码确定一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Save.cs</span><br><span class="line">public override void EndOperationTransaction(EndOperationTransactionArgs e) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他代码</span><br><span class="line">    foreach(DynamicObject dyItem in e.DataEntitys) &#123;</span><br><span class="line">        &#x2F;&#x2F;反写收款单</span><br><span class="line">        WriteBackReceiveBill wb &#x3D; new WriteBackReceiveBill();</span><br><span class="line">        wb.WriteBackForSave(e, this.Context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;WriteBackReceiveBill .cs</span><br><span class="line">public void WriteBackForSave(EndOperationTransactionArgs e, Context contx) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他代码：</span><br><span class="line">    foreach(DynamicObject item in e.DataEntitys) &#123;</span><br><span class="line">        &#x2F;&#x2F;do something </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好嘛，外层套了一个空循环却什么也没做。修改就很简单了，删除无效外层循环即可。</p>
<h2 id="4-3-算法优化案例"><a href="#4-3-算法优化案例" class="headerlink" title="4.3. 算法优化案例"></a>4.3. 算法优化案例</h2><blockquote>
<p>案例4：某全流程跟踪报表超时。</p>
</blockquote>
<p>这个报表是用来跟踪所有单据从下单到出库的业务流程数据流转情况。而所有的流程数据都是按照树形结果存储在数据库表中的，类似这样：</p>
<p><img src="/images/how-much-you-know-about-the-performance-optimization/2799767-b0c94713af838e01.png" alt="流程树表"></p>
<p>图中的流程为：<br>销售合同–&gt;销售订单–&gt;发货通知单–&gt;销售出库单</p>
<p>为了构造流程图，之前的处理方法是把流程数据取回来，通过代码构造流程图。这也就是性能差的原因。</p>
<p>而针对这种情况，就是考验我们平时经验积累了。对于树形结构的表，我们也是可以通过SQL来进行直接查询的，这就要用到了SQL Server的CTE语法来进行递归查询。关于递归查询，可参考我这篇文章：<a href="http://www.jianshu.com/p/ab9d268aa54c" target="_blank" rel="noopener">SQL递归查询知多少</a>。这里就不展开了。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h1><p>性能调优是一个循序渐进的过程，不可能一蹴而就，重在平时的点滴积累。关于工具的选择和使用，本文并未展开，也希望读者也不要纠结与此。当你真正想解决一个问题的时候，相信工具的使用是难不住你的。</p>
<p>最后就大致总结下我的调优思路：</p>
<ol>
<li>调整心态，积极应对</li>
<li>了解性能背景， 收集证据， 尝试重现</li>
<li>问题分类，先监控SQL耗时，大致确定是SQL或是代码层次原因</li>
<li>使用性能分析工具，确定问题点</li>
<li>调优测试</li>
</ol>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>RabbitMQ 知多少</title>
    <url>/post/how-much-you-know-about-the-rabbitmq/</url>
    <content><![CDATA[<p><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-82c5402158929477.png" alt=""></p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><p>RabbitMQ——Rabbit Message Queue的简写，但不能仅仅理解其为消息队列，消息代理更合适。RabbitMQ 是一个由 Erlang 语言开发的AMQP（高级消息队列协议）的开源实现，其内部结构如下：</p>
<p><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-05b3dc7216205c41.png" alt="RabbitMQ 内部结构"></p>
<p>RabbitMQ作为一个消息代理，主要和<strong>消息</strong>打交道，负责接收并转发消息。RabbitMQ提供了可靠的消息机制、跟踪机制和灵活的消息路由，支持消息集群和分布式部署。适用于排队算法、秒杀活动、消息分发、异步处理、数据同步、处理耗时任务、CQRS等应用场景。</p>
<p>下面我们就来学习下RabbitMQ。</p>
<h1 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h1><p>本文主要基于Windows下使用Vs Code 基于.net core进行demo演示。开始之前我们需要准备好以下环境。</p>
<ul>
<li>安装Erlang运行环境<br>下载安装<a href="http://www.erlang.org/downloads" target="_blank" rel="noopener">Erlang</a>。</li>
<li>安装RabbitMQ<br>下载安装Windows版本的<a href="http://www.rabbitmq.com/install-windows.html" target="_blank" rel="noopener">RabbitMQ</a>。</li>
<li>启动RabbitMQ Server<br>点击Windows开始按钮，输入RabbitMQ找到<code>RabbitMQ Comman Prompt</code>，以管理员身份运行。</li>
<li>依次执行以下命令启动RabbitMQ服务<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmq-service install</span><br><span class="line">rabbitmq-service enable</span><br><span class="line">rabbitmq-service start</span><br></pre></td></tr></table></figure></li>
<li>执行<code>rabbitmqlctl status</code>检查RabbitMQ状态</li>
<li>安装管理平台插件<br>执行<code>rabbitmq-plugins enable rabbitmq_management</code>即可成功安装，使用默认账号密码（guest/guest）登录<a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a>即可。</li>
</ul>
<h1 id="3-Hello-RabbitMQ"><a href="#3-Hello-RabbitMQ" class="headerlink" title="3. Hello RabbitMQ"></a>3. Hello RabbitMQ</h1><p>在开始之前我们先来了解下消息模型：<br><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-a5e45f97bec36c8a.png" alt="消息流"><br>消费者（consumer）订阅某个队列。生产者（producer）创建消息，然后发布到队列（queue）中，队列再将消息发送到监听的消费者。</p>
<p>下面我们我们通过demo来了解RabbitMQ的基本用法。</p>
<h2 id="3-1-消息的发送和接收"><a href="#3-1-消息的发送和接收" class="headerlink" title="3.1.消息的发送和接收"></a>3.1.消息的发送和接收</h2><p>创建RabbitMQ文件夹，打开命令提示符，分别创建两个控制台项目Send、Receive。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dotnet new console --name Send &#x2F;&#x2F;创建发送端控制台应用</span><br><span class="line">cd Send &#x2F;&#x2F;进入Send目录</span><br><span class="line">dotnet add package RabbitMQ.Client &#x2F;&#x2F;添加RabbitMQ.Client包</span><br><span class="line">dotnet restore &#x2F;&#x2F;恢复包</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dotnet new console --name Receive &#x2F;&#x2F;创建接收端控制台应用</span><br><span class="line">cd Receive &#x2F;&#x2F;进入Receive目录</span><br><span class="line">dotnet add package RabbitMQ.Client &#x2F;&#x2F;添加RabbitMQ.Client包</span><br><span class="line">dotnet restore &#x2F;&#x2F;恢复包</span><br></pre></td></tr></table></figure>
<p>我们先来添加消息发送端逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Send.cs </span><br><span class="line">public static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;1.1.实例化连接工厂</span><br><span class="line">    var factory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;localhost&quot; &#125;;</span><br><span class="line">    &#x2F;&#x2F;2. 建立连接</span><br><span class="line">    using (var connection &#x3D; factory.CreateConnection())</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;3. 创建信道</span><br><span class="line">        using (var channel &#x3D; connection.CreateModel())</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;4. 申明队列</span><br><span class="line">            channel.QueueDeclare(queue: &quot;hello&quot;, durable: false, exclusive: false, autoDelete: false, arguments: null);</span><br><span class="line">            &#x2F;&#x2F;5. 构建byte消息数据包</span><br><span class="line">            string message &#x3D; args.Length &gt; 0 ? args[0] : &quot;Hello RabbitMQ!&quot;;</span><br><span class="line">            var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line">            &#x2F;&#x2F;6. 发送数据包</span><br><span class="line">            channel.BasicPublish(exchange: &quot;&quot;, routingKey: &quot;hello&quot;, basicProperties: null, body: body);</span><br><span class="line">            Console.WriteLine(&quot; [x] Sent &#123;0&#125;&quot;, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来完善消息接收端逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Receive.cs  省略部分代码</span><br><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;1.实例化连接工厂</span><br><span class="line">    var factory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;localhost&quot; &#125;;</span><br><span class="line">    &#x2F;&#x2F;2. 建立连接</span><br><span class="line">    using (var connection &#x3D; factory.CreateConnection())</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;3. 创建信道</span><br><span class="line">        using (var channel &#x3D; connection.CreateModel())</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;4. 申明队列</span><br><span class="line">            channel.QueueDeclare(queue: &quot;hello&quot;, durable: false, exclusive: false, autoDelete: false, arguments: null);</span><br><span class="line">            &#x2F;&#x2F;5. 构造消费者实例</span><br><span class="line">            var consumer &#x3D; new EventingBasicConsumer(channel);</span><br><span class="line">            &#x2F;&#x2F;6. 绑定消息接收后的事件委托</span><br><span class="line">            consumer.Received +&#x3D; (model, ea) &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                var message &#x3D; Encoding.UTF8.GetString(ea.Body);</span><br><span class="line">                Console.WriteLine(&quot; [x] Received &#123;0&#125;&quot;, message);</span><br><span class="line">                Thread.Sleep(6000);&#x2F;&#x2F;模拟耗时</span><br><span class="line">                Console.WriteLine (&quot; [x] Done&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line">            &#x2F;&#x2F;7. 启动消费者</span><br><span class="line">            channel.BasicConsume(queue: &quot;hello&quot;, autoAck: true, consumer: consumer);</span><br><span class="line">            Console.WriteLine(&quot; Press [enter] to exit.&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先运行消息接收端，再运行消息发送端，结果如下图。</p>
<p><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-9079418f0a3f1ccd.png" alt="运行结果"></p>
<p>从上面的代码中可以看出，发送端和消费端的代码前4步都是一样的。主要的区别在于发送端调用<code>channel.BasicPublish</code>方法发送消息；而接收端需要实例化一个<code>EventingBasicConsumer</code>实例来进行消息处理逻辑。另外一点需要注意的是：消息接收端和发送端的队列名称（queue）必须保持一致，这里指定的队列名称为hello。</p>
<h2 id="3-2-循环调度"><a href="#3-2-循环调度" class="headerlink" title="3.2. 循环调度"></a>3.2. 循环调度</h2><p>使用工作队列的好处就是它能够并行的处理队列。如果堆积了很多任务，我们只需要添加更多的工作者（workers）就可以了。我们先启动两个接收端，等待消息接收，再启动一个发送端进行消息发送。</p>
<p><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-283ced13913a0aac.png" alt="消息分发"></p>
<p>我们增加运行一个消费端后的运行结果：</p>
<p><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-906a1ab86a7459d8.png" alt="循环调度"></p>
<p>从图中可知，我们循环发送4条信息，两个消息接收端按顺序被循环分配。<br>默认情况下，RabbitMQ将按顺序将每条消息发送给下一个消费者。平均每个消费者将获得相同数量的消息。这种分发消息的方式叫做循环（round-robin）。</p>
<h2 id="3-3-消息确认"><a href="#3-3-消息确认" class="headerlink" title="3.3. 消息确认"></a>3.3. 消息确认</h2><p>按照我们上面的demo，一旦RabbitMQ将消息发送到消费端，消息就会立即从内存中移出，无论消费端是否处理完成。在这种情况下，消息就会丢失。</p>
<p>为了确保一个消息永远不会丢失，RabbitMQ支持<strong>消息确认（message acknowledgments）</strong>。当消费端接收消息并且处理完成后，会发送一个ack（消息确认）信号到RabbitMQ，RabbitMQ接收到这个信号后，就可以删除掉这条已经处理的消息任务。但如果消费端挂掉了（比如，通道关闭、连接丢失等）没有发送ack信号。RabbitMQ就会明白某个消息没有正常处理，RabbitMQ将会重新将消息入队，如果有另外一个消费端在线，就会快速的重新发送到另外一个消费端。</p>
<p>RabbitMQ中没有消息超时的概念，只有当消费端关闭或奔溃时，RabbitMQ才会重新分发消息。</p>
<p>微调下Receive中的代码逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;5. 构造消费者实例</span><br><span class="line">var consumer &#x3D; new EventingBasicConsumer(channel);</span><br><span class="line">&#x2F;&#x2F;6. 绑定消息接收后的事件委托</span><br><span class="line">consumer.Received +&#x3D; (model, ea) &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var message &#x3D; Encoding.UTF8.GetString(ea.Body);</span><br><span class="line">    Console.WriteLine(&quot; [x] Received &#123;0&#125;&quot;, message);</span><br><span class="line">    Thread.Sleep(6000);&#x2F;&#x2F;模拟耗时</span><br><span class="line">    Console.WriteLine(&quot; [x] Done&quot;);</span><br><span class="line">    &#x2F;&#x2F; 7. 发送消息确认信号（手动消息确认）</span><br><span class="line">    channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: false);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;8. 启动消费者</span><br><span class="line">&#x2F;&#x2F;autoAck:true；自动进行消息确认，当消费端接收到消息后，就自动发送ack信号，不管消息是否正确处理完毕</span><br><span class="line">&#x2F;&#x2F;autoAck:false；关闭自动消息确认，通过调用BasicAck方法手动进行消息确认</span><br><span class="line">channel.BasicConsume(queue: &quot;hello&quot;, autoAck: false, consumer: consumer);</span><br></pre></td></tr></table></figure>

<p>主要改动的是将 <code>autoAck:true</code>修改为<code>autoAck:fasle</code>，以及在消息处理完毕后手动调用<code>BasicAck</code>方法进行手动消息确认。</p>
<p><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-d781dd054f6d2c77.png" alt=""></p>
<p>从图中可知，消息发送端连续发送4条消息，其中消费端1先被分配处理第一条消息，消费端2被循环分配第二条消息，第三条消息由于没有空闲消费者仍然在队列中。<br>在消费端2未处理完第一条消息之前，手动中断（ctrl+c）。我们可以发现RabbitMQ在下一次分发时，会优先将被中断的消息分发给消费端1处理。</p>
<h2 id="3-4-消息持久化"><a href="#3-4-消息持久化" class="headerlink" title="3.4. 消息持久化"></a>3.4. 消息持久化</h2><p>消息确认确保了即使消费端异常，消息也不会丢失能够被重新分发处理。但是如果RabbitMQ服务端异常，消息依然会丢失。除非我们指定<code>durable:true</code>，否则当RabbitMQ退出或奔溃时，消息将依然会丢失。通过指定<code>durable:true</code>，并指定<code>Persistent=true</code>，来告知RabbitMQ将消息持久化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;send.cs</span><br><span class="line">&#x2F;&#x2F;4. 申明队列(指定durable:true,告知rabbitmq对消息进行持久化)</span><br><span class="line">channel.QueueDeclare(queue: &quot;hello&quot;, durable: true, exclusive: false, autoDelete: false, arguments</span><br><span class="line">&#x2F;&#x2F;将消息标记为持久性 - 将IBasicProperties.SetPersistent设置为true</span><br><span class="line">var properties &#x3D; channel.CreateBasicProperties();</span><br><span class="line">properties.Persistent &#x3D; true;</span><br><span class="line">&#x2F;&#x2F;5. 构建byte消息数据包</span><br><span class="line">string message &#x3D; args.Length &gt; 0 ? args[0] : &quot;Hello RabbitMQ!&quot;;</span><br><span class="line">var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line">&#x2F;&#x2F;6. 发送数据包(指定basicProperties)</span><br><span class="line">channel.BasicPublish(exchange: &quot;&quot;, routingKey: &quot;hello&quot;, basicProperties: properties, body: body);</span><br></pre></td></tr></table></figure>
<p>将消息标记为持久性不能完全保证消息不会丢失。虽然它告诉RabbitMQ将消息保存到磁盘，但是当RabbitMQ接受消息并且还没有保存时，仍然有一个很短的时间窗口。RabbitMQ 可能只是将消息保存到了缓存中，并没有将其写入到磁盘上。持久化是不能够一定保证的，但是对于一个简单任务队列来说已经足够。如果需要确保消息队列的持久化，可以使用<a href="https://www.rabbitmq.com/confirms.html" target="_blank" rel="noopener">publisher confirms</a>.</p>
<h2 id="3-5-公平分发"><a href="#3-5-公平分发" class="headerlink" title="3.5. 公平分发"></a>3.5. 公平分发</h2><p>RabbitMQ的消息分发默认按照消费端的数量，按顺序循环分发。这样仅是确保了消费端被平均分发消息的数量，但却忽略了消费端的闲忙情况。这就可能出现某个消费端一直处理耗时任务处于阻塞状态，某个消费端一直处理一般任务处于空置状态，而只是它们分配的任务数量一样。</p>
<p><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-d2bb1f2ac63fdb15.png" alt=""></p>
<p>但我们可以通过<code>channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);</code><br>设置<code>prefetchCount : 1</code>来告知RabbitMQ，在未收到消费端的消息确认时，不再分发消息，也就确保了当消费端处于忙碌状态时，不再分配任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Receive.cs</span><br><span class="line">&#x2F;&#x2F;4. 申明队列</span><br><span class="line">channel.QueueDeclare(queue: &quot;hello&quot;, durable: false, exclusive: false, autoDelete: false, arguments: null);</span><br><span class="line">&#x2F;&#x2F;设置prefetchCount : 1来告知RabbitMQ，在未收到消费端的消息确认时，不再分发消息，也就确保了当消费端处于忙碌状态时</span><br><span class="line">channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);</span><br></pre></td></tr></table></figure>

<p>这时你需要注意的是如果所有的消费端都处于忙碌状态，你的队列可能会被塞满。你需要注意这一点，要么添加更多的消费端，要么采取其他策略。</p>
<h1 id="4-Exchange"><a href="#4-Exchange" class="headerlink" title="4. Exchange"></a>4. Exchange</h1><p>细心的你也许发现上面的demo，生产者和消费者直接是通过相同队列名称进行匹配衔接的。消费者订阅某个队列，生产者创建消息发布到队列中，队列再将消息转发到订阅的消费者。这样就会有一个局限性，即消费者一次只能发送消息到某一个队列。</p>
<p>那消费者如何才能发送消息到多个消息队列呢？<br>RabbitMQ提供了<strong>Exchange</strong>，它类似于路由器的功能，它用于对消息进行路由，将消息发送到多个队列上。Exchange一方面从生产者接收消息，另一方面将消息推送到队列。但exchange必须知道如何处理接收到的消息，是将其附加到特定队列还是附加到多个队列，还是直接忽略。而这些规则由exchange type定义，exchange的原理如下图所示。<br><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-0b4fba202e525745.png" alt="Exchange"></p>
<p>常见的exchange type 有以下几种：</p>
<ul>
<li>direct（明确的路由规则：消费端绑定的队列名称必须和消息发布时指定的路由名称一致）</li>
<li>topic （模式匹配的路由规则：支持通配符）</li>
<li>fanout （消息广播，将消息分发到exchange上绑定的所有队列上）</li>
</ul>
<p>下面我们就来一一这介绍它们的用法。</p>
<h2 id="4-1-fanout"><a href="#4-1-fanout" class="headerlink" title="4.1 fanout"></a>4.1 fanout</h2><p>本着先易后难的思想，我们先来了解下<strong>fanout</strong>的广播路由机制。fanout的路由机制如下图，即发送到 fanout 类型exchange的消息都会分发到所有绑定该exchange的队列上去。</p>
<p><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-3afd7b874221a9a2.png" alt="fanout 路由机制"></p>
<p>生产者示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成随机队列名称</span><br><span class="line">var queueName &#x3D; channel.QueueDeclare().QueueName;</span><br><span class="line">&#x2F;&#x2F;使用fanout exchange type，指定exchange名称</span><br><span class="line">channel.ExchangeDeclare(exchange: &quot;fanoutEC&quot;, type: &quot;fanout&quot;);</span><br><span class="line">var message &#x3D; &quot;Hello Rabbit!&quot;;</span><br><span class="line">var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line">&#x2F;&#x2F;发布到指定exchange，fanout类型无需指定routingKey</span><br><span class="line">channel.BasicPublish(exchange: &quot;fanoutEC&quot;, routingKey: &quot;&quot;, basicProperties: null, body: body);</span><br></pre></td></tr></table></figure>
<p>消费者示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;申明fanout类型exchange</span><br><span class="line">channel.ExchangeDeclare (exchange: &quot;fanoutEC&quot;, type: &quot;fanout&quot;);</span><br><span class="line">&#x2F;&#x2F;申明随机队列名称</span><br><span class="line">var queuename &#x3D; channel.QueueDeclare ().QueueName;</span><br><span class="line">&#x2F;&#x2F;绑定队列到指定fanout类型exchange，无需指定路由键</span><br><span class="line">channel.QueueBind (queue : queuename, exchange: &quot;fanoutEC&quot;, routingKey: &quot;&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="4-2-direct"><a href="#4-2-direct" class="headerlink" title="4.2. direct"></a>4.2. direct</h2><p>direct相对于fanout就属于完全匹配、单播的模式，路由机制如下图，即队列名称和消息发送时指定的路由完全匹配时，消息才会发送到指定队列上。<br><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-6c78ab57fe06c6ce.png" alt="direct路由机制"></p>
<p>生产者示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成随机队列名称</span><br><span class="line">var queueName &#x3D; channel.QueueDeclare().QueueName;</span><br><span class="line">&#x2F;&#x2F;使用direct exchange type，指定exchange名称</span><br><span class="line">channel.ExchangeDeclare(exchange: &quot;directEC&quot;, type: &quot;direct&quot;);</span><br><span class="line">var message &#x3D; &quot;Hello Rabbit!&quot;;</span><br><span class="line">var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line">&#x2F;&#x2F;发布到direct类型exchange，必须指定routingKey</span><br><span class="line">channel.BasicPublish(exchange: &quot;directEC&quot;, routingKey: &quot;green&quot;, basicProperties: null, body: body);</span><br></pre></td></tr></table></figure>
<p>消费者示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;申明direct类型exchange</span><br><span class="line">channel.ExchangeDeclare (exchange: &quot;directEC&quot;, type: &quot;direct&quot;);</span><br><span class="line">&#x2F;&#x2F;绑定队列到direct类型exchange，需指定路由键routingKey</span><br><span class="line">channel.QueueBind (queue : green, exchange: &quot;directEC&quot;, routingKey: &quot;green&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="4-3-topic"><a href="#4-3-topic" class="headerlink" title="4.3. topic"></a>4.3. topic</h2><p>topic是direct的升级版，是一种模式匹配的路由机制。它支持使用两种通配符来进行模式匹配：符号<strong><code>#</code></strong>和符号<strong><code>*</code></strong>。其中<strong><code>*</code></strong>匹配一个单词， <strong><code>#</code></strong>则表示匹配0个或多个单词，单词之间用<strong><code>.</code></strong>分割。如下图所示。<br><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-3196a1c3880b3466.png" alt="topic路由机制"></p>
<p>生产者示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成随机队列名称</span><br><span class="line">var queueName &#x3D; channel.QueueDeclare().QueueName;</span><br><span class="line">&#x2F;&#x2F;使用topic exchange type，指定exchange名称</span><br><span class="line">channel.ExchangeDeclare(exchange: &quot;topicEC&quot;, type: &quot;topic&quot;);</span><br><span class="line">var message &#x3D; &quot;Hello Rabbit!&quot;;</span><br><span class="line">var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line">&#x2F;&#x2F;发布到topic类型exchange，必须指定routingKey</span><br><span class="line">channel.BasicPublish(exchange: &quot;topicEC&quot;, routingKey: &quot;first.green.fast&quot;, basicProperties: null, body: body);</span><br></pre></td></tr></table></figure>
<p>消费者示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;申明topic类型exchange</span><br><span class="line">channel.ExchangeDeclare (exchange: &quot;topicEC&quot;, type: &quot;topic&quot;);</span><br><span class="line">&#x2F;&#x2F;申明随机队列名称</span><br><span class="line">var queuename &#x3D; channel.QueueDeclare ().QueueName;</span><br><span class="line">&#x2F;&#x2F;绑定队列到topic类型exchange，需指定路由键routingKey</span><br><span class="line">channel.QueueBind (queue : queuename, exchange: &quot;topicEC&quot;, routingKey: &quot;#.*.fast&quot;);</span><br></pre></td></tr></table></figure>

<h1 id="5-RPC"><a href="#5-RPC" class="headerlink" title="5. RPC"></a>5. RPC</h1><p>RPC——Remote Procedure Call，远程过程调用。<br>那RabbitMQ如何进行远程调用呢？示意图如下：<br><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-121e20f9b512c406.png" alt="RPC机制"><br>第一步，主要是进行远程调用的客户端需要指定接收远程回调的队列，并申明消费者监听此队列。<br>第二步，远程调用的服务端除了要申明消费端接收远程调用请求外，还要将结果发送到客户端用来监听回调结果的队列中去。</p>
<p>远程调用客户端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;申明唯一guid用来标识此次发送的远程调用请求</span><br><span class="line">var correlationId &#x3D; Guid.NewGuid().ToString();</span><br><span class="line">&#x2F;&#x2F;申明需要监听的回调队列</span><br><span class="line">var replyQueue &#x3D; channel.QueueDeclare().QueueName;</span><br><span class="line">var properties &#x3D; channel.CreateBasicProperties();</span><br><span class="line">properties.ReplyTo &#x3D; replyQueue;&#x2F;&#x2F;指定回调队列</span><br><span class="line">properties.CorrelationId &#x3D; correlationId;&#x2F;&#x2F;指定消息唯一标识</span><br><span class="line">string number &#x3D; args.Length &gt; 0 ? args[0] : &quot;30&quot;;</span><br><span class="line">var body &#x3D; Encoding.UTF8.GetBytes(number);</span><br><span class="line">&#x2F;&#x2F;发布消息</span><br><span class="line">channel.BasicPublish(exchange: &quot;&quot;, routingKey: &quot;rpc_queue&quot;, basicProperties: properties, body: body);</span><br><span class="line">Console.WriteLine($&quot;[*] Request fib(&#123;number&#125;)&quot;);</span><br><span class="line">&#x2F;&#x2F; &#x2F;&#x2F;创建消费者用于处理消息回调（远程调用返回结果）</span><br><span class="line">var callbackConsumer &#x3D; new EventingBasicConsumer(channel);</span><br><span class="line">channel.BasicConsume(queue: replyQueue, autoAck: true, consumer: callbackConsumer);</span><br><span class="line">callbackConsumer.Received +&#x3D; (model, ea) &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">     &#x2F;&#x2F;仅当消息回调的ID与发送的ID一致时，说明远程调用结果正确返回。</span><br><span class="line">    if (ea.BasicProperties.CorrelationId &#x3D;&#x3D; correlationId)</span><br><span class="line">    &#123;</span><br><span class="line">        var responseMsg &#x3D; $&quot;Get Response: &#123;Encoding.UTF8.GetString(ea.Body)&#125;&quot;;</span><br><span class="line">        Console.WriteLine($&quot;[x]: &#123;responseMsg&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>远程调用服务端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;申明队列接收远程调用请求</span><br><span class="line">channel.QueueDeclare(queue: &quot;rpc_queue&quot;, durable: false,</span><br><span class="line">    exclusive: false, autoDelete: false, arguments: null);</span><br><span class="line">var consumer &#x3D; new EventingBasicConsumer(channel);</span><br><span class="line">Console.WriteLine(&quot;[*] Waiting for message.&quot;);</span><br><span class="line">&#x2F;&#x2F;请求处理逻辑</span><br><span class="line">consumer.Received +&#x3D; (model, ea) &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var message &#x3D; Encoding.UTF8.GetString(ea.Body);</span><br><span class="line">    int n &#x3D; int.Parse(message);</span><br><span class="line">    Console.WriteLine($&quot;Receive request of Fib(&#123;n&#125;)&quot;);</span><br><span class="line">    int result &#x3D; Fib(n);</span><br><span class="line">    &#x2F;&#x2F;从请求的参数中获取请求的唯一标识，在消息回传时同样绑定</span><br><span class="line">    var properties &#x3D; ea.BasicProperties;</span><br><span class="line">    var replyProerties &#x3D; channel.CreateBasicProperties();</span><br><span class="line">    replyProerties.CorrelationId &#x3D; properties.CorrelationId;</span><br><span class="line">    &#x2F;&#x2F;将远程调用结果发送到客户端监听的队列上</span><br><span class="line">    channel.BasicPublish(exchange: &quot;&quot;, routingKey: properties.ReplyTo,</span><br><span class="line">        basicProperties: replyProerties, body: Encoding.UTF8.GetBytes(result.ToString()));</span><br><span class="line">    &#x2F;&#x2F;手动发回消息确认</span><br><span class="line">    channel.BasicAck(ea.DeliveryTag, false);</span><br><span class="line">    Console.WriteLine($&quot;Return result: Fib(&#123;n&#125;)&#x3D; &#123;result&#125;&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">channel.BasicConsume(queue: &quot;rpc_queue&quot;, autoAck: false, consumer: consumer);</span><br></pre></td></tr></table></figure>

<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><p>基于上面的demo和对几种不同exchange路由机制的学习，我们发现RabbitMQ主要是涉及到以下几个核心概念：</p>
<ol>
<li>Publisher：生产者，消息的发送方。</li>
<li>Connection：网络连接。</li>
<li>Channel：信道，多路复用连接中的一条独立的双向数据流通道。</li>
<li>Exchange：交换器（路由器），负责消息的路由到相应队列。</li>
<li>Binding：队列与交换器间的关联绑定。消费者将关注的队列绑定到指定交换器上，以便Exchange能准确分发消息到指定队列。</li>
<li>Queue：队列，消息的缓冲存储区。</li>
<li>Virtual Host：虚拟主机，虚拟主机提供资源的逻辑分组和分离。包含连接，交换，队列，绑定，用户权限，策略等。</li>
<li>Broker：消息队列的服务器实体。</li>
<li>Consumer：消费者，消息的接收方。 </li>
</ol>
<p>这次作为入门就讲到这里，下次我们来讲解下<strong>EventBus + RabbitMQ</strong>如何实现事件的分发。</p>
<blockquote>
<p>参考资料：<br><a href="http://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">RabbitMQ Tutorials</a><br><a href="https://github.com/yanshengjie/RabbitMQ" target="_blank" rel="noopener">Demo路径——RabbitMQ</a></p>
</blockquote>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>消息队列</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>反应式编程知多少 | Rx.NET了解下</title>
    <url>/post/how-much-you-know-about-the-reactive-programming-in-dotnet/</url>
    <content><![CDATA[<p><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-54048d974ab3962e.png" alt=""></p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><blockquote>
<p>An API for asynchronous programming with observable streams.<br>ReactiveX is a combination of the best ideas from the <strong>Observer</strong> pattern, the <strong>Iterator</strong> pattern, and <strong>functional programming</strong>.<br><em>ReactiveX 使用可观察数据流进行异步编程的API。<br>ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华</em>。</p>
</blockquote>
<p>关于Reactive（本文统一译作响应式），有一个<a href="https://www.reactivemanifesto.org/zh-CN" target="_blank" rel="noopener">The Reactive Manifesto</a>【响应式宣言】：<strong>响应式系统（Reactive System）具备以下特质：即时响应性（Responsive）、回弹性（Resilient）、弹性（Elastic）以及消息驱动（Message Driven）。</strong></p>
<p><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-84eafef9e10f402d.png" alt=""></p>
<p>很显然开发一个响应式系统，并不简单。<br>那本文就来讲一讲如何基于Rx.NET进行响应式编程，进而开发更加灵活、松耦合、可伸缩的响应式系统。</p>
<h1 id="2-编程范式"><a href="#2-编程范式" class="headerlink" title="2. 编程范式"></a>2. 编程范式</h1><p>在开始之前呢，我们有必要了解下几种编程范式：命令式编程、声明式编程、函数式编程和响应式编程。</p>
<p><strong>命令式编程</strong>：命令式编程的主要思想是关注计算机执行的步骤，即一步一步告诉计算机先做什么再做什么。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1. 声明变量</span><br><span class="line">List&lt;int&gt; results &#x3D; new List&lt;int&gt;();</span><br><span class="line">&#x2F;&#x2F;2. 循环变量</span><br><span class="line">foreach(var num in Enumerable.Range(1,10))</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;3. 添加条件</span><br><span class="line">    if (num &gt; 5)</span><br><span class="line">    &#123;  </span><br><span class="line">        &#x2F;&#x2F;4. 添加处理逻辑</span><br><span class="line">        results.Add(num);</span><br><span class="line">        Console.WriteLine(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>声明式编程</strong>：声明式编程是以数据结构的形式来表达程序执行的逻辑。它的主要思想是告诉计算机应该做什么，但不指定具体要怎么做。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var nums &#x3D; from num in Enumerable.Range(1,10) where num &gt; 5 select num</span><br></pre></td></tr></table></figure>
<p><strong>函数式编程</strong>：主要思想是把运算过程尽量写成一系列嵌套的函数调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enumerable.Range(1, 10).Where(num &#x3D;&gt; num &gt; 5).ToList().ForEach(Console.WriteLine);</span><br></pre></td></tr></table></figure>
<p><strong>响应式编程</strong>：响应式编程是一种面向数据流和变化传播的编程范式，旨在简化事件驱动应用的实现。响应式编程专注于如何创建依赖于变更的数据流并对变化做出响应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IObservable&lt;int&gt; nums &#x3D; Enumerable.Range(1, 10).ToObservable();</span><br><span class="line"></span><br><span class="line">IDisposable subscription &#x3D; nums.Where(num &#x3D;&gt; num &gt; 5).Subscribe(Console.WriteLine);</span><br><span class="line"></span><br><span class="line">subscription.Dispose();</span><br></pre></td></tr></table></figure>

<h1 id="3-Hello-Rx-NET"><a href="#3-Hello-Rx-NET" class="headerlink" title="3. Hello Rx.NET"></a>3. Hello Rx.NET</h1><p>从一个简单的Demo开始。<br>假设我们现在模拟电热壶烧水，实时输出当前水温，一般我们会这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enumerable.Range(1, 100).ToList().ForEach(Console.WriteLine);</span><br><span class="line">&#x2F;&#x2F; do something else. 阻塞</span><br></pre></td></tr></table></figure>
<p>假设当前程序是智能家居的中控设备，不仅控制电热壶烧水，还控制其他设备，为了避免阻塞主线程。一般我们会创建一个Thread或Task去做。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Task.Run(() &#x3D;&gt; Enumerable.Range(1, 100).ToList().ForEach(Console.WriteLine));</span><br><span class="line">&#x2F;&#x2F; do something else. 非阻塞</span><br></pre></td></tr></table></figure>
<p>假设现在我们不仅要在控制台输出而且还要实时通过扬声器报警。这时我们应该想到委托和事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Heater</span><br><span class="line">&#123;</span><br><span class="line">    private delegate void TemperatureChanged(int temperature);</span><br><span class="line">    private event TemperatureChanged TemperatureChangedEvent;</span><br><span class="line">    public void BoilWater()</span><br><span class="line">    &#123;</span><br><span class="line">        TemperatureChangedEvent +&#x3D; ShowTemperature;</span><br><span class="line">        TemperatureChangedEvent +&#x3D; MakeAlerm;</span><br><span class="line">        Task.Run(</span><br><span class="line">            () &#x3D;&gt;</span><br><span class="line">        Enumerable.Range(1, 100).ToList().ForEach((temperature) &#x3D;&gt; TemperatureChangedEvent(temperature))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    private void ShowTemperature(int temperature)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;当前温度：&#123;temperature&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void MakeAlerm(int temperature)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;嘟嘟嘟，当前水温&#123;temperature&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Heater heater &#x3D; new Heater();        </span><br><span class="line">        heater.BoilWater();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>瞬间代码量就上去了。但是借助Rx.NET，我们可以简化成以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var observable &#x3D; Enumerable.Range(1, 100).ToObservable(NewTheadScheduler.Default);&#x2F;&#x2F;申明可观察序列</span><br><span class="line">Subject&lt;int&gt; subject &#x3D; new Subject&lt;int&gt;();&#x2F;&#x2F;申明Subject</span><br><span class="line">subject.Subscribe((temperature) &#x3D;&gt; Console.WriteLine($&quot;当前温度：&#123;temperature&#125;&quot;));&#x2F;&#x2F;订阅subject</span><br><span class="line">subject.Subscribe((temperature) &#x3D;&gt; Console.WriteLine($&quot;嘟嘟嘟，当前水温：&#123;temperature&#125;&quot;));&#x2F;&#x2F;订阅subject</span><br><span class="line">observable.Subscribe(subject);&#x2F;&#x2F;订阅observable</span><br></pre></td></tr></table></figure>
<p>仅仅通过以下三步：</p>
<ol>
<li>调用<code>ToObservable</code>将枚举序列转换为可观察序列。</li>
<li>通过指定<code>NewTheadScheduler.Default</code>来指定在单独的线程进行枚举。</li>
<li>调用<code>Subscribe</code>方法进行事件注册。</li>
<li>借助<code>Subject</code>进行多播传输</li>
</ol>
<p>通过以上我们可以看到Rx.NET大大简化了事件处理的步骤，而这只是Rx的冰山一角。</p>
<h1 id="4-Rx-NET-核心"><a href="#4-Rx-NET-核心" class="headerlink" title="4. Rx.NET 核心"></a>4. Rx.NET 核心</h1><p><a href="https://github.com/dotnet/reactive" target="_blank" rel="noopener">Reactive Extensions</a>（Rx）是一个为.NET应用提供响应式编程模型的库，用来构建异步基于事件流的应用，通过安装<code>System.Reactive</code>Nuget包进行引用。Rx将事件流抽象为Observable sequences（可观察序列）表示异步数据流，使用LINQ运算符查询异步数据流，并使用<code>Scheduler</code>来控制异步数据流中的并发性。简单地说：<strong>Rx = Observables + LINQ + Schedulers。</strong></p>
<p><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-b4a81ae7fbc5526d.png" alt="Rx layer"></p>
<p>在软件系统中，事件是一种消息用于指示发生了某些事情。事件由Event Source（事件源）引发并由Event Handler（事件处理程序）使用。<br>在Rx中，事件源可以由observable表示，事件处理程序可以由observer表示。<br>但是应用程序使用的数据如何表示呢，例如数据库中的数据或从Web服务器获取的数据。而在应用程序中我们一般处理的数据无外乎两种：静态数据和动态数据。 但无论使用何种类型的数据，其都可以作为流来观察。换句话说，数据流本身也是可观察的。也就意味着，我们也可以用observable来表示数据流。</p>
<p><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-093cbaf2aab308e9.png" alt="Everything is stream"></p>
<p>讲到这里，Rx.NET的核心也就一目了然了：</p>
<ol>
<li>一切皆为数据流</li>
<li>Observable 是对数据流的抽象</li>
<li>Observer是对Observable的响应</li>
</ol>
<p>在Rx中，分别使用<code>IObservable&lt;T&gt;</code>和<code>IObserver&lt;T&gt;</code>接口来表示可观察序列和观察者。它们预置在system命名空间下，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IObservable&lt;out T&gt;</span><br><span class="line">&#123;</span><br><span class="line">      &#x2F;&#x2F;Notifies the provider that an observer is to receive notifications.</span><br><span class="line">      IDisposable Subscribe(IObserver&lt;T&gt; observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface IObserver&lt;in T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;Notifies the observer that the provider has finished sending push-based notifications.</span><br><span class="line">    void OnCompleted();</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;Notifies the observer that the provider has experienced an error condition.</span><br><span class="line">    void OnError(Exception error);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;Provides the observer with new data.</span><br><span class="line">    void OnNext(T value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-cb04b6cd6fced9ea.png" alt=""></p>
<h1 id="5-创建IObservable"><a href="#5-创建IObservable" class="headerlink" title="5. 创建IObservable"></a>5. 创建IObservable<T></h1><p>创建<code>IObservable&lt;T&gt;</code>主要有以下几种方式：<br><strong>1. 直接实现<code>IObservable&lt;T&gt;</code>接口</strong><br><strong>2. 使用<code>Observable.Create</code>创建</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.Create&lt;int&gt;(observer&#x3D;&gt;&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        observer.OnNext(i);</span><br><span class="line">    &#125;</span><br><span class="line">    observer.OnCompleted();</span><br><span class="line">    return Disposable.Empty;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>3. 使用<code>Observable.Deffer</code>进行延迟创建（当有观察者订阅时才创建）</strong><br>比如要连接数据库进行查询，如果没有观察者，那么数据库连接会一直被占用，这样会造成资源浪费。使用Deffer可以解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.Defer(() &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var connection &#x3D; Connect(user, password);</span><br><span class="line">    return connection.ToObservable();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>4. 使用<code>Observable.Generate</code>创建迭代类型的可观察序列</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IObservable&lt;int&gt; observable &#x3D;</span><br><span class="line">    Observable.Generate(</span><br><span class="line">        0,              &#x2F;&#x2F;initial state</span><br><span class="line">        i &#x3D;&gt; i &lt; 10,    &#x2F;&#x2F;condition (false means terminate)</span><br><span class="line">        i &#x3D;&gt; i + 1,     &#x2F;&#x2F;next iteration step</span><br><span class="line">        i &#x3D;&gt; i * 2);      &#x2F;&#x2F;the value in each iteration</span><br></pre></td></tr></table></figure>
<p><strong>5. 使用<code>Observable.Range</code>创建指定区间的可观察序列</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IObservable&lt;int&gt; observable &#x3D; Observable.Range (0, 10).Select (i &#x3D;&gt; i * 2);</span><br></pre></td></tr></table></figure>
<p><strong>6. 创建特殊用途的可观察序列</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.Return (&quot;Hello World&quot;);&#x2F;&#x2F;创建单个元素的可观察序列</span><br><span class="line">Observable.Never&lt;string&gt; ();&#x2F;&#x2F;创建一个空的永远不会结束的可观察序列</span><br><span class="line">Observable.Throw&lt;ApplicationException&gt; (</span><br><span class="line">new ApplicationException (&quot;something bad happened&quot;))&#x2F;&#x2F;创建一个抛出指定异常的可观察序列</span><br><span class="line">Observable.Empty&lt;string&gt; ()&#x2F;&#x2F;创建一个空的立即结束的可观察序列</span><br></pre></td></tr></table></figure>
<p><strong>7. 使用<code>ToObservable</code>转换<code>IEnumerate</code>和Task类型</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enumerable.Range(1, 10).ToObservable();</span><br><span class="line">IObservable&lt;IEnumerable&lt;string&gt;&gt; resultsA &#x3D; searchEngineA.SearchAsync(term).ToObservable();</span><br></pre></td></tr></table></figure>
<p><strong>8. 使用<code>Observable.FromEventPattern&lt;T&gt;</code>和<code>Observable.FromEvent&lt;TDelegate, TEventArgs&gt;</code></strong>进行事件的转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public delegate void RoutedEventHandler(object sender,</span><br><span class="line"> System.Windows.RoutedEventArgs e)</span><br><span class="line">IObservable&lt;EventPattern&lt;RoutedEventArgs&gt;&gt; clicks &#x3D;</span><br><span class="line">                Observable.FromEventPattern&lt;RoutedEventHandler, RoutedEventArgs&gt;(</span><br><span class="line">                    h &#x3D;&gt; theButton.Click +&#x3D; h,</span><br><span class="line">                    h &#x3D;&gt; theButton.Click -&#x3D; h);</span><br><span class="line">clicks.Subscribe(eventPattern &#x3D;&gt; output.Text +&#x3D; &quot;button clicked&quot; + Environment.NewLine);</span><br></pre></td></tr></table></figure>

<p><strong>9. 使用<code>Observable.Using</code>进行资源释放</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IObservable&lt;string&gt; lines &#x3D;</span><br><span class="line">    Observable.Using (</span><br><span class="line">        () &#x3D;&gt; File.OpenText (&quot;TextFile.txt&quot;), &#x2F;&#x2F; opens the file and returns the stream we work with</span><br><span class="line">        stream &#x3D;&gt;</span><br><span class="line">        Observable.Generate (</span><br><span class="line">            stream, &#x2F;&#x2F;initial state</span><br><span class="line">            s &#x3D;&gt; !s.EndOfStream, &#x2F;&#x2F;we continue until we reach the end of the file</span><br><span class="line">            s &#x3D;&gt; s, &#x2F;&#x2F;the stream is our state, it holds the position in the file </span><br><span class="line">            s &#x3D;&gt; s.ReadLine ()) &#x2F;&#x2F;each iteration will emit the current line (and moves to the next)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p><strong>10. 使用<code>Observable.Interval</code>创建指定间隔可观察序列</strong><br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-fbc5816e51fb2b45.png" alt=""></p>
<p><strong>11. 使用<code>Observable.Timer</code>创建可观察的计时器</strong><br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-9295db8a2f4e08e4.png" alt=""></p>
<h1 id="6-RX-操作符"><a href="#6-RX-操作符" class="headerlink" title="6. RX 操作符"></a>6. RX 操作符</h1><p>创建完IObservable<T>后，我们可以对其应用系列Linq操作符，对其进行查询、过滤、聚合等等。Rx内置了以下系列操作符：<br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-54a9467df0b603fa.png" alt="Rx 操作符"><br>下面通过图示来解释常用操作符的作用：<br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-a865665f963a58d8.png" alt="操作符解释"></p>
<h1 id="7-多播传输靠：Subject"><a href="#7-多播传输靠：Subject" class="headerlink" title="7. 多播传输靠：Subject"></a>7. 多播传输靠：Subject</h1><p>基于以上示例，我们了解到，借助Rx可以简化事件模型的实现，而其实质上就是对观察者模式的扩展。提到观察者模式，我们知道一个Subject可以被多个观察者订阅，从而完成消息的多播。同样，在Rx中，也引入了Subject用于多播消息传输，不过Rx中的Subject具有双重身份——即是观察者也是被观察者。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface ISubject&lt;in TSource, out TResult&gt; : IObserver&lt;TSource&gt;,IObservable&lt;TResult&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rx中默认提供了以下四种实现：</p>
<ul>
<li><p>Subject<T>  - 向所有观察者广播每个通知<br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-81a5de33fcef3ea5.png" alt=""></p>
</li>
<li><p>AsyncSubject<T>  - 当可观察序列完成后有且仅发送一个通知<br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-0961c4adefb27d9a.png" alt=""></p>
</li>
<li><p>ReplaySubject<T>  - 缓存指定通知以对后续订阅的观察者进行重放<br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-f661dc814a8ac625.png" alt=""></p>
</li>
<li><p>BehaviorSubject<T>  - 推送默认值或最新值给观察者<br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-c72dc53ff1f6368d.png" alt=""></p>
</li>
</ul>
<p>但对于第一种<code>Subject&lt;T&gt;</code>有一点需要指出，当其有多个观察者序列时，一旦其中一个停止发送消息，则Subject就停止广播所有其他序列后续发送的任何消息。<br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-c6fedeb092186767.png" alt=""></p>
<h1 id="8-有温度的可观察者序列"><a href="#8-有温度的可观察者序列" class="headerlink" title="8. 有温度的可观察者序列"></a>8. 有温度的可观察者序列</h1><p>对于Observable，它们是有温度的，有冷热之分。它们的区别如下图所示：<br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-c4204f808d9849ed.png" alt="冷热观察者序列的区别"></p>
<p><strong>Cold Observable</strong>：有且仅当有观察者订阅时才发送通知，且每个观察者独享一份完整的观察者序列。<br><strong>Hot Observable</strong>：不管有无观察者订阅都会发送通知，且所有观察者共享同一份观察者序列。</p>
<h1 id="9-一切皆在掌控：Scheduler"><a href="#9-一切皆在掌控：Scheduler" class="headerlink" title="9. 一切皆在掌控：Scheduler"></a>9. 一切皆在掌控：Scheduler</h1><p>在Rx中，使用Scheduler来控制并发。而对于Scheduler我们可以理解为程序调度，通过Scheduler来规定在什么时间什么地点执行什么事情。Rx提供了以下几种Scheduler：</p>
<ol>
<li>NewThreadScheduler：即在新线程上执行</li>
<li>ThreadPoolScheduler：即在线程池中执行</li>
<li>TaskPoolScheduler：与ThreadPoolScheduler类似</li>
<li>CurrentThreadScheduler：在当前线程执行</li>
<li>ImmediateScheduler：在当前线程立即执行</li>
<li>EventLoopScheduler：创建一个后台线程按序执行所有操作</li>
</ol>
<p>举例而言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.Return(&quot;Hello&quot;,NewThreadScheduler.Default)</span><br><span class="line">.Subscribe(str&#x3D;&gt;Console.WriteLine($&quot;&#123;str&#125; on ThreadId：&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;)</span><br><span class="line">);</span><br><span class="line">Console.WriteLine($&quot;Current ThreadId：&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;);</span><br><span class="line"></span><br><span class="line">以上输出：</span><br><span class="line">Current ThreadId：1</span><br><span class="line">Hello on ThreadId：4</span><br></pre></td></tr></table></figure>
<h1 id="10-最后"><a href="#10-最后" class="headerlink" title="10. 最后"></a>10. 最后</h1><p>罗里吧嗦的总算把《Rx.NET In Action》这本书的内容大致梳理了一遍，对Rx也有了一个更深的认识，Rx扩展了观察者模式用于支持数据和事件序列，内置系列操作符允许我们以声明式的方式组合这些序列，且无需关注底层的实现进行事件驱动开发：如线程、同步、线程安全、并发数据结构和非阻塞IO。</p>
<p>但事无巨细，难免疏漏。对响应式编程有兴趣的不妨拜读下此书，相信对你会大有裨益。</p>
<blockquote>
<p>参考资料：<br><a href="http://dl1.rapidhosting.info/files/1Y6LHgXt/c14bde04cda2eb9b3c3f1da09dc6987b/Rx.Net.Action.Examples.Tamir.Dresher.31.pdf" target="_blank" rel="noopener">Rx.NET in Action.pdf</a><br><a href="http://reactivex.io/" target="_blank" rel="noopener">ReactiveX</a><br><a href="https://www.cnblogs.com/richieyang/p/4974630.html" target="_blank" rel="noopener">.Net中的反应式编程(Reactive Programming)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Rx.NET</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL递归查询知多少</title>
    <url>/post/how-much-you-know-about-the-recursive-query-in-sqlserver-and-oracle/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近工作中遇到了一个问题，需要根据保存的流程数据，构建流程图。数据库中保存的流程数据是树形结构的，表结构及数据如下图：</p>
<p><img src="/images/how-much-you-know-about-the-recursive-query-in-sqlserver-and-oracle/2799767-438a0621acbccd40.png" alt="流程表结构数据举例"></p>
<p>仔细观察表结构，会发现其树形结构的特点：</p>
<ul>
<li>FFIRSTNODE：标记是否为根节点</li>
<li>FSTABLENAME：标记来源单据名称</li>
<li>FSID：标记来源单据分录ID</li>
<li>FTTABLENAME ：标记目标单据名称</li>
<li>FTID：标记目标单据分录ID</li>
</ul>
<p>图中的流程为：<br><strong>销售合同–&gt;销售订单–&gt;发货通知单–&gt;销售出库单</strong></p>
<p>首先想到的办法就是把流程数据取回来，然后代码构造流程图。<br>第一个思路：根据根节点循环往下找，吭呲半天，发现没那么简单。<br>因为任何一个源头单据都可以多次下推目标单据：<br>第二个思路：先找到终极节点，在从终极节点往上找只至根节点为0。<br>这个思路实现起来也没有那么复杂，逻辑理清，循环遍历，最终也能实现结果。（但在大数据量情况下，易导致性能瓶颈。）</p>
<p>这一次我们换一个思路，让SQL来替我们做这一复杂的递归查询。</p>
<h1 id="SqlServer-递归查询"><a href="#SqlServer-递归查询" class="headerlink" title="SqlServer 递归查询"></a>SqlServer 递归查询</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote>
<p>公用表表达式 (CTE) 可以认为是在单个 SELECT、INSERT、UPDATE、DELETE 或 CREATE VIEW 语句的执行范围内定义的临时结果集。公用表表达式可以包括对自身的引用，这种表达式称为递归公用表表达式。</p>
</blockquote>
<ul>
<li>创建递归查询。有关详细信息，请参阅<a href="https://technet.microsoft.com/zh-cn/library/ms186243(v=sql.105).aspx" target="_blank" rel="noopener">使用公用表表达式的递归查询</a>。</li>
<li>在不需要常规使用视图时替换视图，也就是说，不必将定义存储在元数据中。</li>
<li>启用按从标量嵌套 select 语句派生的列进行分组，或者按不确定性函数或有外部访问的函数进行分组。</li>
<li>在同一语句中多次引用生成的表。</li>
</ul>
<p><a href="https://msdn.microsoft.com/zh-cn/library/ms175972.aspx" target="_blank" rel="noopener">MSDN上对CTE的介绍</a><br><a href="http://www.cnblogs.com/CareySon/archive/2011/12/12/2284740.html" target="_blank" rel="noopener">T-SQL查询进阶–详解公用表表达式(CTE)</a></p>
<p>CTE 的基本语法结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WITH expression_name [ ( column_name [,...n] ) ]</span><br><span class="line">AS</span><br><span class="line">( CTE_query_definition )</span><br><span class="line">--只有在查询定义中为所有结果列都提供了不同的名称时，列名称列表才是可选的。</span><br><span class="line">--运行 CTE 的语句为：</span><br><span class="line">SELECT &lt;column_list&gt; FROM expression_name;</span><br></pre></td></tr></table></figure>
<p>即三个部分：</p>
<ol>
<li>公用表表达式的名字（在WITH关键字之后）</li>
<li>查询的列名（可选）</li>
<li>紧跟AS之后的SELECT语句（<em>如果AS之后有多个对公用表的查询，则只有第一个查询有效</em>）</li>
</ol>
<h2 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a>动手实践</h2><p>根据官网示例我们很简单就可以写出CTE语句应用于我们的应用场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WITH TEST_CTE </span><br><span class="line">AS</span><br><span class="line">(</span><br><span class="line">SELECT TBIE.FSTABLENAME,TBIE.FSID,TBIE.FTTABLENAME,TBIE.FTID,TBIE.FROUTEID FROM T_BF_INSTANCEENTRY TBIE</span><br><span class="line">WHERE TBIE.FTTABLENAME &#x3D; &#39;T_SAL_ORDERENTRY&#39; AND TBIE.FTID &#x3D; 121625</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT CTBIE.FSTABLENAME,CTBIE.FSID,CTBIE.FTTABLENAME,CTBIE.FTID,CTBIE.FROUTEID  FROM T_BF_INSTANCEENTRY CTBIE</span><br><span class="line">INNER JOIN TEST_CTE CTE ON CTBIE.FSID&#x3D;CTE.FTID AND CTBIE.FSTABLENAME &#x3D; CTE.FTTABLENAME</span><br><span class="line">)</span><br><span class="line">SELECT * FROM TEST_CTE  </span><br><span class="line">--限制递归次数</span><br><span class="line">OPTION(MAXRECURSION 10)</span><br></pre></td></tr></table></figure>

<p>在查询中我们指定条件参数<code>WHERE TBIE.FTTABLENAME = &#39;T_SAL_ORDERENTRY&#39; AND TBIE.FTID = 121625</code>，即可查询到指定节点的完整流程数据。<br><em>其中在与公用表<code>TEST_CTE</code>进行关联时，我指定了两个条件<code>CTBIE.FSID=CTE.FTID AND CTBIE.FSTABLENAME = CTE.FTTABLENAME</code>，因为不同类型的单据各有一套自增的ID，直接用ID进行关联迭代不可行。</em></p>
<p><img src="/images/how-much-you-know-about-the-recursive-query-in-sqlserver-and-oracle/2799767-7ecb5971eca7ad7a.png" alt="查询结果"></p>
<p>需要注意的是<strong><code>OPTION(MAXRECURSION 10)</code></strong>是用来限制递归次数，以避免无限递归导致数据库性能消耗严重。</p>
<h2 id="扩展：构造递归路径"><a href="#扩展：构造递归路径" class="headerlink" title="扩展：构造递归路径"></a>扩展：构造递归路径</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WITH TEST_CTE </span><br><span class="line">AS</span><br><span class="line">(</span><br><span class="line">SELECT TBIE.FSTABLENAME,TBIE.FSID,TBIE.FTTABLENAME,TBIE.FTID,TBIE.FROUTEID,Cast(TBIE.FTID as nvarchar(4000)) AS PATH</span><br><span class="line">FROM T_BF_INSTANCEENTRY TBIE</span><br><span class="line">WHERE TBIE.FTTABLENAME &#x3D; &#39;T_SAL_ORDERENTRY&#39; AND TBIE.FTID &#x3D; 121625</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT CTBIE.FSTABLENAME,CTBIE.FSID,CTBIE.FTTABLENAME,CTBIE.FTID,CTBIE.FROUTEID,CTE.PATH+&#39;-&gt;&#39;+Cast(CTBIE.FTID as nvarchar(4000)) PATH  </span><br><span class="line">FROM T_BF_INSTANCEENTRY CTBIE</span><br><span class="line">INNER JOIN TEST_CTE CTE ON CTBIE.FSID&#x3D;CTE.FTID AND CTBIE.FSTABLENAME &#x3D; CTE.FTTABLENAME</span><br><span class="line">)</span><br><span class="line">SELECT * FROM TEST_CTE  </span><br><span class="line">--限制递归次数</span><br><span class="line">OPTION(MAXRECURSION 10)</span><br></pre></td></tr></table></figure>

<p>基于上一个查询，增加一列手动拼接递归路径。注意sql中将PATH设置的类型为navarchar(4000)，在union中，两边的表结构类型必须保持一致，否则会报错<code>定位点类型和递归部分的类型不匹配</code>。可参考此篇博文<br><a href="http://www.cnblogs.com/ccding13/p/3515393.html" target="_blank" rel="noopener">解决CTE定位点类型和递归部分的类型不匹配</a>。</p>
<p><img src="/images/how-much-you-know-about-the-recursive-query-in-sqlserver-and-oracle/2799767-82fc5de8bb634c3a.png" alt="递归路径查询结果"></p>
<h1 id="Oracle-递归查询"><a href="#Oracle-递归查询" class="headerlink" title="Oracle 递归查询"></a>Oracle 递归查询</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>Oracle中的递归查询语句为<code>start with…connect by prior</code>，为中序遍历算法。<br>可参考<a href="http://www.cnblogs.com/yingsong/p/5035907.html" target="_blank" rel="noopener">Oracle 树操作、递归查询(select…start with…connect by…prior)</a>了解更多。</p>
<p><img src="/images/how-much-you-know-about-the-recursive-query-in-sqlserver-and-oracle/2799767-7a6a047617d286e4.png" alt="查询顺序"></p>
<p>其基本语法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select colname from tablename</span><br><span class="line">start with 条件1</span><br><span class="line">connect by 条件2</span><br><span class="line">where 条件3;</span><br></pre></td></tr></table></figure>

<ul>
<li>条件1： 是根结点的限定语句，当然可以放宽限定条件，以遍历多个根结点，实际就是多棵树。</li>
<li>条件2：是连接条件，其中用<strong>PRIOR</strong>表示上一条记录。<br>比如<code>CONNECT BY PRIOR Id = Parent_Id</code>就是说<strong>上一条记录的Id 是本条记录的Parent_Id</strong>。</li>
<li>条件3：过滤返回的结果集。</li>
</ul>
<p><strong>PRIOR关键字</strong></p>
<p>运算符PRIOR被放置于等号前后的位置，决定着查询时的检索顺序。</p>
<ul>
<li>PRIOR被置于CONNECT BY子句中<strong>等号的前面</strong>时，则强制从根节点到叶节点的顺序检索，为<strong>自顶向下</strong>查找。<br>如：<code>CONNECT BY PRIOR Id=Parent_Id</code></li>
<li>PIROR运算符被置于CONNECT BY 子句中<strong>等号的后面</strong>时，则强制从叶节点到根节点的顺序检索，为<strong>自底向上的</strong>查找。<br>如：<code>CONNECT BY Id=PRIOR Parent_Id</code></li>
</ul>
<p><strong>PS：当CONNECT BY后指定多个连接条件时，每个条件都应指定<code>PRIOR</code>关键字</strong></p>
<h2 id="动手实践-1"><a href="#动手实践-1" class="headerlink" title="动手实践"></a>动手实践</h2><p>理清了用法，我们用Oracle来对查询一下业务流程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM T_BF_INSTANCEENTRY </span><br><span class="line">START WITH (FTID&#x3D;100501 AND FTTABLENAME &#x3D; &#39;T_SAL_ORDERENTRY&#39;)</span><br><span class="line">CONNECT BY  FSID&#x3D; PRIOR FTID AND FSTABLENAME &#x3D;PRIOR FTTABLENAME</span><br></pre></td></tr></table></figure>
<p><img src="/images/how-much-you-know-about-the-recursive-query-in-sqlserver-and-oracle/2799767-c1c7a780cbb60575.png" alt="查询结果"></p>
<p>该流程为：<strong>销售订单–&gt;发货通知单–&gt;销售出库单–&gt;退货通知单–&gt;销售退货单</strong><br><em>其中在指定连接条件时，我指定了两个条件<code>FSID= PRIOR FTID AND FSTABLENAME =PRIOR FTTABLENAME</code>，因为不同类型的单据各有一套自增的ID，直接用ID进行关联迭代不可行。</em></p>
<h2 id="扩展：构造递归路径-1"><a href="#扩展：构造递归路径-1" class="headerlink" title="扩展：构造递归路径"></a>扩展：构造递归路径</h2><p>Oracle中提供了<code>SYS_CONNECT_BY_PATH</code>函数用来进行连接路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT TBIE.*, SUBSTR(SYS_CONNECT_BY_PATH(FTID,&#39;-&gt;&#39;),3)  NAME_PATH FROM T_BF_INSTANCEENTRY TBIE</span><br><span class="line">START WITH (FTID&#x3D;100501 AND FTTABLENAME &#x3D; &#39;T_SAL_ORDERENTRY&#39;)</span><br><span class="line">CONNECT BY  FSID&#x3D; PRIOR FTID AND FSTABLENAME &#x3D;PRIOR FTTABLENAME</span><br></pre></td></tr></table></figure>
<p>基于上个查询，增加了一列<code>SUBSTR(SYS_CONNECT_BY_PATH(FTID,&#39;-&gt;&#39;),3)  NAME_PATH</code>用来拼接递归路径。</p>
<p><img src="/images/how-much-you-know-about-the-recursive-query-in-sqlserver-and-oracle/2799767-a2159ee0b27a72c7.png" alt="递归路径查询结果"></p>
<h2 id="显示当前节点的根节点"><a href="#显示当前节点的根节点" class="headerlink" title="显示当前节点的根节点"></a>显示当前节点的根节点</h2><p>这个时候我们要用到<code>connect_by_root</code>函数，用来记录当前节点的根节点信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT TBIE.*, SUBSTR(SYS_CONNECT_BY_PATH(FTID,&#39;-&gt;&#39;),3)NAME_PATH, (connect_by_root FTID) ROOT  FROM T_BF_INSTANCEENTRY TBIE</span><br><span class="line">START WITH (FTID&#x3D;100501 AND FTTABLENAME &#x3D; &#39;T_SAL_ORDERENTRY&#39;)</span><br><span class="line">CONNECT BY  FSID&#x3D; PRIOR FTID AND FSTABLENAME &#x3D;PRIOR FTTABLENAME</span><br></pre></td></tr></table></figure>

<p><img src="/images/how-much-you-know-about-the-recursive-query-in-sqlserver-and-oracle/2799767-1ed0676674ecdc51.png" alt="当前节点的根节点的查询结果"></p>
<h2 id="Oracle中的with…as语句"><a href="#Oracle中的with…as语句" class="headerlink" title="Oracle中的with…as语句"></a>Oracle中的with…as语句</h2><p>Oracle也有with..as 查询语法，一般用来进行子查询，提高查询效率。<br>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with tempTableName as ( select * from table1 )</span><br><span class="line">select * from tempTableName</span><br></pre></td></tr></table></figure>
<p>拿我们的案例举例就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with flow_temp as (</span><br><span class="line">SELECT TBIE.*, SUBSTR(SYS_CONNECT_BY_PATH(FTID,&#39;-&gt;&#39;),3)NAME_PATH, (connect_by_root FTID) ROOT  FROM T_BF_INSTANCEENTRY TBIE</span><br><span class="line">START WITH (FTID&#x3D;100501 AND FTTABLENAME &#x3D; &#39;T_SAL_ORDERENTRY&#39;)</span><br><span class="line">CONNECT BY  FSID&#x3D; PRIOR FTID AND FSTABLENAME &#x3D;PRIOR FTTABLENAME</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">select * from flow_temp</span><br></pre></td></tr></table></figure>

<p>为啥要讲这个呢，我们可以在oracle递归查询后进行筛选啊。</p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>UnitOfWork 知多少</title>
    <url>/post/how-much-you-know-about-the-unit-of-work/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><blockquote>
<p>Maintains a list of objects affected by a business transaction and coordinates the writing out of changes and the resolution of concurrency problems.<br> <em><a href="https://martinfowler.com/eaaCatalog/unitOfWork.html" target="_blank" rel="noopener">Unit of Work</a> –Martin Fowler</em></p>
</blockquote>
<p>Unit Of Work模式，由马丁大叔提出，是一种数据访问模式。UOW模式的作用是在业务用例的操作中跟踪对象的所有更改（增加、删除和更新），并将所有更改的对象保存在其维护的列表中。在业务用例的终点，通过事务，<strong>一次性提交所有更改</strong>，以确保数据的完整性和有效性。总而言之，UOW协调这些对象的持久化及并发问题。</p>
<h1 id="2-UOW的本质"><a href="#2-UOW的本质" class="headerlink" title="2. UOW的本质"></a>2. UOW的本质</h1><p>通过以上的介绍，我们可以总结出实现UOW的几个要点：</p>
<ol>
<li>UOW跟踪变化</li>
<li>UOW维护了一个变更列表</li>
<li>UOW将跟踪到的已变更的对象保存到变更列表中</li>
<li>UOW借助事务一次性提交变更列表中的所有更改</li>
<li>UOW处理并发</li>
</ol>
<p>而对于这些要点，EF中的DBContext已经实现了。</p>
<h1 id="3-EF中的UOW"><a href="#3-EF中的UOW" class="headerlink" title="3. EF中的UOW"></a>3. EF中的UOW</h1><p>每个<code>DbContext</code>类型实例都有一个<code>ChangeTracker</code>用来跟踪记录实体的变化。当调用<code>SaveChanges</code>时，所有的更改将通过事务一次性提交到数据库。</p>
<p>我们直接看个EF Core的测试用例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ApplicationDbContext InMemorySqliteTestDbContext</span><br><span class="line">&#123;</span><br><span class="line">    get</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; In-memory database only exists while the connection is open</span><br><span class="line">        var connection &#x3D; new SqliteConnection(&quot;DataSource&#x3D;:memory:&quot;);</span><br><span class="line">        connection.Open();</span><br><span class="line"></span><br><span class="line">        var options &#x3D; new DbContextOptionsBuilder&lt;ApplicationDbContext&gt;()</span><br><span class="line">            .UseSqlite(connection)</span><br><span class="line">            .Options;</span><br><span class="line"></span><br><span class="line">        var context &#x3D; new ApplicationDbContext(options);</span><br><span class="line">        context.Database.EnsureCreated();</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[Fact]</span><br><span class="line">public void Test_Ef_Implemented_Uow()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;新增用户</span><br><span class="line">    var user &#x3D; new ApplicationUser()</span><br><span class="line">    &#123;</span><br><span class="line">        UserName &#x3D; &quot;shengjie&quot;,</span><br><span class="line">        Email &#x3D; &quot;ysjshengjie@qq.com&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    InMemorySqliteTestDbContext.Users.Add(user);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建用户对应客户</span><br><span class="line">    var customer &#x3D; new Customer()</span><br><span class="line">    &#123;</span><br><span class="line">        ApplicationUser &#x3D; user,</span><br><span class="line">        NickName &#x3D; &quot;圣杰&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    InMemorySqliteTestDbContext.Customers.Add(customer);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加地址</span><br><span class="line">    var address &#x3D; new Address(&quot;广东省&quot;, &quot;深圳市&quot;, &quot;福田区&quot;, &quot;下沙街道&quot;, &quot;圣杰&quot;, &quot;135****9309&quot;);</span><br><span class="line"></span><br><span class="line">    InMemorySqliteTestDbContext.Addresses.Add(address);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;修改客户对象的派送地址</span><br><span class="line">    customer.AddShippingAddress(address);</span><br><span class="line"></span><br><span class="line">    InMemoryTestDbContext.Entry(customer).State &#x3D; EntityState.Modified;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;保存</span><br><span class="line">    var changes &#x3D; InMemorySqliteTestDbContext.SaveChanges();</span><br><span class="line"></span><br><span class="line">    Assert.Equal(3, changes);</span><br><span class="line"></span><br><span class="line">    var savedCustomer &#x3D; InMemorySqliteTestDbContext.Customers</span><br><span class="line">        .FirstOrDefault(c &#x3D;&gt; c.NickName &#x3D;&#x3D; &quot;圣杰&quot;);</span><br><span class="line"></span><br><span class="line">    Assert.Equal(&quot;shengjie&quot;, savedCustomer.ApplicationUser.UserName);</span><br><span class="line"></span><br><span class="line">    Assert.Equal(customer.ApplicationUserId, savedCustomer.ApplicationUserId);</span><br><span class="line"></span><br><span class="line">    Assert.Equal(1, savedCustomer.ShippingAddresses.Count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先这个用例是绿色通过的。该测试用例中我们添加了一个User，并为User创建对应的Customer，同时为Customer添加一条Address。从代码中我们可以看出仅做了一次保存，新增加的User、Customer、Address对象都成功持久化到了内存数据库中。从而证明EF Core是实现了Uow模式的。但很显然应用程序与基础设施层高度耦合，那如何解耦呢？继续往下看。</p>
<h1 id="4-DDD中的UOW"><a href="#4-DDD中的UOW" class="headerlink" title="4. DDD中的UOW"></a>4. DDD中的UOW</h1><p>那既然EF Core已经实现了Uow模式，我们还有必要自行实现一套Uow模式吗？这就视具体情况而定了，如果你的项目简单的增删改查就搞定了的，就不用折腾了。</p>
<p>在DDD中，我们会借助仓储模式来实现领域对象的持久化。仓储只关注于单一聚合的持久化，而业务用例却常常会涉及多个聚合的更改，为了确保业务用例的一致型，我们需要引入事务管理，而事务管理是应用服务层的关注点。我们如何在应用服务层来管理事务呢？借助UOW。这样就形成了一条链：Uow-&gt;仓储–&gt;聚合–&gt;实体和值对象。即Uow负责管理仓储处理事务，仓储管理单一聚合，聚合又由实体和值对象组成。</p>
<p>下面我们就先来定义实体和值对象，这里我们使用层超类型。</p>
<h2 id="4-1-定义实体"><a href="#4-1-定义实体" class="headerlink" title="4.1. 定义实体"></a>4.1. 定义实体</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; A shortcut of &lt;see cref&#x3D;&quot;IEntity&#123;TPrimaryKey&#125;&quot;&#x2F;&gt; for most used primary key type (&lt;see cref&#x3D;&quot;int&quot;&#x2F;&gt;).</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public interface IEntity : IEntity&lt;int&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; Defines interface for base entity type. All entities in the system must implement this interface.</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TPrimaryKey&quot;&gt;Type of the primary key of the entity&lt;&#x2F;typeparam&gt;</span><br><span class="line">public interface IEntity&lt;TPrimaryKey&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Unique identifier for this entity.</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    TPrimaryKey Id &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-定义聚合"><a href="#4-2-定义聚合" class="headerlink" title="4.2. 定义聚合"></a>4.2. 定义聚合</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace UnitOfWork</span><br><span class="line">&#123;</span><br><span class="line">    public interface IAggregateRoot : IAggregateRoot&lt;int&gt;, IEntity</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public interface IAggregateRoot&lt;TPrimaryKey&gt; : IEntity&lt;TPrimaryKey&gt;</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-定义泛型仓储"><a href="#4-3-定义泛型仓储" class="headerlink" title="4.3. 定义泛型仓储"></a>4.3. 定义泛型仓储</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace UnitOfWork</span><br><span class="line">&#123;</span><br><span class="line">    public interface IRepository&lt;TEntity&gt; : IRepository&lt;TEntity, int&gt;</span><br><span class="line">        where TEntity : class, IEntity, IAggregateRoot</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public interface IRepository&lt;TEntity, TPrimaryKey&gt;</span><br><span class="line">        where TEntity : class, IEntity&lt;TPrimaryKey&gt;, IAggregateRoot&lt;TPrimaryKey&gt;</span><br><span class="line">    &#123;        </span><br><span class="line">        IQueryable&lt;TEntity&gt; GetAll();</span><br><span class="line"></span><br><span class="line">        TEntity Get(TPrimaryKey id);</span><br><span class="line"></span><br><span class="line">        TEntity FirstOrDefault(TPrimaryKey id);</span><br><span class="line"></span><br><span class="line">        TEntity Insert(TEntity entity);</span><br><span class="line">        </span><br><span class="line">        TEntity Update(TEntity entity);</span><br><span class="line"></span><br><span class="line">        void Delete(TEntity entity);</span><br><span class="line"></span><br><span class="line">        void Delete(TPrimaryKey id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为仓储是管理聚合的，所以我们需要限制泛型参数为实现<code>IAggregateRoot</code>的类。</p>
<h2 id="4-4-实现泛型仓储"><a href="#4-4-实现泛型仓储" class="headerlink" title="4.4. 实现泛型仓储"></a>4.4. 实现泛型仓储</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">amespace UnitOfWork.Repositories</span><br><span class="line">&#123;</span><br><span class="line">    public class EfCoreRepository&lt;TEntity&gt;</span><br><span class="line">        : EfCoreRepository&lt;TEntity, int&gt;, IRepository&lt;TEntity&gt;</span><br><span class="line">        where TEntity : class, IEntity, IAggregateRoot</span><br><span class="line">    &#123;</span><br><span class="line">        public EfCoreRepository(UnitOfWorkDbContext dbDbContext) : base(dbDbContext)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class EfCoreRepository&lt;TEntity, TPrimaryKey&gt;</span><br><span class="line">        : IRepository&lt;TEntity, TPrimaryKey&gt;</span><br><span class="line">        where TEntity : class, IEntity&lt;TPrimaryKey&gt;, IAggregateRoot&lt;TPrimaryKey&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly UnitOfWorkDbContext _dbContext;</span><br><span class="line"></span><br><span class="line">        public virtual DbSet&lt;TEntity&gt; Table &#x3D;&gt; _dbContext.Set&lt;TEntity&gt;();</span><br><span class="line"></span><br><span class="line">        public EfCoreRepository(UnitOfWorkDbContext dbDbContext)</span><br><span class="line">        &#123;</span><br><span class="line">            _dbContext &#x3D; dbDbContext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public IQueryable&lt;TEntity&gt; GetAll()</span><br><span class="line">        &#123;</span><br><span class="line">            return Table.AsQueryable();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public TEntity Insert(TEntity entity)</span><br><span class="line">        &#123;</span><br><span class="line">            var newEntity &#x3D; Table.Add(entity).Entity;</span><br><span class="line">            _dbContext.SaveChanges();</span><br><span class="line">            return newEntity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public TEntity Update(TEntity entity)</span><br><span class="line">        &#123;</span><br><span class="line">            AttachIfNot(entity);</span><br><span class="line">            _dbContext.Entry(entity).State &#x3D; EntityState.Modified;</span><br><span class="line"></span><br><span class="line">            _dbContext.SaveChanges();</span><br><span class="line"></span><br><span class="line">            return entity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Delete(TEntity entity)</span><br><span class="line">        &#123;</span><br><span class="line">            AttachIfNot(entity);</span><br><span class="line">            Table.Remove(entity);</span><br><span class="line"></span><br><span class="line">           _dbContext.SaveChanges();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Delete(TPrimaryKey id)</span><br><span class="line">        &#123;</span><br><span class="line">            var entity &#x3D; GetFromChangeTrackerOrNull(id);</span><br><span class="line">            if (entity !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                Delete(entity);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            entity &#x3D; FirstOrDefault(id);</span><br><span class="line">            if (entity !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                Delete(entity);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected virtual void AttachIfNot(TEntity entity)</span><br><span class="line">        &#123;</span><br><span class="line">            var entry &#x3D; _dbContext.ChangeTracker.Entries().FirstOrDefault(ent &#x3D;&gt; ent.Entity &#x3D;&#x3D; entity);</span><br><span class="line">            if (entry !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Table.Attach(entity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private TEntity GetFromChangeTrackerOrNull(TPrimaryKey id)</span><br><span class="line">        &#123;</span><br><span class="line">            var entry &#x3D; _dbContext.ChangeTracker.Entries()</span><br><span class="line">                .FirstOrDefault(</span><br><span class="line">                    ent &#x3D;&gt;</span><br><span class="line">                        ent.Entity is TEntity &amp;&amp;</span><br><span class="line">                        EqualityComparer&lt;TPrimaryKey&gt;.Default.Equals(id, ((TEntity)ent.Entity).Id)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">            return entry?.Entity as TEntity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们直接使用EF Core进行持久化，所以我们直接通过构造函数初始化DbContex实例。同时，我们注意到<code>Insert、Update、Delete</code>方法都显式的调用了<code>SaveChanges</code>方法。</p>
<p>至此，我们完成了从实体到聚合再到仓储的定义和实现，万事俱备，只欠Uow。</p>
<h2 id="4-5-实现UOW"><a href="#4-5-实现UOW" class="headerlink" title="4.5. 实现UOW"></a>4.5. 实现UOW</h2><p>通过第3节的说明我们已经知道，EF Core已经实现了UOW模式。而为了确保领域层透明的进行持久化，我们对其进行了更高一层的抽象，实现了仓储模式。但这似乎引入了另外一个问题，因为仓储是管理单一聚合的，每次做增删改时都显式的提交了更改（调用了SaveChanges），在处理多个聚合时，就无法利用DbContext进行批量提交了。那该如何是好？一不做二不休，我们再对其进行一层抽象，抽离保存接口，这也就是Uow的核心接口方法。<br>我们抽离<code>SaveChanges</code>方法，定义<code>IUnitOfWork</code>接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace UnitOfWork</span><br><span class="line">&#123;</span><br><span class="line">    public interface IUnitOfWork</span><br><span class="line">    &#123;</span><br><span class="line">        int SaveChanges();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们是基于EFCore实现Uow的，所以我们只需要依赖DbContex，就可以实现批量提交。实现也很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace UnitOfWork</span><br><span class="line">&#123;</span><br><span class="line">    public class UnitOfWork&lt;TDbContext&gt; : IUnitOfWork where TDbContext : DbContext</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly TDbContext _dbContext;</span><br><span class="line"></span><br><span class="line">        public UnitOfWork(TDbContext context)</span><br><span class="line">        &#123;</span><br><span class="line">            _dbContext &#x3D; context ?? throw new ArgumentNullException(nameof(context));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int SaveChanges()</span><br><span class="line">        &#123;</span><br><span class="line">            return _dbContext.SaveChanges();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然Uow接手保存操作，自然我们需要：<strong>注释掉EfCoreRepository中Insert、Update、Delete方法中的显式保存调用<code>_dbContext.SaveChanges();</code></strong>。</p>
<p>那如何确保操作多个仓储时，最终能够一次性提交所有呢？</p>
<p><strong>确保Uow和仓储共用同一个DbContex即可</strong>。这个时候我们就可以借助依赖注入。</p>
<h2 id="4-6-依赖注入"><a href="#4-6-依赖注入" class="headerlink" title="4.6. 依赖注入"></a>4.6. 依赖注入</h2><p>我们直接使用.net core 提供的依赖注入，依次注入DbContext、UnitOfWork和Repository。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注入DbContext</span><br><span class="line">services.AddDbContext&lt;UnitOfWorkDbContext&gt;(</span><br><span class="line">    options &#x3D;&gt;options.UseSqlServer(</span><br><span class="line">    Configuration.GetConnectionString(&quot;DefaultConnection&quot;)));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注入Uow依赖</span><br><span class="line">services.AddScoped&lt;IUnitOfWork, UnitOfWork&lt;UnitOfWorkDbContext&gt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注入泛型仓储</span><br><span class="line">services.AddTransient(typeof(IRepository&lt;&gt;), typeof(EfCoreRepository&lt;&gt;));</span><br><span class="line">services.AddTransient(typeof(IRepository&lt;,&gt;), typeof(EfCoreRepository&lt;,&gt;));</span><br></pre></td></tr></table></figure>
<p>这里我们限定了DbContext和UnitOfWork的生命周期为<code>Scoped</code>，从而确保每次请求共用同一个对象。如何理解呢？就是<strong>整个调用链</strong>上的需要注入的同类型对象，使用是同一个类型实例。</p>
<h2 id="4-7-使用UOW"><a href="#4-7-使用UOW" class="headerlink" title="4.7. 使用UOW"></a>4.7. 使用UOW</h2><p>下面我们就来实际看一看如何使用UOW，我们定义一个应用服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace UnitOfWork.Customer</span><br><span class="line">&#123;</span><br><span class="line">    public class CustomerAppService : ICustomerAppService</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly IUnitOfWork _unitOfWork;</span><br><span class="line">        private readonly IRepository&lt;Customer&gt; _customerRepository;</span><br><span class="line">        private readonly IRepository&lt;ShoppingCart.ShoppingCart&gt; _shoppingCartRepository;</span><br><span class="line"></span><br><span class="line">        public CustomerAppService(IRepository&lt;ShoppingCart&gt; shoppingCartRepository, </span><br><span class="line">            IRepository&lt;Customer&gt; customerRepository, IUnitOfWork unitOfWork)</span><br><span class="line">        &#123;</span><br><span class="line">            _shoppingCartRepository &#x3D; shoppingCartRepository;</span><br><span class="line">            _customerRepository &#x3D; customerRepository;</span><br><span class="line">            _unitOfWork &#x3D; unitOfWork;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void CreateCustomer(Customer customer)</span><br><span class="line">        &#123;</span><br><span class="line">            _customerRepository.Insert(customer);&#x2F;&#x2F;创建客户</span><br><span class="line"></span><br><span class="line">            var cart &#x3D; new ShoppingCart.ShoppingCart() &#123;CustomerId &#x3D; customer.Id&#125;;</span><br><span class="line">            _shoppingCartRepository.Insert(cart);&#x2F;&#x2F;创建购物车</span><br><span class="line">            _unitOfWork.SaveChanges();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上案例，我们可以看出，我们只需要通过构造函数依赖注入需要的仓储和Uow即可完成对多个仓储的持久化操作。</p>
<h1 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h1><p>对于Uow模式，有很多种实现方式，大多过于复杂抽象。EF和EF Core本身已经实现了Uow模式，所以在实现时，我们应避免不必要的抽象来降低系统的复杂度。</p>
<p>最后，重申一下：<br><strong>Uow模式是用来管理仓储处理事务的，仓储用来解耦的（领域层与基础设施层）。而基于EF实现Uow模式的关键：确保Uow和Reopository之间共享同一个DbContext实例。</strong></p>
<p>最后附上基于.Net Core和EF Core实现的源码： <a href="https://github.com/yanshengjie/UnitOfWork" target="_blank" rel="noopener">GitHub–UnitOfWork</a></p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>UOW</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core + K8S + Apollo 玩转配置中心</title>
    <url>/post/use-apollo-with-netcore-on-k8s/</url>
    <content><![CDATA[<p><img src="/images/use-apollo-with-netcore-on-k8s/2799767-43736dd236959afc.png" alt=""></p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><blockquote>
<p>Apollo（阿波罗）是携程框架部门研发的分布式配置中心，能够集中化管理应用不同环境、不同集群的配置，配置修改后能够实时推送到应用端，并且具备规范的权限、流程治理等特性，适用于微服务配置管理场景。</p>
</blockquote>
<p>如官网所述：Apollo 是携程打造的开源配置中心，<a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">GitHub</a>的星星也快点满22K，因此足见它的成熟度和社区活跃度。因此最近在做配置中心选型的时候，经过一番预演，最终敲定Apollo。</p>
<p>Apollo作为微服务体系中必不可少的基础服务，其架构设计和基本使用我们不得不有所了解。</p>
<p>因此本文接下来将主要来介绍如何基于Helm快速部署Apollo集群至K8S，并与.NET Core应用进行集成，同时介绍下如何平滑迁移配置到Apollo。</p>
<p><strong>本文具有详细的部署步骤，建议动手实操。<br>部署Chart包和Demo已上传至GitHub：<a href="https://github.com/sheng-jie/dotnet.on.k8s/tree/master/K8S.NET.Apollo" target="_blank" rel="noopener">K8S.NET.Apollo</a>，可收藏备用。</strong></p>
<h1 id="2-Apollo-架构一览"><a href="#2-Apollo-架构一览" class="headerlink" title="2. Apollo 架构一览"></a>2. Apollo 架构一览</h1><p>在部署之前，需要了解Apollo的基础架构，以便在后续部署工作的展开。</p>
<p><img src="/images/use-apollo-with-netcore-on-k8s/2799767-f467670ed9cee888.png" alt="Apollo 总体设计"></p>
<p>关于其的解读，我这里就不再详细展开，但以下几点还是要有所了解，感兴趣的可以直接看官网详细介绍：<a href="https://github.com/ctripcorp/apollo/wiki/Apollo配置中心设计" target="_blank" rel="noopener">Apollo配置中心设计</a>。</p>
<ol>
<li>Config Service提供配置的读取、推送等功能，服务对象是Apollo客户端</li>
<li>Admin Service提供配置的修改、发布等功能，服务对象是Apollo Portal（管理界面）</li>
<li>Config Service和Admin Service都是多实例、无状态部署，需要通过注册中心进行服务注册和发现</li>
<li>注册中心默认采用的是Eureka，在K8S中由Service充当</li>
<li>Apollo客户端通过注册中心获取Config Service服务列表进行配置读取</li>
<li>Apollo Portal通过注册中心获取Admin Service服务列表进行配置管理</li>
</ol>
<p>基于上面对Apollo的介绍，其物理架构总结起来就是：</p>
<ol>
<li>每一套环境都必须拥有自己独立的Config Service 和 Admin Service 以及独立ConfigDB。</li>
<li>多套环境可以公用一套Apollo Portal 进行管理，Portal拥有独立PortalDB。</li>
</ol>
<h1 id="3-基于Helm部署到K8S"><a href="#3-基于Helm部署到K8S" class="headerlink" title="3. 基于Helm部署到K8S"></a>3. 基于Helm部署到K8S</h1><p>因为Apollo 1.7.0版本增加了基于Kubernetes原生服务发现的部署模式，来替换内置的Eureka，所以在整体部署上有很大简化，同时官方也提供了Helm Charts，让Apollo更加易于开箱即用。下面就以部署一套测试环境为例讲解一下Apollo的部署要点。（部署至本机Docker Desktop Local K8S环境）。</p>
<p><em>环境要求：  Kubernetes 1.10+，Helm 3</em></p>
<p><img src="/images/use-apollo-with-netcore-on-k8s/2799767-e92736ebe551b07b.png" alt=""></p>
<h2 id="3-1-搭建-Apollo-Config-amp-Portal-DB"><a href="#3-1-搭建-Apollo-Config-amp-Portal-DB" class="headerlink" title="3.1 搭建 Apollo Config&amp;Portal DB"></a>3.1 搭建 Apollo Config&amp;Portal DB</h2><p>从上图的物理架构上来看，首先要部署好Config DB和PortalDB。关于DB的搭建，建议直接使用<code>bitnami/mysql</code>chart搭建。搭建步骤如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; helm repo add bitnami https:&#x2F;&#x2F;charts.bitnami.com&#x2F;bitnami</span><br><span class="line">&gt; helm repo list</span><br><span class="line">&gt; helm repo update</span><br><span class="line">&gt; helm search repo bitnami&#x2F;mysql</span><br><span class="line">NAME            CHART VERSION   APP VERSION     DESCRIPTION</span><br><span class="line">bitnami&#x2F;mysql   6.14.8          8.0.21          Chart to create a Highly available MySQL cluster</span><br></pre></td></tr></table></figure>

<p>执行helm包的安装，需要自定义配置文件，也就是<code>values.yaml</code>。我们可以先行下载 mysql chart包。</p>
<blockquote>
<p>之所以选择将chart包下载到本地，是为了确保后续维护能够基于一致的chart包版本。避免因为执行<code>helm repo update</code>导致chart包版本自动升级，而不自知。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; helm pull bitnami&#x2F;mysql --untar  &#x2F;&#x2F;下载并解包</span><br><span class="line">mysql</span><br><span class="line"> ├── Chart.yaml</span><br><span class="line"> ├── ci</span><br><span class="line"> │   └── values-production.yaml</span><br><span class="line"> ├── files</span><br><span class="line"> │   └── docker-entrypoint-initdb.d</span><br><span class="line"> │       └── README.md</span><br><span class="line"> ├── README.md</span><br><span class="line"> ├── templates</span><br><span class="line"> │   ├── initialization-configmap.yaml</span><br><span class="line"> │   ├── master-configmap.yaml</span><br><span class="line"> │   ├── master-statefulset.yaml</span><br><span class="line"> │   ├── master-svc.yaml</span><br><span class="line"> │   ├── NOTES.txt</span><br><span class="line"> │   ├── secrets.yaml</span><br><span class="line"> │   ├── serviceaccount.yaml</span><br><span class="line"> │   ├── servicemonitor.yaml</span><br><span class="line"> │   ├── slave-configmap.yaml</span><br><span class="line"> │   ├── slave-statefulset.yaml</span><br><span class="line"> │   ├── slave-svc.yaml</span><br><span class="line"> │   └── _helpers.tpl</span><br><span class="line"> ├── values-production.yaml</span><br><span class="line"> └── values.yaml</span><br></pre></td></tr></table></figure>

<p>根据官网<a href="https://github.com/ctripcorp/apollo/wiki/分布式部署指南" target="_blank" rel="noopener">分布式部署指南</a>中所示，其提供了DB的初始化脚本用来分别创建<code>ApolloConfigDB</code>和<code>ApolloPortalDB</code>。因此可以直接将以上SQL脚本下载到mysql chart的<code>files/docker-entrypoint-initdb.d</code>目录下，这样在部署mysql实例时就会自动执行脚本创建数据库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; cd mysql&#x2F;files&#x2F;docker-entrypoint-initdb.d</span><br><span class="line">&gt; curl https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ctripcorp&#x2F;apollo&#x2F;master&#x2F;scripts&#x2F;sql&#x2F;apolloportaldb.sql &gt; apolloportaldb.sql &#x2F;&#x2F;下载apolloportaldb.sql</span><br><span class="line">&gt; curl https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ctripcorp&#x2F;apollo&#x2F;master&#x2F;scripts&#x2F;sql&#x2F;apolloconfigdb.sql &gt; apolloconfigdb.sql 下载apolloconfigdb.sql</span><br><span class="line">&gt; ls</span><br><span class="line"></span><br><span class="line">    Directory: C:\Users\Shengjie\k8s\helm\charts\apollo\mysql\files\docker-entrypoint-initdb.d</span><br><span class="line"></span><br><span class="line">Mode                 LastWriteTime         Length Name</span><br><span class="line">----                 -------------         ------ ----</span><br><span class="line">-a---           8&#x2F;12&#x2F;2020 11:01 PM          21291 apolloconfigdb.sql</span><br><span class="line">-a---           8&#x2F;12&#x2F;2020 10:56 PM          16278 apolloportaldb.sql</span><br><span class="line">-a---            8&#x2F;9&#x2F;2020  6:26 PM            242 README.md</span><br></pre></td></tr></table></figure>

<p>然后复制<code>values.yaml</code>并命名为<code>dev-mysql-values.yaml</code>。然后修改核心配置：</p>
<ol>
<li>global.storageClass=hostpath<br>可通过<code>kubectl get sc</code>查看集群支持的storageClass，我这边选择默认的hostpath。其创建的pv的默认回收策略为delete，也就意味着卸载mysql，数据直接删除，这点需要注意！！！如果需要保留测试数据，请更新storageClass。</li>
<li>root.password=root<br>修改默认root用户的密码</li>
</ol>
<p>修改完毕后，执行以下脚本进行安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; kubectl create ns db #创建单独db命名空间</span><br><span class="line">&gt; helm install mysql-apollo . -f dev-mysql-values.yaml -n db</span><br><span class="line">NAME: mysql-apollo</span><br><span class="line">LAST DEPLOYED: Sun Aug 16 11:01:18 2020</span><br><span class="line">NAMESPACE: db</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">TEST SUITE: None</span><br><span class="line">NOTES:</span><br><span class="line">Please be patient while the chart is being deployed</span><br><span class="line"></span><br><span class="line">Tip:</span><br><span class="line"></span><br><span class="line">  Watch the deployment status using the command: kubectl get pods -w --namespace db</span><br><span class="line"></span><br><span class="line">Services:</span><br><span class="line"></span><br><span class="line">  echo Master: mysql-apollo.db.svc.cluster.local:3306</span><br><span class="line">  echo Slave:  mysql-apollo-slave.db.svc.cluster.local:3306</span><br><span class="line"></span><br><span class="line">Administrator credentials:</span><br><span class="line"></span><br><span class="line">  echo Username: root</span><br><span class="line">  echo Password : $(kubectl get secret --namespace db mysql-apollo -o jsonpath&#x3D;&quot;&#123;.data.mysql-root-password&#125;&quot; | base64 --decode)</span><br><span class="line"></span><br><span class="line">To connect to your database:</span><br><span class="line"></span><br><span class="line">  1. Run a pod that you can use as a client:</span><br><span class="line"></span><br><span class="line">      kubectl run mysql-apollo-client --rm --tty -i --restart&#x3D;&#39;Never&#39; --image  docker.io&#x2F;bitnami&#x2F;mysql:8.0.21-debian-10-r17 --namespace db --command -- bash</span><br><span class="line"></span><br><span class="line">  2. To connect to master service (read&#x2F;write):</span><br><span class="line"></span><br><span class="line">      mysql -h mysql-apollo.db.svc.cluster.local -uroot -p my_database</span><br><span class="line"></span><br><span class="line">  3. To connect to slave service (read-only):</span><br><span class="line"></span><br><span class="line">      mysql -h mysql-apollo-slave.db.svc.cluster.local -uroot -p my_database</span><br><span class="line"></span><br><span class="line">To upgrade this helm chart:</span><br><span class="line"></span><br><span class="line">  1. Obtain the password as described on the &#39;Administrator credentials&#39; section and set the &#39;root.password&#39; parameter as shown below:</span><br><span class="line"></span><br><span class="line">      ROOT_PASSWORD&#x3D;$(kubectl get secret --namespace db mysql-apollo -o jsonpath&#x3D;&quot;&#123;.data.mysql-root-password&#125;&quot; | base64 --decode)</span><br><span class="line">      helm upgrade mysql-apollo bitnami&#x2F;mysql --set root.password&#x3D;$ROOT_PASSWORD</span><br></pre></td></tr></table></figure>

<p>按照上面提示，验证数据库成功创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; kubectl run mysql-apollo-client --rm --tty -i --restart&#x3D;&#39;Never&#39; --image  docker.io&#x2F;bitnami&#x2F;mysql:8.0.21-debian-10-r17 </span><br><span class="line">--namespace db --command -- bash  # 创建mysql-client pod</span><br><span class="line">I have no name!@mysql-apollo-client:&#x2F;$ mysql -h mysql-apollo.db.svc.cluster.local -uroot -proot    # 连接至master 节点    </span><br><span class="line">mysql: [Warning] Using a password on the command line interface can be insecure.</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 61</span><br><span class="line">Server version: 8.0.21 Source distribution</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2020, Oracle and&#x2F;or its affiliates. All rights reserved.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and&#x2F;or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type &#39;help;&#39; or &#39;\h&#39; for help. Type &#39;\c&#39; to clear the current input statement.</span><br><span class="line"></span><br><span class="line">mysql&gt; show databases; # 查看databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| ApolloConfigDB     |</span><br><span class="line">| ApolloPortalDB     |</span><br><span class="line">| information_schema |</span><br><span class="line">| my_database        |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">7 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; use ApolloConfigDB; # 切换至ApolloConfigDB；</span><br><span class="line">Reading table information for completion of table and column names</span><br><span class="line">You can turn off this feature to get a quicker startup with -A</span><br><span class="line"></span><br><span class="line">Database changed</span><br><span class="line">mysql&gt; show tables;  # 查看数据表；</span><br><span class="line">+--------------------------+</span><br><span class="line">| Tables_in_ApolloConfigDB |</span><br><span class="line">+--------------------------+</span><br><span class="line">| AccessKey                |</span><br><span class="line">| App                      |</span><br><span class="line">| AppNamespace             |</span><br><span class="line">| Audit                    |</span><br><span class="line">| Cluster                  |</span><br><span class="line">| Commit                   |</span><br><span class="line">| GrayReleaseRule          |</span><br><span class="line">| Instance                 |</span><br><span class="line">| InstanceConfig           |</span><br><span class="line">| Item                     |</span><br><span class="line">| Namespace                |</span><br><span class="line">| NamespaceLock            |</span><br><span class="line">| Release                  |</span><br><span class="line">| ReleaseHistory           |</span><br><span class="line">| ReleaseMessage           |</span><br><span class="line">| ServerConfig             |</span><br><span class="line">+--------------------------+</span><br><span class="line">16 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>至此，确认Apollo ConfigDB和PortalDB搭建成功。</p>
<h2 id="3-2-搭建-Apollo-Config-Service"><a href="#3-2-搭建-Apollo-Config-Service" class="headerlink" title="3.2 搭建 Apollo Config Service"></a>3.2 搭建 Apollo Config Service</h2><p>搭建Apollo Service 需要添加携程官方chart仓库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; helm repo add apollo http:&#x2F;&#x2F;ctripcorp.github.io&#x2F;apollo&#x2F;charts</span><br><span class="line">&gt; helm search repo apollo</span><br><span class="line">NAME                    CHART VERSION   APP VERSION     DESCRIPTION</span><br><span class="line">apollo&#x2F;apollo-portal    0.1.0           1.7.0           A Helm chart for Apollo Portal</span><br><span class="line">apollo&#x2F;apollo-service   0.1.0           1.7.0           A Helm chart for Apollo Config Service and Apol...</span><br></pre></td></tr></table></figure>
<p>从上可知，主要包含两个chart，分别用来部署service和portal。下来研究下apollo/apollo-service 这个chart。老规矩，先把chart包下载下来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; helm pull apollo&#x2F;apollo-service --untar</span><br><span class="line">apollo-service</span><br><span class="line"> ├── Chart.yaml</span><br><span class="line"> ├── templates</span><br><span class="line"> │   ├── deployment-adminservice.yaml</span><br><span class="line"> │   ├── deployment-configservice.yaml</span><br><span class="line"> │   ├── NOTES.txt</span><br><span class="line"> │   ├── service-adminservice.yaml</span><br><span class="line"> │   ├── service-configdb.yaml</span><br><span class="line"> │   ├── service-configservice.yaml</span><br><span class="line"> │   └── _helpers.tpl</span><br><span class="line"> └── values.yaml</span><br></pre></td></tr></table></figure>

<p>从上面的树形图来看，主要就是用来部署config service 和 admin service。紧接着，复制一个<code>values.yaml</code>，命名为<code>dev-apollo-svc-values.yaml</code>。主要修改以下配置：</p>
<ol>
<li>configdb.host=mysql-apollo.db<br>指定configdb的主机，因为是在集群内部，直接使用服务名即可</li>
<li>configdb.password=root<br>指定configdb的秘密</li>
</ol>
<p>修改后的配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">configdb:</span><br><span class="line">  name: apollo-configdb</span><br><span class="line">  # apolloconfigdb host</span><br><span class="line">  host: &quot;mysql-apollo.db&quot;</span><br><span class="line">  port: 3306</span><br><span class="line">  dbName: ApolloConfigDB</span><br><span class="line">  # apolloconfigdb user name</span><br><span class="line">  userName: &quot;root&quot;</span><br><span class="line">  # apolloconfigdb password</span><br><span class="line">  password: &quot;root&quot;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>其他配置可以暂定不动，紧接着执行以下命令进行安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; kubectl create ns apollo # 创建apollo 命名空间</span><br><span class="line">&gt; helm install --dry-run --debug apollo-dev-svc . -f dev-apollo-svc-values.yaml -n apollo # 测试安装，验证模板生成的资源文件是否有误</span><br><span class="line">&gt; helm install apollo-dev-svc . -f dev-apollo-svc-values.yaml -n apollo</span><br><span class="line">NAME: apollo-dev-svc</span><br><span class="line">LAST DEPLOYED: Sun Aug 16 11:17:38 2020</span><br><span class="line">NAMESPACE: apollo</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">TEST SUITE: None</span><br><span class="line">NOTES:</span><br><span class="line">Get meta service url for current release by running these commands:</span><br><span class="line">  echo http:&#x2F;&#x2F;apollo-dev-svc-apollo-configservice.apollo:8080      </span><br><span class="line"></span><br><span class="line">For local test use:</span><br><span class="line">  export POD_NAME&#x3D;$(kubectl get pods --namespace apollo -l &quot;app&#x3D;apollo-dev-svc-apollo-configservice&quot; -o jsonpath&#x3D;&quot;&#123;.items[0].metadata.name&#125;&quot;)</span><br><span class="line">  echo http:&#x2F;&#x2F;127.0.0.1:8080</span><br><span class="line">  kubectl --namespace apollo port-forward $POD_NAME 8080:8080</span><br></pre></td></tr></table></figure>
<p>这里要记住上面的meta service url：<code>http://apollo-dev-svc-apollo-configservice.apollo:8080</code></p>
<p>那如何确认正确部署了呢：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; kubectl get all -n apollo # 查看apollo命名空间下部署的资源</span><br><span class="line">NAME                                                       READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod&#x2F;apollo-dev-svc-apollo-adminservice-7d4468ff46-gw6h4    1&#x2F;1     Running   0          3m26s</span><br><span class="line">pod&#x2F;apollo-dev-svc-apollo-configservice-58d6c44cd4-n4qk9   1&#x2F;1     Running   0          3m26s</span><br><span class="line"></span><br><span class="line">NAME                                          TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">service&#x2F;apollo-dev-svc-apollo-adminservice    ClusterIP   10.99.251.14     &lt;none&gt;        8090&#x2F;TCP   3m26s</span><br><span class="line">service&#x2F;apollo-dev-svc-apollo-configservice   ClusterIP   10.108.121.201   &lt;none&gt;        8080&#x2F;TCP   3m26s</span><br><span class="line"></span><br><span class="line">NAME                                                  READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps&#x2F;apollo-dev-svc-apollo-adminservice    1&#x2F;1     1            1           3m26s</span><br><span class="line">deployment.apps&#x2F;apollo-dev-svc-apollo-configservice   1&#x2F;1     1            1           3m26s</span><br><span class="line"></span><br><span class="line">NAME                                                             DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps&#x2F;apollo-dev-svc-apollo-adminservice-7d4468ff46    1         1         1       3m26s</span><br><span class="line">replicaset.apps&#x2F;apollo-dev-svc-apollo-configservice-58d6c44cd4   1         1         1       3m26s</span><br></pre></td></tr></table></figure>
<p>从上可知暴露了两个服务configservice和adminservice，来尝试将configservice进行端口转发到本地端口来看一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; kubectl port-forward service&#x2F;apollo-dev-svc-apollo-configservice 8080:8080 -n apollo # 转发configservice到本地服务</span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 8080</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 8080</span><br></pre></td></tr></table></figure>
<p>使用浏览器访问 <a href="http://localhost:8080" target="_blank" rel="noopener">localhost:8080</a>，可以看到输出<code>[{&quot;appName&quot;:&quot;apollo-configservice&quot;,&quot;instanceId&quot;:&quot;apollo-configservice:http://apollo.shisheng.wang/config-svc&quot;,&quot;homepageUrl&quot;:&quot;http://apollo.shisheng.wang/config-svc&quot;},{&quot;appName&quot;:&quot;apollo-adminservice&quot;,&quot;instanceId&quot;:&quot;apollo-adminservice:http://apollo.shisheng.wang/admin-svc&quot;,&quot;homepageUrl&quot;:&quot;http://apollo.shisheng.wang/admin-svc&quot;}]</code>。</p>
<p>至此说明，Apollo Service 搭建成功。</p>
<h2 id="3-3-搭建-Apollo-Portal-Service"><a href="#3-3-搭建-Apollo-Portal-Service" class="headerlink" title="3.3 搭建 Apollo Portal Service"></a>3.3 搭建 Apollo Portal Service</h2><p>同样，先来下载portal chart包，并研究下目录结构：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; helm pull apollo&#x2F;apollo-portal --untar</span><br><span class="line">apollo-portal</span><br><span class="line"> ├── Chart.yaml</span><br><span class="line"> ├── templates</span><br><span class="line"> │   ├── deployment-portal.yaml</span><br><span class="line"> │   ├── ingress-portal.yaml</span><br><span class="line"> │   ├── NOTES.txt</span><br><span class="line"> │   ├── service-portal.yaml</span><br><span class="line"> │   ├── service-portaldb.yaml</span><br><span class="line"> │   └── _helpers.tpl</span><br><span class="line"> └── values.yaml</span><br></pre></td></tr></table></figure>
<p>从上可知，portal 相对来说，主要是构建portal服务，并可以通过ingress暴露服务。复制一个<code>values.yaml</code>，命名为<code>dev-apollo-portal-values.yaml</code>。主要修改以下配置：</p>
<ol>
<li><code>ingress.enabled=true</code><br>启用ingress，并通过注解设置ingress controller，因为portal是个有状态服务，所以要关注Sessiion状态维持。以下主要是针对nginx-ingress-controller的配置，如果使用的其他的ingress-controller请注意更改。（nginx-ingress-controller的安装，这里就不具体展开了，可以简单执行<code>helm install nginx bitnaim/nginx-ingress-controller</code> 安装就好了。）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ingress:</span><br><span class="line">  enabled: true</span><br><span class="line">  annotations:</span><br><span class="line">    kubernetes.io&#x2F;ingress.class: nginx</span><br><span class="line">    nginx.ingress.kubernetes.io&#x2F;rewrite-target: &#x2F;</span><br><span class="line">    nginx.ingress.kubernetes.io&#x2F;affinity: &quot;cookie&quot;</span><br><span class="line">    nginx.ingress.kubernetes.io&#x2F;session-cookie-name: &quot;route&quot;</span><br><span class="line">  hosts:</span><br><span class="line">    - host: &quot;apollo.demo.com&quot;</span><br><span class="line">      paths: [&quot;&#x2F;&quot;]</span><br><span class="line">  tls: []</span><br></pre></td></tr></table></figure></li>
<li>指定配置源 ，主要是envs和metaServers两个配置项：<br><code>config.envs=dev</code><br><code>config.metaServers.dev=http://apollo-dev-svc-apollo-configservice.apollo:8080</code>（上面部署apollo service输出的apollo service url）<em>如果同时启用开发、测试和生产环境。可以配置为：<code>envs: &quot;dev,uat,prd&quot;</code>，metaServers 分别指定对应环境的配置即可。</em><br>以下是只启用开发环境的配置：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">config:</span><br><span class="line">  # spring profiles to activate</span><br><span class="line">  profiles: &quot;github,auth&quot;</span><br><span class="line">  # specify the env names, e.g. dev,pro</span><br><span class="line">  envs: &quot;dev&quot;</span><br><span class="line">  # specify the meta servers, e.g.</span><br><span class="line">  # dev: http:&#x2F;&#x2F;apollo-configservice-dev:8080</span><br><span class="line">  # pro: http:&#x2F;&#x2F;apollo-configservice-pro:8080</span><br><span class="line">  metaServers: </span><br><span class="line">    dev: http:&#x2F;&#x2F;apollo-svc-dev-apollo-configservice.apollo:8080</span><br><span class="line">    # dev: http:&#x2F;&#x2F;apollo.shisheng.wang</span><br><span class="line">  # specify the context path, e.g. &#x2F;apollo</span><br><span class="line">  contextPath: &quot;&quot;</span><br><span class="line">  # extra config files for apollo-portal, e.g. application-ldap.yml</span><br><span class="line">  files: &#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>portaldb.host=mysql-apollo.db &amp; portaldb.password=root<br>指定portaldb的主机和密码<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">portaldb:</span><br><span class="line">  name: apollo-portaldb</span><br><span class="line">  # apolloportaldb host</span><br><span class="line">  host: mysql-apollo.db</span><br><span class="line">  port: 3306</span><br><span class="line">  dbName: ApolloPortalDB</span><br><span class="line">  # apolloportaldb user name</span><br><span class="line">  userName: root</span><br><span class="line">  # apolloportaldb password</span><br><span class="line">  password: root</span><br></pre></td></tr></table></figure>
其他配置可以暂定不动，紧接着执行以下命令进行安装：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; Helm install --dry-run --debug apollo-dev-portal . -f dev-apollo-portal-values.yaml -n apollo # 测试安装，验证模板生成的资源文件是否有误</span><br><span class="line">&gt; Helm install apollo-dev-portal . -f dev-apollo-portal-values.yaml -n apollo</span><br><span class="line">PS C:\Users\Shengjie\k8s\helm\charts\apollo\apollo-portal&gt; Helm install apollo-dev-portal . -f dev-apollo-portal-values.yaml -n apollo</span><br><span class="line">NAME: apollo-dev-portal</span><br><span class="line">LAST DEPLOYED: Sun Aug 16 11:53:18 2020</span><br><span class="line">NAMESPACE: apollo</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">TEST SUITE: None</span><br><span class="line">NOTES:</span><br><span class="line">Get apollo portal url by running these commands:</span><br><span class="line">  http:&#x2F;&#x2F;apollo.demo.com&#x2F;</span><br></pre></td></tr></table></figure>
到这一步，如果需要本地可以访问，还需要修改本地hosts，添加<code>127.0.0.1 apollo.demo.com</code>。然后打开你的Browser输入<a href="http://apollo.demo.com/" target="_blank" rel="noopener">http://apollo.demo.com/</a>，就可以访问了。默认用户密码是：[apollo/admin]。<br><img src="/images/use-apollo-with-netcore-on-k8s/2799767-021717d0f5f8392c.png" alt="apollo login page"></li>
</ol>
<h2 id="3-4-暴露-config-service"><a href="#3-4-暴露-config-service" class="headerlink" title="3.4 暴露 config service"></a>3.4 暴露 config service</h2><p>以上部署的是开发环境，但要想开发环境要访问到config service，我们还需要些小动作。这个时候就需要修改apollo service的chart模板，在<code>template</code>目录增加<code>ingress-configservice.yaml</code>文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># ingress-configservice.yaml</span><br><span class="line">&#123;&#123;- if .Values.configService.ingress.enabled -&#125;&#125;</span><br><span class="line">&#123;&#123;- $fullName :&#x3D; include &quot;apollo.configService.fullName&quot; . -&#125;&#125;</span><br><span class="line">&#123;&#123;- $svcPort :&#x3D; .Values.configService.service.port -&#125;&#125;</span><br><span class="line">&#123;&#123;- if semverCompare &quot;&gt;&#x3D;1.14-0&quot; .Capabilities.KubeVersion.GitVersion -&#125;&#125;</span><br><span class="line">apiVersion: networking.k8s.io&#x2F;v1beta1</span><br><span class="line">&#123;&#123;- else -&#125;&#125;</span><br><span class="line">apiVersion: extensions&#x2F;v1beta1</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: &#123;&#123; $fullName &#125;&#125;</span><br><span class="line">  labels:</span><br><span class="line">    &#123;&#123;- include &quot;apollo.service.labels&quot; . | nindent 4 &#125;&#125;</span><br><span class="line">  &#123;&#123;- with .Values.configService.ingress.annotations &#125;&#125;</span><br><span class="line">  annotations:</span><br><span class="line">    &#123;&#123;- toYaml . | nindent 4 &#125;&#125;</span><br><span class="line">  &#123;&#123;- end &#125;&#125;</span><br><span class="line">spec:</span><br><span class="line">&#123;&#123;- if .Values.configService.ingress.tls &#125;&#125;</span><br><span class="line">  tls:</span><br><span class="line">  &#123;&#123;- range .Values.configService.ingress.tls &#125;&#125;</span><br><span class="line">    - hosts:</span><br><span class="line">      &#123;&#123;- range .hosts &#125;&#125;</span><br><span class="line">        - &#123;&#123; . | quote &#125;&#125;</span><br><span class="line">      &#123;&#123;- end &#125;&#125;</span><br><span class="line">      secretName: &#123;&#123; .secretName &#125;&#125;</span><br><span class="line">  &#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br><span class="line">  rules:</span><br><span class="line">  &#123;&#123;- range .Values.configService.ingress.hosts &#125;&#125;</span><br><span class="line">    - host: &#123;&#123; .host | quote &#125;&#125;</span><br><span class="line">      http:</span><br><span class="line">        paths:</span><br><span class="line">        &#123;&#123;- range .paths &#125;&#125;</span><br><span class="line">          - path: &#123;&#123; . &#125;&#125;</span><br><span class="line">            backend:</span><br><span class="line">              serviceName: &#123;&#123; $fullName &#125;&#125;</span><br><span class="line">              servicePort: &#123;&#123; $svcPort &#125;&#125;</span><br><span class="line">        &#123;&#123;- end &#125;&#125;</span><br><span class="line">  &#123;&#123;- end &#125;&#125;</span><br><span class="line">&#123;&#123;- end &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改<code>values.yaml</code>在<code>configService</code>节点下增加<code>ingress</code>配置选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">configService:</span><br><span class="line">  name: apollo-configservice</span><br><span class="line">  fullNameOverride: &quot;&quot;</span><br><span class="line">  replicaCount: 2</span><br><span class="line">  containerPort: 8080</span><br><span class="line">  image:</span><br><span class="line">    repository: apolloconfig&#x2F;apollo-configservice</span><br><span class="line">    pullPolicy: IfNotPresent</span><br><span class="line">  imagePullSecrets: []</span><br><span class="line">  service:</span><br><span class="line">    fullNameOverride: &quot;&quot;</span><br><span class="line">    port: 8080</span><br><span class="line">    targetPort: 8080</span><br><span class="line">    type: ClusterIP</span><br><span class="line">  # 以下为新增ingress配置项  </span><br><span class="line">  ingress:</span><br><span class="line">    enabled: false</span><br><span class="line">    annotations: &#123;&#125;</span><br><span class="line">    hosts:</span><br><span class="line">      - host: &quot;&quot;</span><br><span class="line">        paths: []</span><br><span class="line">    tls: []</span><br></pre></td></tr></table></figure>

<p>然后再修改上面我们创建的<code>dev-apollo-svc-values.yaml</code>下的<code>configService</code>节点，添加对应<code>ingress</code>和<code>config.configServiceUrlOverride</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">configService:</span><br><span class="line">  name: apollo-configservice</span><br><span class="line">  fullNameOverride: &quot;&quot;</span><br><span class="line">  replicaCount: 1</span><br><span class="line">  containerPort: 8080</span><br><span class="line">  image:</span><br><span class="line">    repository: apolloconfig&#x2F;apollo-configservice</span><br><span class="line">    pullPolicy: IfNotPresent</span><br><span class="line">  imagePullSecrets: []</span><br><span class="line">  service:</span><br><span class="line">    fullNameOverride: &quot;&quot;</span><br><span class="line">    port: 8080</span><br><span class="line">    targetPort: 8080</span><br><span class="line">    type: ClusterIP</span><br><span class="line">  ingress:</span><br><span class="line">    enabled: true</span><br><span class="line">    annotations:</span><br><span class="line">      kubernetes.io&#x2F;ingress.class: nginx</span><br><span class="line">      nginx.ingress.kubernetes.io&#x2F;rewrite-target: &#x2F;$2</span><br><span class="line">    hosts:</span><br><span class="line">      - host: &quot;apollo.demo.com&quot;</span><br><span class="line">        paths: [&quot;&#x2F;config-svc(&#x2F;|$)(.*)&quot;]</span><br><span class="line">    tls: []</span><br><span class="line">  liveness:</span><br><span class="line">    initialDelaySeconds: 100</span><br><span class="line">    periodSeconds: 10</span><br><span class="line">  readiness:</span><br><span class="line">    initialDelaySeconds: 30</span><br><span class="line">    periodSeconds: 5</span><br><span class="line">  config:</span><br><span class="line">    # spring profiles to activate</span><br><span class="line">    profiles: &quot;github,kubernetes&quot;</span><br><span class="line">    # override apollo.config-service.url: config service url to be accessed by apollo-client</span><br><span class="line">    configServiceUrlOverride: &quot;http:&#x2F;&#x2F;apollo.demo.com&#x2F;config-svc&quot;</span><br><span class="line">    # override apollo.admin-service.url: admin service url to be accessed by apollo-portal</span><br><span class="line">    adminServiceUrlOverride: &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>修改完毕，执行以下命令升级apollo service：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; helm upgrade apollo-service-dev . -f dev-apollo-svc-values.yaml -n apollo</span><br><span class="line">NAME: apollo-service-dev</span><br><span class="line">LAST DEPLOYED: Tue Aug 18 14:20:41 2020</span><br><span class="line">NAMESPACE: apollo</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">TEST SUITE: None</span><br><span class="line">NOTES:</span><br><span class="line">Get meta service url for current release by running these commands:</span><br><span class="line">  echo http:&#x2F;&#x2F;apollo-service-dev-apollo-configservice.apollo:8080</span><br><span class="line"></span><br><span class="line">For local test use:</span><br><span class="line">  export POD_NAME&#x3D;$(kubectl get pods --namespace apollo -l &quot;app&#x3D;apollo-service-dev-apollo-configservice&quot; -o jsonpath&#x3D;&quot;&#123;.items[0].metadata.name&#125;&quot;)</span><br><span class="line">  echo http:&#x2F;&#x2F;127.0.0.1:8080</span><br><span class="line">  kubectl --namespace apollo port-forward $POD_NAME 8080:8080</span><br><span class="line">&gt; curl http:&#x2F;&#x2F;apollo.demo.com&#x2F;config-svc</span><br><span class="line">[&#123;&quot;appName&quot;:&quot;apollo-configservice&quot;,&quot;instanceId&quot;:&quot;apollo-configservice:http:&#x2F;&#x2F;apollo.demo.com&#x2F;config-svc&quot;,&quot;homepageUrl&quot;:&quot;http:&#x2F;&#x2F;apollo.demo.com&#x2F;config-svc&quot;&#125;,&#123;&quot;appName&quot;:&quot;apollo-adminservice&quot;,&quot;instanceId&quot;:&quot;apollo-adminservice:http:&#x2F;&#x2F;apollo-service-dev-apollo-adminservice.apollo:8090&quot;,&quot;homepageUrl&quot;:&quot;http:&#x2F;&#x2F;apollo-service-dev-apollo-adminservice.apollo:8090&quot;&#125;]</span><br></pre></td></tr></table></figure>
<p>从上面的输出可以看到，现在已经可以通过<code>http://apollo.demo.com/config-svc</code>读取metaServer配置了，后面本地开发环境就可以通过这个链接来读取Apollo的配置。</p>
<h1 id="4-NET-Core-集成Apollo"><a href="#4-NET-Core-集成Apollo" class="headerlink" title="4. .NET Core 集成Apollo"></a>4. .NET Core 集成Apollo</h1><p>这一部分我就快速带过了，执行以下命令创建项目，并引入<code>apollo</code>和<code>swagger</code>相关包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; dotnet new webapi -n K8S.NET.Apollo</span><br><span class="line">&gt; cd K8S.NET.Apollo</span><br><span class="line">&gt; dotnet add package Com.Ctrip.Framework.Apollo.Configuration</span><br><span class="line">&gt; dotnet add package Swashbuckle.AspNetCore</span><br></pre></td></tr></table></figure>
<p>修改<code>appsettings.json</code>增加<code>apollo</code>配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    &quot;AllowedHosts&quot;: &quot;*&quot;,</span><br><span class="line">    &quot;apollo&quot;: &#123;</span><br><span class="line">        &quot;AppId&quot;: &quot;test&quot;,</span><br><span class="line">        &quot;MetaServer&quot;: &quot;http:&#x2F;&#x2F;apollo.demo.com&#x2F;config-svc&quot;,</span><br><span class="line">        &quot;Env&quot;: &quot;Dev&quot;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改<code>Program.cs</code>，添加Apollo配置源如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static IHostBuilder CreateHostBuilder(string[] args) &#x3D;&gt;</span><br><span class="line">    Host.CreateDefaultBuilder(args)</span><br><span class="line">    .ConfigureAppConfiguration(configBuilder &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        configBuilder.AddApollo(configBuilder.Build().GetSection(&quot;apollo&quot;))</span><br><span class="line">            .AddDefault()</span><br><span class="line">            .AddNamespace(&quot;TEST1.connectionstrings&quot;, &quot;ConnectionStrings&quot;)</span><br><span class="line">            .AddNamespace(&quot;logging&quot;, ConfigFileFormat.Json)</span><br><span class="line">            ;</span><br><span class="line">    &#125;)</span><br><span class="line">        .ConfigureWebHostDefaults(webBuilder &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>修改<code>Startup.cs</code>，添加Swagger集成，方便测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void ConfigureServices(IServiceCollection services)</span><br><span class="line">&#123;</span><br><span class="line">    services.AddControllers();</span><br><span class="line">    services.AddSwaggerGen(c &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        c.SwaggerDoc(&quot;v1&quot;, new OpenApiInfo &#123; Title &#x3D; this.GetType().Namespace, Version &#x3D; &quot;v1&quot; &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; This method gets called by the runtime. Use this method to configure the HTTP request pipeline.</span><br><span class="line">public void Configure(IApplicationBuilder app, IWebHostEnvironment env)</span><br><span class="line">&#123;</span><br><span class="line">    if (env.IsDevelopment())</span><br><span class="line">    &#123;</span><br><span class="line">        app.UseDeveloperExceptionPage();</span><br><span class="line">    &#125;</span><br><span class="line">    app.UseSwagger();</span><br><span class="line">    app.UseSwaggerUI(c &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        c.SwaggerEndpoint(&quot;&#x2F;swagger&#x2F;v1&#x2F;swagger.json&quot;, $&quot;&#123;this.GetType().Namespace&#125; V1&quot;);</span><br><span class="line">        c.RoutePrefix &#x3D; string.Empty;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加<code>ApolloController</code>，增加以下测试代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace K8S.NET.Apollo.Controllers</span><br><span class="line">&#123;</span><br><span class="line">    [ApiController]</span><br><span class="line">    [Route(&quot;[controller]&#x2F;[action]&quot;)]</span><br><span class="line">    public class ApolloController : Controller</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly IConfiguration _configuration;</span><br><span class="line">        public ApolloController(IConfiguration configuration)</span><br><span class="line">        &#123;</span><br><span class="line">            _configuration &#x3D; configuration;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [HttpGet(&quot;key&quot;)]</span><br><span class="line">        public IActionResult GetLogLevelSection()</span><br><span class="line">        &#123;</span><br><span class="line">            var key &#x3D; &quot;Logging:LogLevel&quot;;</span><br><span class="line">            var val &#x3D; _configuration.GetSection(key).Get&lt;LoggingOptions&gt;();</span><br><span class="line">            return Ok($&quot;&#123;key&#125;:&#123;JsonSerializer.Serialize(val)&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [HttpGet(&quot;key&quot;)]</span><br><span class="line">        public IActionResult GetString(string key)</span><br><span class="line">        &#123;</span><br><span class="line">            var val &#x3D; _configuration.GetValue&lt;string&gt;(key);</span><br><span class="line">            return Ok($&quot;&#123;key&#125;:&#123;val&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [HttpGet(&quot;key&quot;)]</span><br><span class="line">        public IActionResult GetConnectionStrings(string key)</span><br><span class="line">        &#123;</span><br><span class="line">            var val &#x3D; _configuration.GetConnectionString(key);</span><br><span class="line">            return Ok($&quot;&#123;key&#125;:&#123;val&#125;&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class LoggingOptions : Dictionary&lt;string, string&gt;</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>登录Apollo Portal，添加test项目，并增加以下配置，并发布。<br><img src="/images/use-apollo-with-netcore-on-k8s/2799767-26742654e9fa45fc.png" alt="增加配置"></p>
<p>本地调试，就能够获取云端配置，另外Apollo同时会同步一份配置到本地目录：<code>c:/opt/data/test/config-cache</code>。这样就可以保证即使无法建立云端连接，也可以正常加载本地配置。<br>执行以下命令，进行配置读取和验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; curl https:&#x2F;&#x2F;localhost:5001&#x2F;Apollo&#x2F;GetLogLevelSection</span><br><span class="line">Logging:LogLevel:&#123;&quot;Default&quot;:&quot;Information&quot;,&quot;Microsoft&quot;:&quot;Warning&quot;,&quot;Microsoft.Hosting.Lifetime&quot;:&quot;Information&quot;&#125;</span><br><span class="line">&gt; curl https:&#x2F;&#x2F;localhost:5001&#x2F;Apollo&#x2F;GetString&#x2F;key?key&#x3D;name</span><br><span class="line">name:Shengjie</span><br><span class="line">&gt; curl https:&#x2F;&#x2F;localhost:5001&#x2F;Apollo&#x2F;GetConnectionStrings&#x2F;key?key&#x3D;Default</span><br><span class="line">Default:Server&#x3D;mu3ne-mysql;port&#x3D;3306;database&#x3D;mu3ne0001;user id&#x3D;root;password&#x3D;abc123;AllowLoadLocalInfile&#x3D;true</span><br></pre></td></tr></table></figure>





<h1 id="5-配置迁移指北"><a href="#5-配置迁移指北" class="headerlink" title="5.配置迁移指北"></a>5.配置迁移指北</h1><p>相信采用Apollo的绝大多数都不是一开始就用的，都是再配置逐渐复杂之后，才进行迁移的。我也不例外，之前是用K8S的ConfigMap来做配置管理。下面就来讲下迁移指南，我将其分为两种模式：</p>
<ol>
<li>偷懒模式<br>如果想改动最小，就直接将项目配置继续以Json格式维护到Apollo的私有命名空间下。<br><img src="/images/use-apollo-with-netcore-on-k8s/2799767-cb5f7cdd209df803.png" alt=""><br><img src="/images/use-apollo-with-netcore-on-k8s/2799767-365c7ec8ea0774fa.png" alt=""></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static IHostBuilder CreateHostBuilder(string[] args) &#x3D;&gt;</span><br><span class="line">    Host.CreateDefaultBuilder(args)</span><br><span class="line">        .ConfigureAppConfiguration((context, builder) &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            builder.AddApollo(builder.Build().GetSection(&quot;apollo&quot;))</span><br><span class="line">                .AddDefault()</span><br><span class="line">                .AddNamespace(&quot;appsettings&quot;,ConfigFileFormat.Json);</span><br><span class="line">        &#125;)</span><br><span class="line">        .ConfigureWebHostDefaults(webBuilder &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>强迫症模式<br>也有人考虑，既然上Apollo，就要用到它的特性，因此对现有配置就要分门别类。哪些是公用的，哪些是私有的。对于公用的就要定义到公共的命名空间下。公共命名空间的配置格式只有Properties格式，因此需要将Json转为Properties。比如针对<code>Logging</code>配置可以借助网站 <a href="https://tools.fromdev.com/json-to-property-converter.html" target="_blank" rel="noopener">json2properties converter</a>进行在线转换。如下所示：</li>
</ol>
<p><img src="/images/use-apollo-with-netcore-on-k8s/2799767-145fd931518f0f42.png" alt="json2properties"></p>
<p>如果真这样做，你就错了，你会发现最终的日志配置不生效。这是因为<code>properties</code>格式是以<strong><code>.</code></strong>进行分割，而.NET Core是用<strong><code>:</code></strong>来识别节点配置， 因此<code>properties</code>配置按<strong><code>:</code></strong>分割就好了，如下所示，以下两种配置等效：</p>
<p><img src="/images/use-apollo-with-netcore-on-k8s/2799767-bd49e8486057cdd0.png" alt="json 与 properties 相互转换"></p>
<h1 id="6-最后"><a href="#6-最后" class="headerlink" title="6. 最后"></a>6. 最后</h1><p>以上，相信若能够动手实操，你将收获匪浅。</p>
<p>本文Demo和Chart包的完整配置已上传至Github：<a href="https://github.com/sheng-jie/dotnet.on.k8s/tree/master/K8S.NET.Apollo" target="_blank" rel="noopener">K8S.NET.Apollo</a>，请按需取用。</p>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>apollo</tag>
      </tags>
  </entry>
  <entry>
    <title>.NET Core + K8S + Loki  玩转日志聚合</title>
    <url>/post/use-loki-with-netcore-on-k8s/</url>
    <content><![CDATA[<p><img src="/images/use-loki-with-netcore-on-k8s/2799767-8a2a9babaa4251ed.png" alt="Grafana loki"></p>
<h1 id="1-Intro"><a href="#1-Intro" class="headerlink" title="1. Intro"></a>1. Intro</h1><p>最近在了解日志聚合系统，正好前几天看到一篇文章《<a href="https://www.ershicimi.com/p/a0747756a287962e76fe672d88c7f912" target="_blank" rel="noopener">用了日志系统新贵Loki，ELK突然不香了！</a>》，所以就决定动手体验一下。本文就带大家快速了解下Loki，并简单介绍.NET Core如何集成Loki。</p>
<h1 id="2-What’s-Loki-Stack"><a href="#2-What’s-Loki-Stack" class="headerlink" title="2. What’s Loki Stack"></a>2. What’s Loki Stack</h1><p><a href="https://github.com/grafana/loki" target="_blank" rel="noopener">Grafana Loki</a> like Prometheus, but for logs。其是一个水平可扩展，高可用性，多租户的<strong>日志聚合系统</strong>，基于Apatch 2.0开源。其有三部分组成：</p>
<ol>
<li>Loki 是主服务器，负责存储日志和处理查询。对标ELK中的ElasticSearch。</li>
<li>Promtail 是代理，负责收集日志并将其发送给loki。对标ELK中的Logstash。</li>
<li>Grafana提供用户界面。对标ELK中的Kibana。<br><img src="/images/use-loki-with-netcore-on-k8s/2799767-74a1d7b72766122c.png" alt=""></li>
</ol>
<h1 id="3-Why-Use-Loki"><a href="#3-Why-Use-Loki" class="headerlink" title="3. Why Use Loki"></a>3. Why Use Loki</h1><p>日志聚合系统的目的是为了方便我们进行日志跟踪和故障排查，尤其在云原生的环境之下。目前主流的日志聚合系统，当数ELK、EFK和Loki。Loki相较于ELK Stack有以下优势：</p>
<ul>
<li><p>Elasticsearch中的数据作为非结构化JSON对象存储在磁盘上，Loki以二进制的形式存储。</p>
</li>
<li><p>Elasticsearch采用全文索引，倒排索引的切分和共享的成本较高。Loki仅索引元数据，比如标签。</p>
</li>
<li><p>和Prometheus无缝集成。</p>
</li>
</ul>
<h1 id="4-How-Use-Loki"><a href="#4-How-Use-Loki" class="headerlink" title="4. How Use Loki"></a>4. How Use Loki</h1><p>首先我们先来基于Heml安装Loki到本地K8S集群。</p>
<p><strong>1. 添加Loki Chart 仓库：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Shengjie&gt; helm repo add loki https:&#x2F;&#x2F;grafana.github.io&#x2F;loki&#x2F;charts</span><br><span class="line">&quot;loki&quot; has been added to your repositories</span><br><span class="line">PS C:\Users\Shengjie&gt; helm repo update</span><br><span class="line">Hang tight while we grab the latest from your chart repositories...</span><br><span class="line">...Successfully got an update from the &quot;stable&quot; chart repository</span><br><span class="line">...Successfully got an update from the &quot;loki&quot; chart repository</span><br><span class="line">Update Complete. ⎈ Happy Helming!⎈</span><br></pre></td></tr></table></figure>
<p><strong>2. 安装Loki Stack</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Shengjie&gt; helm search hub loki-stack</span><br><span class="line">URL                                             CHART VERSION   APP VERSION     DESCRIPTION</span><br><span class="line">https:&#x2F;&#x2F;hub.helm.sh&#x2F;charts&#x2F;loki&#x2F;loki-stack      0.38.3          v1.5.0          Loki: like Prometheus, but for logs.</span><br><span class="line">PS C:\Users\Shengjie&gt; helm show values loki&#x2F;loki-stack</span><br><span class="line">loki:</span><br><span class="line">  enabled: true</span><br><span class="line"></span><br><span class="line">promtail:</span><br><span class="line">  enabled: true</span><br><span class="line"></span><br><span class="line">fluent-bit:</span><br><span class="line">  enabled: false</span><br><span class="line"></span><br><span class="line">grafana:</span><br><span class="line">  enabled: false</span><br><span class="line">  sidecar:</span><br><span class="line">    datasources:</span><br><span class="line">      enabled: true</span><br><span class="line">  image:</span><br><span class="line">    tag: 6.7.0</span><br><span class="line"></span><br><span class="line">prometheus:</span><br><span class="line">  enabled: false</span><br><span class="line"></span><br><span class="line">filebeat:</span><br><span class="line">  enabled: false</span><br><span class="line">  filebeatConfig:</span><br><span class="line">    filebeat.yml: |</span><br><span class="line">      # logging.level: debug</span><br><span class="line">      filebeat.inputs:</span><br><span class="line">      - type: container</span><br><span class="line">        paths:</span><br><span class="line">          - &#x2F;var&#x2F;log&#x2F;containers&#x2F;*.log</span><br><span class="line">        processors:</span><br><span class="line">        - add_kubernetes_metadata:</span><br><span class="line">            host: $&#123;NODE_NAME&#125;</span><br><span class="line">            matchers:</span><br><span class="line">            - logs_path:</span><br><span class="line">                logs_path: &quot;&#x2F;var&#x2F;log&#x2F;containers&#x2F;&quot;</span><br><span class="line">      output.logstash:</span><br><span class="line">        hosts: [&quot;logstash-loki:5044&quot;]</span><br><span class="line"></span><br><span class="line">logstash:</span><br><span class="line">  enabled: false</span><br><span class="line">  image:</span><br><span class="line">    repository: grafana&#x2F;logstash-output-loki</span><br><span class="line">    tag: 1.0.1</span><br><span class="line">  filters:</span><br><span class="line">    main: |-</span><br><span class="line">      filter &#123;</span><br><span class="line">        if [kubernetes] &#123;</span><br><span class="line">          mutate &#123;</span><br><span class="line">            add_field &#x3D;&gt; &#123;</span><br><span class="line">              &quot;container_name&quot; &#x3D;&gt; &quot;%&#123;[kubernetes][container][name]&#125;&quot;</span><br><span class="line">              &quot;namespace&quot; &#x3D;&gt; &quot;%&#123;[kubernetes][namespace]&#125;&quot;</span><br><span class="line">              &quot;pod&quot; &#x3D;&gt; &quot;%&#123;[kubernetes][pod][name]&#125;&quot;</span><br><span class="line">            &#125;</span><br><span class="line">            replace &#x3D;&gt; &#123; &quot;host&quot; &#x3D;&gt; &quot;%&#123;[kubernetes][node][name]&#125;&quot;&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mutate &#123;</span><br><span class="line">          remove_field &#x3D;&gt; [&quot;tags&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  outputs:</span><br><span class="line">    main: |-</span><br><span class="line">      output &#123;</span><br><span class="line">        loki &#123;</span><br><span class="line">          url &#x3D;&gt; &quot;http:&#x2F;&#x2F;loki:3100&#x2F;loki&#x2F;api&#x2F;v1&#x2F;push&quot;</span><br><span class="line">          #username &#x3D;&gt; &quot;test&quot;</span><br><span class="line">          #password &#x3D;&gt; &quot;test&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        # stdout &#123; codec &#x3D;&gt; rubydebug &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>从上面的Values中，可以看出，可以自定义启用fluent-bit、grafana、filebeat、prometheus、logstash组件。这里我们仅启用grafana日志界面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Shengjie&gt; helm install loki-stack loki&#x2F;loki-stack --set grafana.enabled&#x3D;true</span><br><span class="line">coalesce.go:165: warning: skipped value for filters: Not a table.</span><br><span class="line">coalesce.go:165: warning: skipped value for filters: Not a table.</span><br><span class="line">NAME: loki-stack</span><br><span class="line">LAST DEPLOYED: Sun Jul 26 11:58:11 2020</span><br><span class="line">NAMESPACE: default</span><br><span class="line">STATUS: deployed</span><br><span class="line">REVISION: 1</span><br><span class="line">NOTES:</span><br><span class="line">The Loki stack has been deployed to your cluster. Loki can now be added as a datasource in Grafana.</span><br><span class="line"></span><br><span class="line">See http:&#x2F;&#x2F;docs.grafana.org&#x2F;features&#x2F;datasources&#x2F;loki&#x2F; for more detail.</span><br></pre></td></tr></table></figure>
<p><strong>3. 登录Grafana</strong><br>首先确认Loki是否成功部署：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Shengjie&gt; helm list</span><br><span class="line">NAME            NAMESPACE       REVISION        UPDATED                                 STATUS          CHART                   APP VERSION</span><br><span class="line">loki-stack      default         1               2020-07-26 11:58:11.022896 +0800 CST    deployed        loki-stack-0.38.3       v1.5.0</span><br><span class="line">PS C:\Users\Shengjie&gt; kubectl get pod -w</span><br><span class="line">NAME                                READY   STATUS        RESTARTS   AGE</span><br><span class="line">loki-stack-0                        1&#x2F;1     Running       0          2m33s</span><br><span class="line">loki-stack-grafana-c447cfbd-z6tbg   1&#x2F;1     Running       0          2m33s</span><br><span class="line">loki-stack-promtail-j47hl           1&#x2F;1     Running       0          2m33s</span><br><span class="line">PS C:\Users\Shengjie&gt; kubectl get svc -w</span><br><span class="line">NAME                  TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">kubernetes            ClusterIP   10.96.0.1       &lt;none&gt;        443&#x2F;TCP    56d</span><br><span class="line">loki-stack            ClusterIP   10.110.83.209   &lt;none&gt;        3100&#x2F;TCP   2m52s</span><br><span class="line">loki-stack-grafana    ClusterIP   10.111.24.26    &lt;none&gt;        80&#x2F;TCP     2m52s</span><br><span class="line">loki-stack-headless   ClusterIP   None            &lt;none&gt;        3100&#x2F;TCP   2m52s</span><br></pre></td></tr></table></figure>
<p>从上面可知，已经成功启动，其中loki暴露的容器端口为3100，grafana暴露的端口为80。<br>因此我们下一步需要进行端口转发，才能访问grafana。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Shengjie&gt; kubectl port-forward svc&#x2F;loki-stack-grafana 3000:80</span><br><span class="line">Forwarding from 127.0.0.1:3000 -&gt; 3000</span><br><span class="line">Forwarding from [::1]:3000 -&gt; 3000</span><br></pre></td></tr></table></figure>
<p>然后本地浏览器打开<a href="http://localhost:3000" target="_blank" rel="noopener">http://localhost:3000/</a>就可以访问了。<br>其默认用户是admin，默认密码在哪里呢，别慌，我们去看下loki-stack chart 的readme：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Shengjie&gt; helm show readme loki&#x2F;loki-stack</span><br><span class="line"># Loki-Stack Helm Chart</span><br><span class="line">## Prerequisites</span><br><span class="line"></span><br><span class="line">Make sure you have Helm [installed](https:&#x2F;&#x2F;helm.sh&#x2F;docs&#x2F;using_helm&#x2F;#installing-helm) and</span><br><span class="line">[deployed](https:&#x2F;&#x2F;helm.sh&#x2F;docs&#x2F;using_helm&#x2F;#installing-tiller) to your cluster. Then add</span><br><span class="line">Loki&#39;s chart repository to Helm:</span><br><span class="line">$ helm repo add loki https:&#x2F;&#x2F;grafana.github.io&#x2F;loki&#x2F;charts</span><br><span class="line"></span><br><span class="line">You can update the chart repository by running:</span><br><span class="line">$ helm repo update</span><br><span class="line"></span><br><span class="line">## Deploy Loki and Promtail to your cluster</span><br><span class="line">### Deploy with default config</span><br><span class="line">$ helm upgrade --install loki loki&#x2F;loki-stack</span><br><span class="line">### Deploy in a custom namespace</span><br><span class="line">$ helm upgrade --install loki --namespace&#x3D;loki-stack loki&#x2F;loki-stack</span><br><span class="line"></span><br><span class="line">### Deploy with custom config</span><br><span class="line"></span><br><span class="line">$ helm upgrade --install loki loki&#x2F;loki-stack --set &quot;key1&#x3D;val1,key2&#x3D;val2,...&quot;</span><br><span class="line">## Deploy Loki and Fluent Bit to your cluster</span><br><span class="line">$ helm upgrade --install loki loki&#x2F;loki-stack \</span><br><span class="line">    --set fluent-bit.enabled&#x3D;true,promtail.enabled&#x3D;false</span><br><span class="line">## Deploy Grafana to your cluster</span><br><span class="line">The chart loki-stack contains a pre-configured Grafana, simply use &#96;--set grafana.enabled&#x3D;true&#96;</span><br><span class="line"></span><br><span class="line">To get the admin password for the Grafana pod, run the following command:</span><br><span class="line">$ kubectl get secret --namespace &lt;YOUR-NAMESPACE&gt; loki-grafana -o jsonpath&#x3D;&quot;&#123;.data.admin-password&#125;&quot; | base64 --decode ; echo</span><br><span class="line">To access the Grafana UI, run the following command:</span><br><span class="line">$ kubectl port-forward --namespace &lt;YOUR-NAMESPACE&gt; service&#x2F;loki-grafana 3000:80</span><br><span class="line">Navigate to http:&#x2F;&#x2F;localhost:3000 and login with &#96;admin&#96; and the password output above.</span><br><span class="line">Then follow the [instructions for adding the loki datasource](&#x2F;docs&#x2F;getting-started&#x2F;grafana.md), using the URL &#96;http:&#x2F;&#x2F;loki:3100&#x2F;&#96;</span><br></pre></td></tr></table></figure>
<p>上面已经说了很清楚了，可以从secret中获取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">如果在windows powersheel中执行，需要分两步：</span><br><span class="line">1. 先获取base64加密的密码</span><br><span class="line">PS C:\Users\Shengjie&gt; $pwd&#x3D; kubectl get secret --namespace default loki-stack-grafana -o jsonpath&#x3D;&quot;&#123;.data.admin-password&#125;&quot;</span><br><span class="line">2. decode base64</span><br><span class="line">PS C:\Users\Shengjie&gt; [Text.Encoding]::Utf8.GetString([Convert]::FromBase64String($pwd))</span><br><span class="line">CjnbkkQmwQynZ96gCsynSf0elYQLOp4dyuDnp9jJ</span><br><span class="line"></span><br><span class="line">------------------------</span><br><span class="line">Linux命令行执行：</span><br><span class="line">shengjie@Thinkpad:&#x2F;mnt&#x2F;c&#x2F;Users&#x2F;Shengjie$ kubectl get secret --namespace default loki-stack-grafana -o jsonpath&#x3D;&quot;&#123;.data.admin-password&#125;&quot; | base64 --decode ; echo</span><br><span class="line">CjnbkkQmwQynZ96gCsynSf0elYQLOp4dyuDnp9jJ</span><br></pre></td></tr></table></figure>
<p>然后使用<code>admin/CjnbkkQmwQynZ96gCsynSf0elYQLOp4dyuDnp9jJ</code>即可成功登录<a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a>。</p>
<p><img src="/images/use-loki-with-netcore-on-k8s/2799767-1c28d06f48f9ee6c.png" alt="Grafnan Explore"></p>
<h1 id="5-Use-Loki-With-NET-Core"><a href="#5-Use-Loki-With-NET-Core" class="headerlink" title="5. Use Loki With .NET Core"></a>5. Use Loki With .NET Core</h1><p>下一步，我们就来创建一个ASP.NET Core Web 应用，将日志记录到Loki，并通过Grafana进行聚合分析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Shengjie&gt; dotnet new web -n Loki.K8s.Demo</span><br><span class="line">The template &quot;ASP.NET Core Empty&quot; was created successfully.</span><br><span class="line"></span><br><span class="line">Processing post-creation actions...</span><br><span class="line">Running &#39;dotnet restore&#39; on Loki.K8s.Demo\Loki.K8s.Demo.csproj...</span><br><span class="line">  Determining projects to restore...</span><br><span class="line">  Restored C:\Users\Shengjie\Loki.K8s.Demo\Loki.K8s.Demo.csproj (in 150 ms).</span><br><span class="line"></span><br><span class="line">Restore succeeded.</span><br><span class="line">PS C:\Users\Shengjie&gt; cd .\Loki.K8s.Demo\</span><br><span class="line"># 添加Serilog.AspNetCore和Serilog.Sinks.Loki Nuget包。</span><br><span class="line">PS C:\Users\Shengjie\Loki.K8s.Demo&gt; dotnet add package Serilog.AspNetCore</span><br><span class="line">PS C:\Users\Shengjie\Loki.K8s.Demo&gt; dotnet add package Serilog.Sinks.Loki</span><br></pre></td></tr></table></figure>
<p>从上可知，日志组件选用的是Serilog，因为其支持持久化日志到Loki。<br>修改<code>Program.cs</code>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static IHostBuilder CreateHostBuilder(string[] args) &#x3D;&gt;</span><br><span class="line">    Host.CreateDefaultBuilder(args)</span><br><span class="line">        .ConfigureWebHostDefaults(webBuilder &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">        &#125;).UseSerilog((ctx, cfg) &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;cfg.MinimumLevel.Override(&quot;Microsoft&quot;, LogEventLevel.Warning);&#x2F;&#x2F;Microsoft框架本身的日志，仅输出Warning以上级别</span><br><span class="line">            cfg.Enrich.FromLogContext()</span><br><span class="line">            .Enrich.WithProperty(&quot;App&quot;, ctx.HostingEnvironment.ApplicationName)</span><br><span class="line">            .Enrich.WithProperty(&quot;ENV&quot;, ctx.HostingEnvironment.EnvironmentName)</span><br><span class="line">            .WriteTo.LokiHttp(new NoAuthCredentials(&quot;http:&#x2F;&#x2F;localhost:3100&quot;))&#x2F;&#x2F;配置Loki Url和认证方式</span><br><span class="line">            .WriteTo.Console();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>修改<code>Startup.cs</code>的<code>Configure</code>方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void Configure(IApplicationBuilder app, IWebHostEnvironment env,ILogger&lt;Startup&gt; logger)</span><br><span class="line">&#123;</span><br><span class="line">    if (env.IsDevelopment())</span><br><span class="line">    &#123;</span><br><span class="line">        app.UseDeveloperExceptionPage();</span><br><span class="line">    &#125;</span><br><span class="line">    app.UseRouting();</span><br><span class="line">    app.UseEndpoints(endpoints &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapGet(&quot;&#x2F;&quot;, async context &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            logger.LogInformation(&quot;start handle request!&quot;);</span><br><span class="line">            await context.Response.WriteAsync(&quot;Hello World!&quot;);</span><br><span class="line">            logger.LogInformation(&quot;end handle request!&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为不想把应用打包成镜像运行到K8S中，所以我们需要把K8S的Loki服务做一次端口转发暴露到本机，转发后，就可以使用<code>http://localhost:3100</code>作为Loki的Url进行日志写入啦。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PS C:\Users\Shengjie\Loki.K8s.Demo&gt; kubectl port-forward svc&#x2F;loki-stack 3100:3100</span><br><span class="line">Forwarding from 127.0.0.1:3100 -&gt; 3100</span><br><span class="line">Forwarding from [::1]:3100 -&gt; 3100</span><br></pre></td></tr></table></figure>
<p>运行项目后，重新打开Grafana，添加过滤条件，就可以查看应用日志了。</p>
<p><img src="/images/use-loki-with-netcore-on-k8s/2799767-54cdf8c248c39797.png" alt=""></p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://cloud.tencent.com/developer/article/1622402" target="_blank" rel="noopener">日志聚合工具loki</a></li>
<li><a href="https://blog.csdn.net/linkthaha/category_9331298.html" target="_blank" rel="noopener">CSDN-linkt1234-Loki</a></li>
<li><a href="https://grafana.com/docs/loki/latest/" target="_blank" rel="noopener">Loki官方文档</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>云原生</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>Loki</tag>
      </tags>
  </entry>
  <entry>
    <title>WinDbg分析高内存占用问题</title>
    <url>/post/use-windbg-to-analyze-high-memory-issue/</url>
    <content><![CDATA[<p><img src="/images/use-windbg-to-analyze-high-memory-issue/2799767-0f1cf31d06374907.png" alt=""></p>
<h1 id="1-问题简介"><a href="#1-问题简介" class="headerlink" title="1. 问题简介"></a>1. 问题简介</h1><p>最近产品发布大版本补丁更新，一商超客户升级后，反馈系统经常奔溃，导致超市的收银系统无法正常收银，现场排队付款的顾客更是抱怨声声。为了缓解现场的情况， 客户都是手动回收IIS应用程序池才能解决。<br><img src="/images/use-windbg-to-analyze-high-memory-issue/2799767-fc4cfcbf08a0df04.png" alt="现场排队情况"></p>
<p>这样的后果是很严重的，接到反馈，第一时间想到的是加内存吧，这样最快。但是客户从8G–&gt;16G–&gt;32G，只是延长了每次奔溃的时间，但是并没有解决系统卡顿的问题。到这里，也基本猜测了问题所在了，肯定是什么东西一直在吃内存且得不到释放。这种问题，也就只能打Dump分析了。</p>
<h1 id="2-打Dump"><a href="#2-打Dump" class="headerlink" title="2. 打Dump"></a>2. 打Dump</h1><p>远程客户应用服务器，32G内存占用已经消耗了78%，而现场已经反馈收银系统接近奔溃了，要求先强制回收内存。反正也要奔溃了，先打Dump再说吧。<br>（PS：打Dump会挂起进程，导致应用无法响应！而打Dump的耗时，也是根据当时进程的内存占用有关，内存占用越大，耗时越久。）<br>打开任务管理器，选择对应的IIS进程，右键创建转储文件（Dump）。<br><img src="/images/use-windbg-to-analyze-high-memory-issue/2799767-fe85d20242c6f435.png" alt="打Dump"></p>
<p>结果，Dump文件是生成的，结果当分析的时候，发现Windbg提示Dump无效。说明Dump文件创建的有问题。观察任务管理器，发现内存占用一下就降下来了，原来是之前的进程直接奔溃了，重启了一个W3WP进程。</p>
<p>既然直接从任务管理器无法创建，就使用第三方工具收集Dump吧。经过Goggle，找到一款很好用的Dump收集工具<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump" target="_blank" rel="noopener">ProcDump</a>，是一个命令行应用，其主要用途是监视应用程序的CPU或内存峰值并在峰值期间生成Dump。</p>
<p>因为是高内存占用问题，我们使用以下命令来抓取dump：<br>（PS：可以使用进程名称，也可以使用进程ID来指定要创建Dump的进程。当有多个相同名称的进程时，必须使用进程ID来指定！）</p>
<blockquote>
<p>procdump w3wp -m 20480 -o D:\Dumps （当内存超过20G时抓取一个w3wp进程的MiniDump）</p>
</blockquote>
<p>上面就是我踩得第一个坑，因为默认抓取的是MiniDump，很快就抓下来，文件也很小，正在我得意的时候，Windbg加载Dump分析的时候，发现包含的信息很少，根本无法进行进一步的分析。</p>
<p>调整创建Dump的命令，添加<code>-ma</code>参数即可创建完整Dump。</p>
<blockquote>
<p>procdump w3wp -ma -m 20480 -o D:\Dumps （当内存超过20G时抓取一个w3wp进程的完整Dump）</p>
</blockquote>
<p>结果再一次，当内存占用到达20G，占比80%的时候，Dump再次创建失败，提示：<code>Procdump Error writing dump file</code>。再一次感觉到绝望。不过至少有错误提示，Google一把，果然存在天涯沦落人。<a href="https://stackoverflow.com/questions/39936971/procdump-error-writing-dump-file-0x80070005-error-0x80070005-2147024891-acc" target="_blank" rel="noopener">Procdump Error writing dump file: 0x80070005 Error 0x80070005 (-2147024891): Access is denied</a>。大致的意思是说，当90S内Dump文件没有成功创建的话（也就意味着w3wp进程被挂起了90s），IIS检测到w3wp进程挂起超过90s没有响应就会终止进程，重新创建一个新的进程。好嘛，真是处处是坑。</p>
<p>这个坑，也让我开始真正停下来思考问题。<strong>罗马不是一日建成的，内存也不是一下撑爆的。</strong>我干嘛死脑筋非要到内存占用超过80%才去打Dump呢呢呢？？？！</p>
<p>焕然大悟，如醍醐灌顶。</p>
<blockquote>
<p>procdump w3wp -ma -m 8000 -o D:\Dumps （当内存超过8000M时抓取一个w3wp进程的完整Dump，并输出到D:\Dumps文件夹）</p>
</blockquote>
<p>此时内存占用在40%左右，这次Dump终于成功创建了。</p>
<h1 id="3-分析Dump"><a href="#3-分析Dump" class="headerlink" title="3.分析Dump"></a>3.分析Dump</h1><p>分析Dump，上WinDbg。如果对WinDbg不理解，可以看我这篇<a href="https://www.jianshu.com/p/57f0ab8702b5" target="_blank" rel="noopener">WinDbg学习笔记</a>。</p>
<p>接下来就是一通命令乱敲，我尽量解释清晰。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !dumpheap -stat &#x2F;&#x2F;检查当前所有托管类型的统计信息</span><br><span class="line">....</span><br><span class="line">00007ffdb9387a98   777101     69462436 System.Char[]</span><br><span class="line">00007ffdb938c988   588917    115563505 System.Byte[]</span><br><span class="line">00007ffdb9389220  1026406    119828936 System.Int32[]</span><br><span class="line">00007ffdb93516a8   663559    128819040 System.Collections.Generic.Dictionary&#96;2+Entry[[System.String, mscorlib],[System.Object, mscorlib]][]</span><br><span class="line">00000218c6c30a80  6436865    197832116      Free</span><br><span class="line">00007ffdae9cc240    23171    273333144 System.Collections.Generic.HashSet&#96;1+Slot[[System.String, mscorlib]][]</span><br><span class="line">00007ffdb9391f28 13885170    333244080 System.Boolean</span><br><span class="line">00007ffd5c24a068 14003455    560138200 Kingdee.BOS.JSON.JSONArray</span><br><span class="line">00007ffdb9386fc0 14373648   1393615400 System.Object[]</span><br><span class="line">00007ffdb9386948 76146065   4000287202 System.String</span><br><span class="line">Total 138435970 objects</span><br></pre></td></tr></table></figure>
<p>使用<code>dumpheap -stat</code>命令查看当前所有托管类型的统计信息。从输出的结果来看：</p>
<ol>
<li>其中占用内存最多当属<code>System.String</code>类型，接近4G的大小（是不是很吃惊？!）。</li>
<li>其次<code>System.Object[]</code>类型占有1.3G大小。</li>
<li><code>Kingdee.BOS.JSON.JSONArray</code>类型也大概占用了560M。</li>
</ol>
<p>我们首先来分析占用最多的<code>System.String</code>类型，看看有什么发现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !dumpheap -mt 00007ffdb9386948 -min 200 &#x2F;&#x2F;查看200byte以上的string</span><br><span class="line">Address               MT     Size</span><br><span class="line">...</span><br><span class="line">0000021bcbaf5158 00007ffdb9386948     1140</span><br><span class="line">0000021d375d1038 00007ffdb9386948   149698     </span><br><span class="line">0000021d375f5920 00007ffdb9386948   149698     </span><br><span class="line">0000021d3765b138 00007ffdb9386948   149706     </span><br><span class="line">0000021d37f739c8 00007ffdb9386948   217120     </span><br><span class="line">0000021d37fa8a08 00007ffdb9386948   190162     </span><br><span class="line">0000021d38047330 00007ffdb9386948  1224698     </span><br><span class="line">0000021d3829d348 00007ffdb9386948  1224698     </span><br><span class="line">0000021d386bd678 00007ffdb9386948  2610994     </span><br><span class="line">0000021d38bb8500 00007ffdb9386948  2610994     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics:</span><br><span class="line">              MT    Count    TotalSize Class Name</span><br><span class="line">00007ffdb9386948    10991     76632628 System.String</span><br><span class="line">Total 10991 objects</span><br></pre></td></tr></table></figure>
<p>从上面的输出可以发现：</p>
<ol>
<li>单个<code>System.String</code>类型最大占用2M以上。</li>
<li>超过200byte的字节的大小的<code>System.String</code>总大小也不过76M。（所以我们也不必深究大的String对象。）</li>
</ol>
<p>那我们索性挑一个小点的对象来看看存储的是什么字符串，来满足一下我们的好奇心。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.000&gt; !do 0000021bcbaf5158 &#x2F;&#x2F;使用!do命令查看一个对象的内容</span><br><span class="line">Name:        System.String</span><br><span class="line">MethodTable: 00007ffdb9386948</span><br><span class="line">EEClass:     00007ffdb8c850e0</span><br><span class="line">Size:        1140(0x474) bytes</span><br><span class="line">File:        C:\Windows\Microsoft.Net\assembly\GAC_64\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll</span><br><span class="line">String:      5b13710029d012False2052_T_BD_MATERIAL_MATERIAL.FAuxPropertyIdFBaseUnitIdFCategoryIDFChargeIDFCheckIncomingFDefaultVendorFErpClsIDFInvPtyIdFIsAffectPlanFIsAffectPlan1FIsBatchManageFIsComControlFIsEnableFIsEnable1FIsExpParToFlotFIsInventoryFIsPRFIsReturnMaterialFIsSourceControlFIsVmiBusinessFNameFNumberFPlanModeFPurchasePriceUnitIdFPurchaseUnitIdFPurPriceURNomFPurPriceURNumFPurURNomFPurURNumFReceiveAdvanceDaysFReceiveDelayDaysFReceiveMaxScaleFReceiveMinScaleFSalePriceUnitIdFSaleUnitIdFSpecificationFStockIdFStockPlaceIdFStoreUnitIDFTaxTypeFUseOrgId111193</span><br><span class="line">Fields:</span><br><span class="line">              MT    Field   Offset                 Type VT     Attr            Value Name</span><br><span class="line">00007ffdb9389288  400026f        8         System.Int32  1 instance              557 m_stringLength</span><br><span class="line">00007ffdb9387b00  4000270        c          System.Char  1 instance               35 m_firstChar</span><br><span class="line">00007ffdb9386948  4000274       90        System.String  0   shared           static Empty</span><br><span class="line">                                 &gt;&gt; Domain:Value  00000218c6c4d220:NotInit  0000021d52d81840:NotInit  &lt;&lt;</span><br></pre></td></tr></table></figure>
<p>似乎是基础资料字段信息。那接下来使用<code>!gcroot</code>命令查看其对应的GC根，看看到底是什么对象持有其引用，导致占用内存得不到释放。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !gcroot 0000021bcbaf5158 &#x2F;&#x2F;使用!gcroot 查看一个对象的gc根</span><br><span class="line">HandleTable:</span><br><span class="line">    00000218c6ff15e8 (pinned handle)</span><br><span class="line">    -&gt; 0000021cc75ebe68 System.Object[]</span><br><span class="line">    -&gt; 0000021bc7629a10 Kingdee.BOS.Cache.KCacheManagerFactory</span><br><span class="line">    -&gt; 0000021bc7629ab8 System.Collections.Generic.Dictionary&#96;2[[System.String, mscorlib],[Kingdee.BOS.Cache.AbstractKCacheManager, Kingdee.BOS]]</span><br><span class="line">    -&gt; 0000021c4da6fa48 System.Collections.Generic.Dictionary&#96;2+Entry[[System.String, mscorlib],[Kingdee.BOS.Cache.AbstractKCacheManager, Kingdee.BOS]][]</span><br><span class="line">    -&gt; 00000218c83861b8 Kingdee.BOS.Cache.KCacheManager</span><br><span class="line">    -&gt; 00000218c8386630 Kingdee.BOS.Cache.ECache.ECacheManager</span><br><span class="line">    -&gt; 00000218c83866e8 System.Collections.Concurrent.ConcurrentDictionary&#96;2[[System.String, mscorlib],[System.Collections.Generic.HashSet&#96;1[[System.String, mscorlib]], System.Core]]</span><br><span class="line">    -&gt; 0000021bcbae0c70 System.Collections.Concurrent.ConcurrentDictionary&#96;2+Tables[[System.String, mscorlib],[System.Collections.Generic.HashSet&#96;1[[System.String, mscorlib]], System.Core]]</span><br><span class="line">    -&gt; 0000021bcbad0128 System.Collections.Concurrent.ConcurrentDictionary&#96;2+Node[[System.String, mscorlib],[System.Collections.Generic.HashSet&#96;1[[System.String, mscorlib]], System.Core]][]</span><br><span class="line">    -&gt; 0000021bcbb34bf8 System.Collections.Concurrent.ConcurrentDictionary&#96;2+Node[[System.String, mscorlib],[System.Collections.Generic.HashSet&#96;1[[System.String, mscorlib]], System.Core]]</span><br><span class="line">    -&gt; 0000021bcbada790 System.Collections.Concurrent.ConcurrentDictionary&#96;2+Node[[System.String, mscorlib],[System.Collections.Generic.HashSet&#96;1[[System.String, mscorlib]], System.Core]]</span><br><span class="line">    -&gt; 0000021a49766460 System.Collections.Generic.HashSet&#96;1[[System.String, mscorlib]]</span><br><span class="line">    -&gt; 00000219540976b0 System.Collections.Generic.HashSet&#96;1+Slot[[System.String, mscorlib]][]</span><br><span class="line">    -&gt; 0000021bcbaf5158 System.String</span><br><span class="line"></span><br><span class="line">Found 1 unique roots (run &#39;!GCRoot -all&#39; to see all roots).</span><br></pre></td></tr></table></figure>

<p>从以上输出可以看出：</p>
<ol>
<li>该String类型被一个Hashset所持有。</li>
<li>从<code>Cache</code>关键字可以看出该String类型是被<strong>缓存</strong>所持有。</li>
</ol>
<p>分析到这里，我们大致可以得出一个结论：</p>
<blockquote>
<p>String类型占用4G内存，绝大多数是由缓存所占用，才导致String类型得不到释放。</p>
</blockquote>
<p>那我们是不是可以猜测<strong>内存占用持续走高是不是被缓存撑爆的呢？</strong>。</p>
<p>带着这个疑问我们来继续分析下<code>Kingdee.BOS.JSON.JSONArray</code>类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !dumpheap -mt 00007ffd5c24a068 &#x2F;&#x2F;输出托管堆上的所有JSONArray对象</span><br><span class="line">         Address               MT     Size</span><br><span class="line">....</span><br><span class="line">0000021975972b48 00007ffd5c24a068       40     </span><br><span class="line">00000218c933f060 00007ffd5c24a068       40     </span><br><span class="line">00000218c7605990 00007ffd5c24a068       40     </span><br><span class="line">00000218c7605af0 00007ffd5c24a068       40     </span><br><span class="line">00000218c7605c50 00007ffd5c24a068       40     </span><br><span class="line">00000218c7605e18 00007ffd5c24a068       40     </span><br><span class="line">00000218c7605fa0 00007ffd5c24a068       40     </span><br><span class="line">00000218c7606198 00007ffd5c24a068       40     </span><br><span class="line">00000218c7606338 00007ffd5c24a068       40     </span><br><span class="line">00000218c76064b0 00007ffd5c24a068       40     </span><br><span class="line">User interrupt.</span><br></pre></td></tr></table></figure>
<p>从输出结果来看：</p>
<ol>
<li>满屏都是40byte的JSONArray。只能使用<code>Ctrl+Break</code>命令中止输出。</li>
</ol>
<p>但为了保险期间，我们来验证下有没有100byte以上的<code>JSONArray</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !dumpheap -mt 00007ffd5c24a068 -min 100</span><br><span class="line">         Address               MT     Size</span><br><span class="line"></span><br><span class="line">Statistics:</span><br><span class="line">              MT    Count    TotalSize Class Name</span><br><span class="line">Total 0 objects</span><br></pre></td></tr></table></figure>
<p>这时我们可以大胆猜测所有的<code>JSONArray</code>对象都是40byte。从而可以得出另一个猜测<strong>占用560M内存的JSONArray，都具有相似的对象结构。</strong>接下来我们来验证这个猜测。随机选择几个对象，看看其内容具体是什么。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !DumpObj &#x2F;d 0000021975972b48  &#x2F;&#x2F;查看第一个JSONArray</span><br><span class="line">Name:        System.Object[]</span><br><span class="line">MethodTable: 00007ffdb9386fc0</span><br><span class="line">EEClass:     00007ffdb8d4aa00</span><br><span class="line">Size:        88(0x58) bytes</span><br><span class="line">Array:       Rank 1, Number of elements 8, Type CLASS (Print Array)</span><br><span class="line">Fields:</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<p>从输出可以看出：</p>
<ol>
<li>JSONArray实质是<code>System.Object[]</code>类型。</li>
<li>对应的<code>MethodTable: 00007ffdb9386fc0</code>。</li>
</ol>
<p>如果你记性好的话，我们应当还记得占用内存第二多的就是这个<code>System.Object[]</code>类型，占用1.3G。翻到上面，你可以发现其MethodTable和上面的统计信息是一致的。<br>（PS：到这里我们是不是可以猜测：<strong><code>System.Object[]</code>占用的内存无法释放，就是由于被<code>JSONArray</code>持有引用导致的呢？</strong>）</p>
<p>既然是数组，就使用<code>!DumpArray</code> 命令来解开数组的面纱。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !DumpArray &#x2F;d 0000021975972b48 </span><br><span class="line">Name:        System.Object[]</span><br><span class="line">MethodTable: 00007ffdb9386fc0</span><br><span class="line">EEClass:     00007ffdb8d4aa00</span><br><span class="line">Size:        88(0x58) bytes</span><br><span class="line">Array:       Rank 1, Number of elements 8, Type CLASS</span><br><span class="line">Element Methodtable: 00007ffdb9386f28</span><br><span class="line">[0] 0000021975972a08</span><br><span class="line">[1] 0000021975972a70</span><br><span class="line">[2] 0000021975972a40</span><br><span class="line">[3] 0000021ac75e87b8</span><br><span class="line">[4] 0000021975972b10</span><br><span class="line">[5] 0000021975972ba0</span><br><span class="line">[6] null</span><br><span class="line">[7] null</span><br><span class="line">0:000&gt; !DumpObj &#x2F;d 0000021975972a08</span><br><span class="line">Name:        System.String</span><br><span class="line">MethodTable: 00007ffdb9386948</span><br><span class="line">EEClass:     00007ffdb8c850e0</span><br><span class="line">Size:        54(0x36) bytes</span><br><span class="line">File:        C:\Windows\Microsoft.Net\assembly\GAC_64\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll</span><br><span class="line">String:      555d8ca25a6261</span><br><span class="line">Fields:7</span><br><span class="line">              MT    Field   Offset                 Type VT     Attr            Value Name</span><br><span class="line">00007ffdb9389288  400026f        8         System.Int32  1 instance               14 m_stringLength</span><br><span class="line">00007ffdb9387b00  4000270        c          System.Char  1 instance               35 m_firstChar</span><br><span class="line">00007ffdb9386948  4000274       90        System.String  0   shared           static Empty</span><br><span class="line">                                 &gt;&gt; Domain:Value  00000218c6c4d220:NotInit  0000021d52d81840:NotInit  &lt;&lt;</span><br></pre></td></tr></table></figure>
<p>从以上输出可以看出，其共有8个子项，我们再随机挑几个子项看看是什么内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !DumpObj &#x2F;d 0000021975972a70</span><br><span class="line">Name:        System.String</span><br><span class="line">MethodTable: 00007ffdb9386948</span><br><span class="line">EEClass:     00007ffdb8c850e0</span><br><span class="line">Size:        42(0x2a) bytes</span><br><span class="line">File:        C:\Windows\Microsoft.Net\assembly\GAC_64\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll</span><br><span class="line">String:      FHTZDLB</span><br><span class="line">Fields:</span><br><span class="line">              MT    Field   Offset                 Type VT     Attr            Value Name</span><br><span class="line">00007ffdb9389288  400026f        8         System.Int32  1 instance                8 m_stringLength</span><br><span class="line">00007ffdb9387b00  4000270        c          System.Char  1 instance               50 m_firstChar</span><br><span class="line">00007ffdb9386948  4000274       90        System.String  0   shared           static Empty</span><br><span class="line">                                 &gt;&gt; Domain:Value  00000218c6c4d220:NotInit  0000021d52d81840:NotInit  &lt;&lt;</span><br><span class="line">0:000&gt; !DumpObj &#x2F;d 0000021975972a40</span><br><span class="line">Name:        System.String</span><br><span class="line">MethodTable: 00007ffdb9386948</span><br><span class="line">EEClass:     00007ffdb8c850e0</span><br><span class="line">Size:        42(0x2a) bytes</span><br><span class="line">File:        C:\Windows\Microsoft.Net\assembly\GAC_64\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll</span><br><span class="line">String:      发货通知单列表</span><br><span class="line">Fields:</span><br><span class="line">              MT    Field   Offset                 Type VT     Attr            Value Name</span><br><span class="line">00007ffdb9389288  400026f        8         System.Int32  1 instance                8 m_stringLength</span><br><span class="line">00007ffdb9387b00  4000270        c          System.Char  1 instance             6279 m_firstChar</span><br><span class="line">00007ffdb9386948  4000274       90        System.String  0   shared           static Empty</span><br><span class="line">                                 &gt;&gt; Domain:Value  00000218c6c4d220:NotInit  0000021d52d81840:NotInit  &lt;&lt;</span><br></pre></td></tr></table></figure>
<p>我们可以看到一个字符串内容是<code>FHTZDLB</code>，另一个是<code>发货通知单列表</code>。看到这，我立马就条件反射的想到，这不就是我们的菜单信息嘛。为了验证我的想法，连续查看几个<code>JSONArray</code>，都是相似的内容。</p>
<p>这时，我们继续发扬敢猜敢做的精神。<strong>是不是内存被菜单缓存撑爆的？！</strong></p>
<p>为了验证这一猜测，我们继续从Dump中寻找佐证。使用<code>~* e!clrstack</code>来看看所有线程的调用堆栈吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; ~* e!clrstack</span><br><span class="line">OS Thread Id: 0x11dc (0)</span><br><span class="line">Unable to walk the managed stack. The current thread is likely not a </span><br><span class="line">managed thread. You can run !threads to get a list of managed threads in</span><br><span class="line">the process</span><br><span class="line">Failed to start stack walk: 80070057</span><br><span class="line">OS Thread Id: 0x2b2c (28)</span><br><span class="line">        Child SP               IP Call Site</span><br><span class="line">00000076cff7ecc8 00007ffdca2e6bf4 [HelperMethodFrame_1OBJ: 00000076cff7ecc8] System.Threading.WaitHandle.WaitMultiple(System.Threading.WaitHandle[], Int32, Boolean, Boolean)</span><br><span class="line">00000076cff7ee00 00007ffdb91af67c System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[], Int32, Boolean) [f:\dd\ndp\clr\src\BCL\system\threading\waithandle.cs @ 454]</span><br><span class="line">00000076cff7ee60 00007ffdb201b2fb System.Net.TimerThread.ThreadProc()</span><br><span class="line">00000076cff7ef10 00007ffdb915ca72 System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean) [f:\dd\ndp\clr\src\BCL\system\threading\executioncontext.cs @ 954]</span><br><span class="line">00000076cff7efe0 00007ffdb915c904 System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean) [f:\dd\ndp\clr\src\BCL\system\threading\executioncontext.cs @ 902]</span><br><span class="line">00000076cff7f010 00007ffdb915c8c2 System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object) [f:\dd\ndp\clr\src\BCL\system\threading\executioncontext.cs @ 891]</span><br><span class="line">00000076cff7f060 00007ffdb9196472 System.Threading.ThreadHelper.ThreadStart() [f:\dd\ndp\clr\src\BCL\system\threading\thread.cs @ 111]</span><br><span class="line">00000076cff7f2b8 00007ffdbb4f6793 [GCFrame: 00000076cff7f2b8] </span><br><span class="line">00000076cff7f608 00007ffdbb4f6793 [DebuggerU2MCatchHandlerFrame: 00000076cff7f608] </span><br><span class="line">00000076cff7f798 00007ffdbb4f6793 [ContextTransitionFrame: 00000076cff7f798] </span><br><span class="line">00000076cff7f9c8 00007ffdbb4f6793 [DebuggerU2MCatchHandlerFrame: 00000076cff7f9c8] </span><br><span class="line"></span><br><span class="line">OS Thread Id: 0x1bd4 (133)</span><br><span class="line">        Child SP               IP Call Site</span><br><span class="line">GetFrameContext failed: 1</span><br><span class="line">0000000000000000 0000000000000000 </span><br><span class="line">OS Thread Id: 0x1a98 (134)</span><br><span class="line">        Child SP               IP Call Site</span><br><span class="line">00000076dbdbcc88 00007ffdca2e6124 [InlinedCallFrame: 00000076dbdbcc88] .SNIReadSyncOverAsync(SNI_ConnWrapper*, SNI_Packet**, Int32)</span><br><span class="line">00000076dbdbcc88 00007ffdaaaf5dd4 [InlinedCallFrame: 00000076dbdbcc88] .SNIReadSyncOverAsync(SNI_ConnWrapper*, SNI_Packet**, Int32)</span><br><span class="line">00000076dbdbcc60 00007ffdaaaf5dd4 DomainNeutralILStubClass.IL_STUB_PInvoke(SNI_ConnWrapper*, SNI_Packet**, Int32)</span><br><span class="line">00000076dbdbcd10 00007ffdaab08fe3 SNINativeMethodWrapper.SNIReadSyncOverAsync(System.Runtime.InteropServices.SafeHandle, IntPtr ByRef, Int32)</span><br><span class="line">00000076dbdbcd70 00007ffdaabe0ae0 System.Data.SqlClient.TdsParserStateObject.ReadSniSyncOverAsync()</span><br><span class="line">00000076dbdbcdd0 00007ffdaabe09dd System.Data.SqlClient.TdsParserStateObject.TryReadNetworkPacket()</span><br><span class="line">00000076dbdbce10 00007ffdaabdf7f5 System.Data.SqlClient.TdsParserStateObject.TryPrepareBuffer()</span><br><span class="line">00000076dbdbce50 00007ffdaabdfa0e System.Data.SqlClient.TdsParserStateObject.TryReadByte(Byte ByRef)</span><br><span class="line">00000076dbdbce90 00007ffdaabc7daa System.Data.SqlClient.TdsParser.TryRun(System.Data.SqlClient.RunBehavior, System.Data.SqlClient.SqlCommand, System.Data.SqlClient.SqlDataReader, System.Data.SqlClient.BulkCopySimpleResultSet, System.Data.SqlClient.TdsParserStateObject, Boolean ByRef)</span><br><span class="line">00000076dbdbcff0 00007ffdaabbb3c7 System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()</span><br><span class="line">00000076dbdbd050 00007ffdaabb8325 System.Data.SqlClient.SqlDataReader.get_MetaData()</span><br><span class="line">00000076dbdbd0a0 00007ffdaab3be73 System.Data.SqlClient.SqlCommand.FinishExecuteReader(System.Data.SqlClient.SqlDataReader, System.Data.SqlClient.RunBehavior, System.String, Boolean, Boolean)</span><br><span class="line">00000076dbdbd110 00007ffdaab3b75f System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(System.Data.CommandBehavior, System.Data.SqlClient.RunBehavior, Boolean, Boolean, Int32, System.Threading.Tasks.Task ByRef, Boolean, Boolean, System.Data.SqlClient.SqlDataReader, Boolean)</span><br><span class="line">00000076dbdbd1f0 00007ffdaab3a763 System.Data.SqlClient.SqlCommand.RunExecuteReader(System.Data.CommandBehavior, System.Data.SqlClient.RunBehavior, Boolean, System.String, System.Threading.Tasks.TaskCompletionSource&#96;1, Int32, System.Threading.Tasks.Task ByRef, Boolean ByRef, Boolean, Boolean)</span><br><span class="line">00000076dbdbd2c0 00007ffdaab3a49b System.Data.SqlClient.SqlCommand.RunExecuteReader(System.Data.CommandBehavior, System.Data.SqlClient.RunBehavior, Boolean, System.String)</span><br><span class="line">00000076dbdbd360 00007ffdaab35cc6 System.Data.SqlClient.SqlCommand.ExecuteReader(System.Data.CommandBehavior, System.String)</span><br><span class="line">00000076dbdbd3f0 00007ffd5c517ead Kingdee.BOS.App.Data.AbstractDatabase.DoExecuteReader(System.Data.Common.DbCommand, System.Data.CommandBehavior)</span><br><span class="line">00000076dbdbd450 00007ffd5c515ebb Kingdee.BOS.App.Data.AbstractDatabase.ExecuteReader(System.Data.Common.DbCommand, System.Collections.Generic.IEnumerable&#96;1, System.Data.CommandBehavior, Boolean)</span><br><span class="line">00000076dbdbd4d0 00007ffd5c4fd6f2 Kingdee.BOS.App.Data.AbstractDatabase.ExecuteReader(System.Data.Common.DbCommand, System.Collections.Generic.IEnumerable&#96;1, System.Data.CommandBehavior)</span><br><span class="line">00000076dbdbd500 00007ffd5c4e31b1 Kingdee.BOS.App.Data.DBUtils.ExecuteReader(Kingdee.BOS.Context, System.String, System.Collections.Generic.IEnumerable&#96;1, System.Data.CommandType, System.Data.CommandBehavior, Boolean)</span><br><span class="line">00000076dbdbd570 00007ffd5c51d2a7 Kingdee.BOS.App.Data.DBUtils.ExecuteReader(Kingdee.BOS.Context, System.String, System.Collections.Generic.IEnumerable&#96;1, System.Data.CommandType, Boolean)</span><br><span class="line">00000076dbdbd5b0 00007ffd5c51d2fc Kingdee.BOS.App.Data.DBUtils.ExecuteReader(Kingdee.BOS.Context, System.String, System.Data.CommandType, Boolean)</span><br><span class="line">00000076dbdbd5e0 00007ffd5c51d341 Kingdee.BOS.App.Data.DBUtils.ExecuteReader(Kingdee.BOS.Context, System.String)</span><br><span class="line">00000076dbdbd610 00007ffd5ca5a5d4 Kingdee.BOS.App.Core.MainConsole.MainConsoleServer.GetSearchMenuData(Kingdee.BOS.Context, System.String, System.Collections.Generic.HashSet&#96;1 ByRef, System.Collections.Generic.HashSet&#96;1 ByRef)</span><br><span class="line">00000076dbdbd7d0 00007ffd5ca58164 Kingdee.BOS.App.Core.MainConsole.MainConsoleServer.GetMenuArrayForCache(Kingdee.BOS.Context)</span><br><span class="line">00000076dbdbda78 00007ffdbb4f6793 [DebuggerU2MCatchHandlerFrame: 00000076dbdbda78] </span><br><span class="line">00000076dbdbddb8 00007ffdbb4f6793 [HelperMethodFrame_PROTECTOBJ: 00000076dbdbddb8] System.RuntimeMethodHandle.InvokeMethod(System.Object, System.Object[], System.Signature, Boolean)</span><br><span class="line">00000076dbdbdf30 00007ffdb914b690 System.Reflection.RuntimeMethodInfo.UnsafeInvokeInternal(System.Object, System.Object[], System.Object[]) [f:\dd\ndp\clr\src\BCL\system\reflection\methodinfo.cs @ 761]</span><br><span class="line">00000076dbdbdfa0 00007ffdb9142922 System.Reflection.RuntimeMethodInfo.Invoke(System.Object, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo) [f:\dd\ndp\clr\src\BCL\system\reflection\methodinfo.cs @ 735]</span><br><span class="line">00000076dbdbe020 00007ffdb9143f22 System.Reflection.MethodBase.Invoke(System.Object, System.Object[]) [f:\dd\ndp\clr\src\BCL\system\reflection\methodbase.cs @ 211]</span><br><span class="line">00000076dbdbe060 00007ffd5c61990c Microsoft.Practices.Unity.InterceptionExtension.InterceptingRealProxy+c__DisplayClass1.b__0(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextInterceptionBehaviorDelegate)</span><br><span class="line">00000076dbdbe160 00007ffd5c619477 Microsoft.Practices.Unity.InterceptionExtension.PolicyInjectionBehavior+c__DisplayClass1.b__0(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbdbe200 00007ffd5c61cbc4 Kingdee.BOS.Cache.KCacheMethodCallHandler.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbdbe350 00007ffd5c61b10b Kingdee.BOS.Performance.Publisher.PerformanceCallHandler.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbdbe3e0 00007ffd5c61b10b Kingdee.BOS.Performance.Publisher.PerformanceCallHandler.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbdbe470 00007ffd5c61b10b Kingdee.BOS.Performance.Publisher.PerformanceCallHandler.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbdbe500 00007ffd5c61936d Microsoft.Practices.Unity.InterceptionExtension.HandlerPipeline.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.InvokeHandlerDelegate)</span><br><span class="line">00000076dbdbe590 00007ffd5c618999 Microsoft.Practices.Unity.InterceptionExtension.PolicyInjectionBehavior.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextInterceptionBehaviorDelegate)</span><br><span class="line">00000076dbdbe620 00007ffd5c61845d Microsoft.Practices.Unity.InterceptionExtension.InterceptionBehaviorPipeline.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.InvokeInterceptionBehaviorDelegate)</span><br><span class="line">00000076dbdbe6b0 00007ffd5c617002 Microsoft.Practices.Unity.InterceptionExtension.InterceptingRealProxy.Invoke(System.Runtime.Remoting.Messaging.IMessage)</span><br><span class="line">00000076dbdbe790 00007ffdb911190c System.Runtime.Remoting.Proxies.RealProxy.PrivateInvoke(System.Runtime.Remoting.Proxies.MessageData ByRef, Int32) [f:\dd\ndp\clr\src\BCL\system\runtime\remoting\realproxy.cs @ 823]</span><br><span class="line">00000076dbdbe980 00007ffdbb4f4a02 [TPMethodFrame: 00000076dbdbe980] Kingdee.BOS.Contracts.IMainConsoleServer.GetMenuArrayForCache(Kingdee.BOS.Context)</span><br><span class="line">00000076dbdbec00 00007ffdb91ad436 System.Threading.Tasks.Task.Execute() [f:\dd\ndp\clr\src\BCL\system\threading\Tasks\Task.cs @ 2498]</span><br><span class="line">00000076dbdbec40 00007ffdb915ca72 System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean) [f:\dd\ndp\clr\src\BCL\system\threading\executioncontext.cs @ 954]</span><br><span class="line">00000076dbdbed10 00007ffdb915c904 System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean) [f:\dd\ndp\clr\src\BCL\system\threading\executioncontext.cs @ 902]</span><br><span class="line">00000076dbdbed40 00007ffdb91ad6dc System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef) [f:\dd\ndp\clr\src\BCL\system\threading\Tasks\Task.cs @ 2827]</span><br><span class="line">00000076dbdbedf0 00007ffdb91acdf3 System.Threading.Tasks.Task.ExecuteEntry(Boolean) [f:\dd\ndp\clr\src\BCL\system\threading\Tasks\Task.cs @ 2767]</span><br><span class="line">00000076dbdbee30 00007ffdb9194882 System.Threading.ThreadPoolWorkQueue.Dispatch() [f:\dd\ndp\clr\src\BCL\system\threading\threadpool.cs @ 820]</span><br><span class="line">00000076dbdbf2c8 00007ffdbb4f6793 [DebuggerU2MCatchHandlerFrame: 00000076dbdbf2c8] </span><br><span class="line">00000076dbdbf458 00007ffdbb4f6793 [ContextTransitionFrame: 00000076dbdbf458] </span><br><span class="line">00000076dbdbf688 00007ffdbb4f6793 [DebuggerU2MCatchHandlerFrame: 00000076dbdbf688] </span><br><span class="line">OS Thread Id: 0x153c (135)</span><br><span class="line">        Child SP               IP Call Site</span><br><span class="line">GetFrameContext failed: 1</span><br><span class="line">0000000000000000 0000000000000000 </span><br><span class="line">OS Thread Id: 0x242c (136)</span><br><span class="line">        Child SP               IP Call Site</span><br><span class="line">GetFrameContext failed: 1</span><br><span class="line">0000000000000000 0000000000000000 </span><br><span class="line">OS Thread Id: 0x153c (135)</span><br><span class="line">        Child SP               IP Call Site</span><br><span class="line">GetFrameContext failed: 1</span><br><span class="line">0000000000000000 0000000000000000 </span><br><span class="line">OS Thread Id: 0x242c (136)</span><br><span class="line">        Child SP               IP Call Site</span><br><span class="line">GetFrameContext failed: 1</span><br><span class="line">0000000000000000 0000000000000000 </span><br><span class="line">OS Thread Id: 0x2a04 (137)</span><br><span class="line">        Child SP               IP Call Site</span><br><span class="line">00000076dbf7af08 00007ffdca2e6124 [InlinedCallFrame: 00000076dbf7af08] .SNIReadSyncOverAsync(SNI_ConnWrapper*, SNI_Packet**, Int32)</span><br><span class="line">00000076dbf7af08 00007ffdaaaf5dd4 [InlinedCallFrame: 00000076dbf7af08] .SNIReadSyncOverAsync(SNI_ConnWrapper*, SNI_Packet**, Int32)</span><br><span class="line">00000076dbf7aee0 00007ffdaaaf5dd4 DomainNeutralILStubClass.IL_STUB_PInvoke(SNI_ConnWrapper*, SNI_Packet**, Int32)</span><br><span class="line">00000076dbf7af90 00007ffdaab08fe3 SNINativeMethodWrapper.SNIReadSyncOverAsync(System.Runtime.InteropServices.SafeHandle, IntPtr ByRef, Int32)</span><br><span class="line">00000076dbf7aff0 00007ffdaabe0ae0 System.Data.SqlClient.TdsParserStateObject.ReadSniSyncOverAsync()</span><br><span class="line">00000076dbf7b050 00007ffdaabe09dd System.Data.SqlClient.TdsParserStateObject.TryReadNetworkPacket()</span><br><span class="line">00000076dbf7b090 00007ffdaabdf7f5 System.Data.SqlClient.TdsParserStateObject.TryPrepareBuffer()</span><br><span class="line">00000076dbf7b0d0 00007ffdaabdfa0e System.Data.SqlClient.TdsParserStateObject.TryReadByte(Byte ByRef)</span><br><span class="line">00000076dbf7b110 00007ffdaabc7daa System.Data.SqlClient.TdsParser.TryRun(System.Data.SqlClient.RunBehavior, System.Data.SqlClient.SqlCommand, System.Data.SqlClient.SqlDataReader, System.Data.SqlClient.BulkCopySimpleResultSet, System.Data.SqlClient.TdsParserStateObject, Boolean ByRef)</span><br><span class="line">00000076dbf7b270 00007ffdaabbb3c7 System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()</span><br><span class="line">00000076dbf7b2d0 00007ffdaabb8325 System.Data.SqlClient.SqlDataReader.get_MetaData()</span><br><span class="line">00000076dbf7b320 00007ffdaab3be73 System.Data.SqlClient.SqlCommand.FinishExecuteReader(System.Data.SqlClient.SqlDataReader, System.Data.SqlClient.RunBehavior, System.String, Boolean, Boolean)</span><br><span class="line">00000076dbf7b390 00007ffdaab3b75f System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(System.Data.CommandBehavior, System.Data.SqlClient.RunBehavior, Boolean, Boolean, Int32, System.Threading.Tasks.Task ByRef, Boolean, Boolean, System.Data.SqlClient.SqlDataReader, Boolean)</span><br><span class="line">00000076dbf7b470 00007ffdaab3a763 System.Data.SqlClient.SqlCommand.RunExecuteReader(System.Data.CommandBehavior, System.Data.SqlClient.RunBehavior, Boolean, System.String, System.Threading.Tasks.TaskCompletionSource&#96;1, Int32, System.Threading.Tasks.Task ByRef, Boolean ByRef, Boolean, Boolean)</span><br><span class="line">00000076dbf7b540 00007ffdaab3a49b System.Data.SqlClient.SqlCommand.RunExecuteReader(System.Data.CommandBehavior, System.Data.SqlClient.RunBehavior, Boolean, System.String)</span><br><span class="line">00000076dbf7b5e0 00007ffdaab35cc6 System.Data.SqlClient.SqlCommand.ExecuteReader(System.Data.CommandBehavior, System.String)</span><br><span class="line">00000076dbf7b670 00007ffd5c517ead Kingdee.BOS.App.Data.AbstractDatabase.DoExecuteReader(System.Data.Common.DbCommand, System.Data.CommandBehavior)</span><br><span class="line">00000076dbf7b6d0 00007ffd5c515ebb Kingdee.BOS.App.Data.AbstractDatabase.ExecuteReader(System.Data.Common.DbCommand, System.Collections.Generic.IEnumerable&#96;1, System.Data.CommandBehavior, Boolean)</span><br><span class="line">00000076dbf7b750 00007ffd5c4fd6f2 Kingdee.BOS.App.Data.AbstractDatabase.ExecuteReader(System.Data.Common.DbCommand, System.Collections.Generic.IEnumerable&#96;1, System.Data.CommandBehavior)</span><br><span class="line">00000076dbf7b780 00007ffd5c4e31b1 Kingdee.BOS.App.Data.DBUtils.ExecuteReader(Kingdee.BOS.Context, System.String, System.Collections.Generic.IEnumerable&#96;1, System.Data.CommandType, System.Data.CommandBehavior, Boolean)</span><br><span class="line">00000076dbf7b7f0 00007ffd5c51d2a7 Kingdee.BOS.App.Data.DBUtils.ExecuteReader(Kingdee.BOS.Context, System.String, System.Collections.Generic.IEnumerable&#96;1, System.Data.CommandType, Boolean)</span><br><span class="line">00000076dbf7b830 00007ffd5c61737a Kingdee.BOS.App.Data.DBUtils.ExecuteReader(Kingdee.BOS.Context, System.String, System.Collections.Generic.List&#96;1)</span><br><span class="line">00000076dbf7b860 00007ffd5c8d2bd7 Kingdee.BOS.App.Core.UserParameterService.GetParamter(Kingdee.BOS.Context, Int64, System.String, System.String)</span><br><span class="line">00000076dbf7bb68 00007ffdbb4f6793 [DebuggerU2MCatchHandlerFrame: 00000076dbf7bb68] </span><br><span class="line">00000076dbf7bea8 00007ffdbb4f6793 [HelperMethodFrame_PROTECTOBJ: 00000076dbf7bea8] System.RuntimeMethodHandle.InvokeMethod(System.Object, System.Object[], System.Signature, Boolean)</span><br><span class="line">00000076dbf7c020 00007ffdb914b690 System.Reflection.RuntimeMethodInfo.UnsafeInvokeInternal(System.Object, System.Object[], System.Object[]) [f:\dd\ndp\clr\src\BCL\system\reflection\methodinfo.cs @ 761]</span><br><span class="line">00000076dbf7c090 00007ffdb9142922 System.Reflection.RuntimeMethodInfo.Invoke(System.Object, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo) [f:\dd\ndp\clr\src\BCL\system\reflection\methodinfo.cs @ 735]</span><br><span class="line">00000076dbf7c110 00007ffdb9143f22 System.Reflection.MethodBase.Invoke(System.Object, System.Object[]) [f:\dd\ndp\clr\src\BCL\system\reflection\methodbase.cs @ 211]</span><br><span class="line">00000076dbf7c150 00007ffd5c61990c Microsoft.Practices.Unity.InterceptionExtension.InterceptingRealProxy+c__DisplayClass1.b__0(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextInterceptionBehaviorDelegate)</span><br><span class="line">00000076dbf7c250 00007ffd5c619477 Microsoft.Practices.Unity.InterceptionExtension.PolicyInjectionBehavior+c__DisplayClass1.b__0(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbf7c2f0 00007ffd5c61cbc4 Kingdee.BOS.Cache.KCacheMethodCallHandler.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbf7c440 00007ffd5c61b10b Kingdee.BOS.Performance.Publisher.PerformanceCallHandler.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbf7c4d0 00007ffd5c61b10b Kingdee.BOS.Performance.Publisher.PerformanceCallHandler.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbf7c560 00007ffd5c61b10b Kingdee.BOS.Performance.Publisher.PerformanceCallHandler.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbf7c5f0 00007ffd5c61936d Microsoft.Practices.Unity.InterceptionExtension.HandlerPipeline.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.InvokeHandlerDelegate)</span><br><span class="line">00000076dbf7c680 00007ffd5c618999 Microsoft.Practices.Unity.InterceptionExtension.PolicyInjectionBehavior.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextInterceptionBehaviorDelegate)</span><br><span class="line">00000076dbf7c710 00007ffd5c61845d Microsoft.Practices.Unity.InterceptionExtension.InterceptionBehaviorPipeline.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.InvokeInterceptionBehaviorDelegate)</span><br><span class="line">00000076dbf7c7a0 00007ffd5c617002 Microsoft.Practices.Unity.InterceptionExtension.InterceptingRealProxy.Invoke(System.Runtime.Remoting.Messaging.IMessage)</span><br><span class="line">00000076dbf7c880 00007ffdb911190c System.Runtime.Remoting.Proxies.RealProxy.PrivateInvoke(System.Runtime.Remoting.Proxies.MessageData ByRef, Int32) [f:\dd\ndp\clr\src\BCL\system\runtime\remoting\realproxy.cs @ 823]</span><br><span class="line">00000076dbf7ca70 00007ffdbb4f4a02 [TPMethodFrame: 00000076dbf7ca70] Kingdee.BOS.Contracts.IUserParameterService.GetParamter(Kingdee.BOS.Context, Int64, System.String, System.String)</span><br><span class="line">00000076dbf7ccf0 00007ffd5c8d28c5 Kingdee.BOS.App.Security.K3CloudLoginService.SetRegionInfo(Kingdee.BOS.Context, Kingdee.BOS.Contracts.IUserParameterService, Kingdee.BOS.Orm.DataEntity.DynamicObject)</span><br><span class="line">00000076dbf7cd70 00007ffd5c22b2e2 Kingdee.BOS.App.Security.K3DataCenterService.GetDataCenterContextByID(System.String)</span><br><span class="line">00000076dbf7cdc0 00007ffd5c227d97 Kingdee.BOS.App.Security.K3CloudLoginService+c__DisplayClass8.b__3(System.String)</span><br><span class="line">00000076dbf7cdf0 00007ffd5c228471 Kingdee.BOS.Core.Authentication.AbstractAuthService.LoadContext(Kingdee.BOS.Core.Authentication.LoadContextArg)</span><br><span class="line">00000076dbf7ce50 00007ffd5c226ed8 Kingdee.BOS.App.Security.K3CloudLoginService.Login(Kingdee.BOS.Performance.Common.PerformanceContext, Kingdee.BOS.Authentication.LoginInfo)</span><br><span class="line">00000076dbf7ced0 00007ffd5c20b5a9 Kingdee.BOS.ServiceHelper.LoginServiceHelper.Login(Kingdee.BOS.Performance.Common.PerformanceContext, System.String, Kingdee.BOS.Authentication.LoginInfo)</span><br><span class="line">00000076dbf7cf30 00007ffd5c20960f Kingdee.BOS.WebApi.ServicesStub.AuthService.ValidateLoginInfo(System.String, Kingdee.BOS.Authentication.LoginInfo)</span><br><span class="line">00000076dbf7d080 00007ffd5c20783c Kingdee.BOS.WebApi.ServicesStub.AuthService.ValidateUser(System.String, System.String, System.String, Int32)</span><br><span class="line">00000076dbf7d318 00007ffdbb4f6793 [DebuggerU2MCatchHandlerFrame: 00000076dbf7d318] </span><br><span class="line">00000076dbf7d658 00007ffdbb4f6793 [HelperMethodFrame_PROTECTOBJ: 00000076dbf7d658] System.RuntimeMethodHandle.InvokeMethod(System.Object, System.Object[], System.Signature, Boolean)</span><br><span class="line">00000076dbf7d7d0 00007ffdb914b690 System.Reflection.RuntimeMethodInfo.UnsafeInvokeInternal(System.Object, System.Object[], System.Object[]) [f:\dd\ndp\clr\src\BCL\system\reflection\methodinfo.cs @ 761]</span><br><span class="line">00000076dbf7d840 00007ffdb9142922 System.Reflection.RuntimeMethodInfo.Invoke(System.Object, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo) [f:\dd\ndp\clr\src\BCL\system\reflection\methodinfo.cs @ 735]</span><br><span class="line">00000076dbf7d8c0 00007ffd5c206201 Kingdee.BOS.ServiceFacade.KDServiceFx.ServiceExecutor.Execute(Kingdee.BOS.ServiceFacade.KDServiceFx.KDServiceContext, Kingdee.BOS.ServiceFacade.KDServiceFx.ServiceType, System.String[], Kingdee.BOS.ServiceFacade.SerializerProxy, Kingdee.BOS.ServiceFacade.KDServiceFx.ServiceType)</span><br><span class="line">00000076dbf7d960 00007ffd5c203ea9 Kingdee.BOS.ServiceFacade.KDServiceFx.ExecuteServiceModule.OnProcess(Kingdee.BOS.ServiceFacade.KDServiceFx.KDServiceContext)</span><br><span class="line">00000076dbf7da00 00007ffd5c203ab8 Kingdee.BOS.ServiceFacade.KDServiceFx.ModulePipeline.ExcuteRequest(Kingdee.BOS.ServiceFacade.KDServiceFx.KDServiceContext)</span><br><span class="line">00000076dbf7da50 00007ffd5c20123e Kingdee.BOS.ServiceFacade.KDServiceFx.RequestExcuteRuntime.StartRequest(Kingdee.BOS.ServiceFacade.KDServiceFx.RequestExtractor, Kingdee.BOS.ServiceFacade.KDServiceFx.WebContext)</span><br><span class="line">00000076dbf7daa0 00007ffd5c200f00 Kingdee.BOS.ServiceFacade.KDServiceFx.KDSVCHandler.ExecuteRequest(Kingdee.BOS.ServiceFacade.KDServiceFx.WebContext, Kingdee.BOS.ServiceFacade.KDServiceFx.RequestExtractor)</span><br><span class="line">00000076dbf7dae0 00007ffd5c200d45 Kingdee.BOS.ServiceFacade.KDServiceFx.KDSVCHandler.ProcessRequestInternal(Kingdee.BOS.ServiceFacade.KDServiceFx.WebContext, Kingdee.BOS.ServiceFacade.KDServiceFx.RequestExtractor)</span><br><span class="line">00000076dbf7db30 00007ffdac1a373e *** WARNING: Unable to verify checksum for System.Web.ni.dll</span><br><span class="line">System.Web.HttpApplication+CallHandlerExecutionStep.System.Web.HttpApplication.IExecutionStep.Execute()</span><br><span class="line">00000076dbf7dbc0 00007ffdac1633fb System.Web.HttpApplication.ExecuteStep(IExecutionStep, Boolean ByRef)</span><br><span class="line">00000076dbf7dc10 00007ffdac178220 System.Web.HttpApplication+PipelineStepManager.ResumeSteps(System.Exception)</span><br><span class="line">00000076dbf7dd70 00007ffdac163f79 System.Web.HttpApplication.BeginProcessRequestNotification(System.Web.HttpContext, System.AsyncCallback)</span><br><span class="line">00000076dbf7ddc0 00007ffdac1766c3 System.Web.HttpRuntime.ProcessRequestNotificationPrivate(System.Web.Hosting.IIS7WorkerRequest, System.Web.HttpContext)</span><br><span class="line">00000076dbf7de40 00007ffdac165398 System.Web.Hosting.PipelineRuntime.ProcessRequestNotificationHelper(IntPtr, IntPtr, IntPtr, Int32)</span><br><span class="line">00000076dbf7e000 00007ffdac164f63 System.Web.Hosting.PipelineRuntime.ProcessRequestNotification(IntPtr, IntPtr, IntPtr, Int32)</span><br><span class="line">00000076dbf7e040 00007ffdac8646ba DomainNeutralILStubClass.IL_STUB_ReversePInvoke(Int64, Int64, Int64, Int32)</span><br><span class="line">00000076dbf7e8b0 00007ffdbb4f21fe [InlinedCallFrame: 00000076dbf7e8b0] System.Web.Hosting.UnsafeIISMethods.MgdIndicateCompletion(IntPtr, System.Web.RequestNotificationStatus ByRef)</span><br><span class="line">00000076dbf7e8b0 00007ffdac1d2dde [InlinedCallFrame: 00000076dbf7e8b0] System.Web.Hosting.UnsafeIISMethods.MgdIndicateCompletion(IntPtr, System.Web.RequestNotificationStatus ByRef)</span><br><span class="line">00000076dbf7e880 00007ffdac1d2dde DomainNeutralILStubClass.IL_STUB_PInvoke(IntPtr, System.Web.RequestNotificationStatus ByRef)</span><br><span class="line">00000076dbf7e940 00007ffdac16556f System.Web.Hosting.PipelineRuntime.ProcessRequestNotificationHelper(IntPtr, IntPtr, IntPtr, Int32)</span><br><span class="line">00000076dbf7eb00 00007ffdac164f63 System.Web.Hosting.PipelineRuntime.ProcessRequestNotification(IntPtr, IntPtr, IntPtr, Int32)</span><br><span class="line">00000076dbf7eb40 00007ffdac8646ba DomainNeutralILStubClass.IL_STUB_ReversePInvoke(Int64, Int64, Int64, Int32)</span><br><span class="line">00000076dbf7ed18 00007ffdbb4f2453 [ContextTransitionFrame: 00000076dbf7ed18]</span><br></pre></td></tr></table></figure>
<p>通过仔细比对发现这么一条<code>Kingdee.BOS.App.Core.MainConsole.MainConsoleServer.GetMenuArrayForCache(Kingdee.BOS.Context)</code>调用堆栈。从方法命名来看，像是用来获取菜单数组并缓存。结合前后堆栈的联系，我们可以大致得出这样一个线索：<strong>用户使用WebApi登录后会缓存一份独立的菜单供用户使用</strong>。</p>
<p>有了代码堆栈，接下来知道怎么干了吧？当然是核实源代码确定问题啊。</p>
<h1 id="4-分析源码验证问题"><a href="#4-分析源码验证问题" class="headerlink" title="4. 分析源码验证问题"></a>4. 分析源码验证问题</h1><p><code>Kingdee.BOS.App.Core.MainConsole.MainConsoleServer.GetMenuArrayForCache(Kingdee.BOS.Context)</code>方法源代码如下：<br><img src="/images/use-windbg-to-analyze-high-memory-issue/2799767-6b4c4abbb111e312.png" alt="GetMenuArrayForCache"></p>
<p>我们发现它是用的<code>UserToken</code>来缓存用户菜单。看到<code>Token</code>，你可能就会条件反射的想到其生命周期。是的，聪明贤惠如你，Token是有生命周期的。也就意味着Token过期后，下次登录还会再次缓存一份菜单。你可能会问Token过期后没有去清对应的菜单缓存吗？是的，并没有。</p>
<p>严谨的你，可能又会问Token多久过期？20mins。你眼珠子一转，接着问，满打满算，一个用户1个小时也就申请3次Token，24小时，也就申请72个Token，一个菜单缓存也就顶多1K，所以一个用户一天也就最多占用72K。你的网站得有多少并发，才能被这么多菜单缓存撑爆啊？！</p>
<p>Good Question！！！</p>
<p>是的，客户的应用场景的并发也就顶多几百而已。那到底是什么导致如此多的菜单缓存呢？</p>
<p>原因是，客户的第三方客户端使用WebApi与我们的系统对接。而每次调用WebApi时都会先去调用登录接口，但却未保存会话信息。也就是说，客户第三方客户端每次的WebApi调用都会产生一个新的Token。那如果有成千上万的WebApi请求，也就意味着成千上万的菜单缓存啊。</p>
<p>好了，点到为止。至此，已经基本定位到问题的根源了。</p>
<h1 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h1><p>也许很多同学没有接触过WinDbg，觉得其是一个复杂的工具。其实通过本文的案例讲解，其无非是通过一系列常见的命令来进行问题跟踪来定位问题。</p>
<p>最后来简单总结下，Windbg分析问题的步骤：</p>
<ol>
<li>创建完整Dump文件</li>
<li>Windbg加载Dump文件</li>
<li>根据不同问题类型，使用相关的命令进行分析</li>
<li>耐心分析，抽丝剥茧</li>
<li>边分析边猜测边验证</li>
<li>结合源码验证猜想</li>
<li>修复验证</li>
</ol>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>WinDbg</tag>
      </tags>
  </entry>
</search>
