<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>五分钟快速搭建Serverless免费邮件服务</title>
    <url>/post/build-your-first-serverless-free-email-service-with-azure-function/</url>
    <content><![CDATA[<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-508cd8bd0a9c2fe7.png" alt=""></p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>本文将带你快速基于 Azure Function 和 SendGrid 构建一个免费的Serverless（无服务器）的邮件发送服务，让你感受下Serverless的强大之处。</p>
<p>该服务可以<strong>每月免费发送2,5000封</strong>，这是完全白嫖啊，感兴趣的，赶紧动起你的小手爪，噼里啪啦搞起来呀。</p>
<h1 id="2-创建-SendGrid-账号"><a href="#2-创建-SendGrid-账号" class="headerlink" title="2. 创建 SendGrid 账号"></a>2. 创建 SendGrid 账号</h1><p><em>你要有一个Azure账号，没有的话，花几分钟自行注册一个就好。(我的账号注册在香港区域)</em></p>
<p>咱们先来创建一个<strong>SendGrid Accounts</strong>，如下图所示。点击SendGrid Accounts后，再点击创建SendGrid account。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-48afba14c71a05c2.png" alt="SendGrid Accounts"></p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-83453108dc39e87f.png" alt="Create SendGrid Account"></p>
<p>填写完毕后，点击Review+Create，稍等片刻，提示部署成功，那么恭喜你，可以接着往下玩耍了。如果部署失败，可能会因为SendGrid屏蔽了某些区域的账号创建，就只能重新注册个Azure账号玩耍了。</p>
<p>紧接着，前往刚刚创建的SendGrid Account，点击Manage会跳转至SendGrid管理面板。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-8ff7849d28bd0cee.png" alt="SendGrid Account"></p>
<p>打开后，会要求你进去邮件验证，自行前往邮箱验证即可。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-cd231fc9c9e1a91c.png" alt="SendGrid Dashboard"></p>
<p>点击API Keys，然后点击Create API Key，填写API Key Name，选择 Full Access，点击Create&amp;View，记下生成的API Key，后面需要用到。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-19e799cbfe57546a.png" alt="创建ApiKey"></p>
<h1 id="3-创建第一个函数应用"><a href="#3-创建第一个函数应用" class="headerlink" title="3. 创建第一个函数应用"></a>3. 创建第一个函数应用</h1><p>回到Azure控制台，然后搜索<strong>函数应用</strong>。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-0baff2aa7153f3e3.png" alt="搜索函数应用"></p>
<p>打开后点击添加，按以下图示进行创建。其中务必选择以代码发布，承载的操作系统选择Windows。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-8ca4cc1a0e8c637f.png" alt="Create Azure Function"></p>
<p>创建成功后，转到资源，如下图所示：</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-c725525dd929a9a5.png" alt="Azure Function"></p>
<p>依次点击函数，添加，选择HTTP trigger模板，填写函数名称，然后指定身份验证级别。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-965ad86a3747bae3.png" alt="Create HTTP trigger"></p>
<p>点击创建，创建成功后，跳转到函数页面，点击获取函数URL，粘贴URL到浏览器就可以访问到你创建的第一个函数应用。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-182870212f9d7667.png" alt="First Httptrigger Function"></p>
<p>点击代码+测试，就可以看到模板代码，如下图所示：</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-0207fff5a0b8b049.png" alt="Httptrigger 模板代码"></p>
<p>从截图来看，这个和C#的语法并无太大差别，官方称为C#脚本。</p>
<p>紧接着替换<code>run.csx</code>为以下代码并点击保存：</p>
<p>紧接着替换<code>run.csx</code>为以下代码并点击保存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;run.csx</span><br><span class="line">#r &quot;Newtonsoft.Json&quot;</span><br><span class="line">#r &quot;SendGrid&quot;</span><br><span class="line"></span><br><span class="line">using System.Net;</span><br><span class="line">using Microsoft.Azure.WebJobs.Host;</span><br><span class="line">using SendGrid.Helpers.Mail;</span><br><span class="line">using Microsoft.Extensions.Primitives;</span><br><span class="line">using Newtonsoft.Json;</span><br><span class="line"></span><br><span class="line">public static SendGridMessage Run(Email req, ILogger log)</span><br><span class="line">&#123;</span><br><span class="line">    var reqStr &#x3D; JsonConvert.SerializeObject(req);</span><br><span class="line">    log.LogInformation(reqStr);</span><br><span class="line"></span><br><span class="line">    var message &#x3D; new SendGridMessage();</span><br><span class="line">    message.AddTo(req.To);</span><br><span class="line">    message.AddContent(&quot;text&#x2F;html&quot;, req.Body);</span><br><span class="line">    message.SetFrom(new EmailAddress(req.From));</span><br><span class="line">    message.SetSubject(req.Subject);</span><br><span class="line">    return message;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Email</span><br><span class="line">&#123;</span><br><span class="line">    public string To &#123; get; set; &#125;</span><br><span class="line">    public string From &#123; get; set; &#125;</span><br><span class="line">    public string Subject &#123; get; set; &#125;</span><br><span class="line">    public string Body &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后修改<code>function.json</code>中的配置如下，并保存。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;bindings&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;authLevel&quot;: &quot;function&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;req&quot;,</span><br><span class="line">      &quot;type&quot;: &quot;httpTrigger&quot;,</span><br><span class="line">      &quot;direction&quot;: &quot;in&quot;,</span><br><span class="line">      &quot;methods&quot;: [</span><br><span class="line">        &quot;get&quot;,</span><br><span class="line">        &quot;post&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;sendGrid&quot;,</span><br><span class="line">      &quot;name&quot;: &quot;$return&quot;,</span><br><span class="line">      &quot;direction&quot;: &quot;out&quot;,</span><br><span class="line">      &quot;apiKey&quot;: &quot;SendGridAPIKeyAsAppSetting&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意观察配置项中需要指定<code>apiKey</code>，就是我们上面创建SendGrid Account 中对应的ApiKey。回到上面创建的Azure Function 应用服务，然后按下图添加上面发邮件函数需要的配置项，如下所示。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-2e75613d39c9277e.png" alt="添加配置项"></p>
<p>添加完毕后，再回到函数中就可以测试运行了，如下图所示：</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-8226414351eae530.png" alt=""></p>
<p>查收邮件，你将收到来自Azure Function &amp; SendGrid 的免费问候。</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-cf4dc9e150c3c981.png" alt="查收邮件"></p>
<p>当然，也可以通过Postman自行验证：</p>
<p><img src="/images/build-your-first-serverless-free-email-service-with-azure-function/2799767-f4f04ec45f023c3f.png" alt="Postman"></p>
<h1 id="4-最后"><a href="#4-最后" class="headerlink" title="4.最后"></a>4.最后</h1><p>通过以上的连环操作，相信你不仅成功薅了一把微软的羊毛，而且顺带对<strong>Serverless</strong>也有了一定的认知。</p>
<p>如果对Azure Function感兴趣的，不妨参考<a href="https://docs.microsoft.com/en-us/azure/azure-functions/" target="_blank" rel="noopener">官方文档</a>研究一番，相信你会发掘不少玩法，顺便再薅它几把羊毛，哈哈哈！</p>
]]></content>
      <categories>
        <category>技术积累</category>
      </categories>
      <tags>
        <tag>Serverless</tag>
      </tags>
  </entry>
  <entry>
    <title>MediatR 知多少</title>
    <url>/post/how-much-you-know-about-the-MediatR/</url>
    <content><![CDATA[<p><img src="/images/how-much-you-know-about-the-MediatR/2799767-81f47b8d28199687.png" alt=""></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>首先不用查字典了，词典查无此词。猜测是作者笔误将<strong>Mediator</strong>写成MediatR了。废话少说，转入正题。</p>
<p>先来简单了解下这个开源项目<a href="https://github.com/jbogard/MediatR" target="_blank" rel="noopener">MediatR</a>（作者Jimmy Bogard，也是开源项目AutoMapper的创建者，在此表示膜拜）：</p>
<blockquote>
<p>Simple mediator implementation in .NET. In-process messaging with no dependencies. Supports request/response, commands, queries, notifications and events, synchronous and async with intelligent dispatching via C# generic variance.<br><em>.NET中的简单中介者模式实现，一种进程内消息传递机制（无其他外部依赖）。 支持以同步或异步的形式进行请求/响应，命令，查询，通知和事件的消息传递，并通过C#泛型支持消息的智能调度。</em></p>
</blockquote>
<p>如上所述，其核心是一个中介者模式的.NET实现，其目的是消息发送和消息处理的解耦。它支持以单播和多播形式使用同步或异步的模式来发布消息，创建和侦听事件。</p>
<h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><p>既然是对中介者模式的一种实现，那么我们就有必要简要介绍下中介者这个设计模式，以便后续展开。<br><img src="/images/how-much-you-know-about-the-MediatR/2799767-6165cec43764d9cd.png" alt="中介者模式类图"></p>
<blockquote>
<p>中介者模式：用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互。</p>
</blockquote>
<p>看上面的官方定义可能还是有点绕，那么下面这张图应该能帮助你对中介者模式有个直观了解。<br><img src="/images/how-much-you-know-about-the-MediatR/2799767-306109184e4beaa6.png" alt=""></p>
<p>使用中介模式，对象之间的交互将封装在中介对象中。对象不再直接相互交互（解耦），而是通过中介进行交互。这减少了对象之间的依赖性，从而减少了耦合。</p>
<p>那其优缺点也在图中很容易看出：</p>
<blockquote>
<p><strong>优点</strong>：中介者模式的优点就是减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者，减少了依赖，当然同时也降低了类间的耦合<br><strong>缺点</strong>：中介者模式的缺点就是中介者会膨胀得很大，而且逻辑复杂，原本N个对象直接的相互依赖关系转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越复杂。</p>
</blockquote>
<h1 id="Hello-MeidatR"><a href="#Hello-MeidatR" class="headerlink" title="Hello MeidatR"></a>Hello MeidatR</h1><p>在开始之前，我们先来了解下其基本用法。</p>
<h2 id="单播消息传输"><a href="#单播消息传输" class="headerlink" title="单播消息传输"></a>单播消息传输</h2><p>单播消息传输，也就是一对一的消息传递，一个消息对应一个消息处理。其通过<code>IRequest</code>来抽象单播消息，用<code>IRequestHandler</code>进行消息处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;构建 消息请求</span><br><span class="line">public class Ping : IRequest&lt;string&gt; &#123; &#125;</span><br><span class="line">&#x2F;&#x2F;构建 消息处理</span><br><span class="line">public class PingHandler : IRequestHandler&lt;Ping, string&gt; &#123;</span><br><span class="line">    public Task&lt;string&gt; Handle(Ping request, CancellationToken cancellationToken) &#123;</span><br><span class="line">        return Task.FromResult(&quot;Pong&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;发送 请求</span><br><span class="line">var response &#x3D; await mediator.Send(new Ping());</span><br><span class="line">Debug.WriteLine(response); &#x2F;&#x2F; &quot;Pong&quot;</span><br></pre></td></tr></table></figure>

<h2 id="多播消息传输"><a href="#多播消息传输" class="headerlink" title="多播消息传输"></a>多播消息传输</h2><p>多播消息传输，也就是一对多的消息传递，一个消息对应多个消息处理。其通过<code>INotification</code>来抽象多播消息，对应的消息处理类型为<code>INotificationHandler</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;构建 通知消息</span><br><span class="line">public class Ping : INotification &#123; &#125;</span><br><span class="line">&#x2F;&#x2F;构建 消息处理器1</span><br><span class="line">public class Pong1 : INotificationHandler&lt;Ping&gt; &#123;</span><br><span class="line">    public Task Handle(Ping notification, CancellationToken cancellationToken) &#123;</span><br><span class="line">        Debug.WriteLine(&quot;Pong 1&quot;);</span><br><span class="line">        return Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;构建 消息处理器2</span><br><span class="line">public class Pong2 : INotificationHandler&lt;Ping&gt; &#123;</span><br><span class="line">    public Task Handle(Ping notification, CancellationToken cancellationToken) &#123;</span><br><span class="line">        Debug.WriteLine(&quot;Pong 2&quot;);</span><br><span class="line">        return Task.CompletedTask;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;发布消息</span><br><span class="line">await mediator.Publish(new Ping());</span><br></pre></td></tr></table></figure>

<h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>对MediatR有了基本认识后，我们来看看源码，研究下其如何实现的。</p>
<p><img src="/images/how-much-you-know-about-the-MediatR/2799767-00b8410a546d62e4.png" alt="类图"></p>
<p>从代码图中我们可以看到其核心的对象主要包括：</p>
<ol>
<li>IRequest Vs IRequestHandler</li>
<li>INotification Vs INoticifaitonHandler</li>
<li>IMediator Vs Mediator</li>
<li>Unit</li>
<li>IPipelineBehavior</li>
</ol>
<h2 id="IRequest-Vs-IRequestHandler"><a href="#IRequest-Vs-IRequestHandler" class="headerlink" title="IRequest Vs IRequestHandler"></a>IRequest Vs IRequestHandler</h2><p>其中<code>IRequest</code>和<code>INotification</code>分别对应单播和多播消息的抽象。<br>对于单播消息可以决定是否需要返回值选用不同的接口：</p>
<ul>
<li>IRequest<T> - 有返回值</li>
<li>IRequest - 无返回值</li>
</ul>
<p>这里就不得不提到其中巧妙的设计，通过引入结构类型<code>Unit</code>来代表无返回的情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 代表无需返回值的请求</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public interface IRequest : IRequest&lt;Unit&gt; &#123; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 代表有返回值的请求</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TResponse&quot;&gt;Response type&lt;&#x2F;typeparam&gt;</span><br><span class="line">public interface IRequest&lt;out TResponse&gt; : IBaseRequest &#123; &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; Allows for generic type constraints of objects implementing IRequest or IRequest&#123;TResponse&#125;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public interface IBaseRequest &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>同样对于<code>IRequestHandler</code>也是通过结构类型<code>Unit</code>来处理不需要返回值的情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IRequestHandler&lt;in TRequest, TResponse&gt;</span><br><span class="line">    where TRequest : IRequest&lt;TResponse&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Task&lt;TResponse&gt; Handle(TRequest request, CancellationToken cancellationToken);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface IRequestHandler&lt;in TRequest&gt; : IRequestHandler&lt;TRequest, Unit&gt;</span><br><span class="line">    where TRequest : IRequest&lt;Unit&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面我们可以看出定义了一个方法名为<code>Handle</code>返回值为<code>Task</code>的包装类型，而因此赋予了其具有以同步和异步的方式进行消息处理的能力。我们再看一下其以异步方式进行消息处理（无返回值）的默认实现<code>AsyncRequestHandler</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class AsyncRequestHandler&lt;TRequest&gt; : IRequestHandler&lt;TRequest&gt;</span><br><span class="line">    where TRequest : IRequest</span><br><span class="line">&#123;</span><br><span class="line">    async Task&lt;Unit&gt; IRequestHandler&lt;TRequest, Unit&gt;.Handle(TRequest request, CancellationToken cancellationToken)</span><br><span class="line">    &#123;</span><br><span class="line">        await Handle(request, cancellationToken).ConfigureAwait(false);</span><br><span class="line">        return Unit.Value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected abstract Task Handle(TRequest request, CancellationToken cancellationToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码来看，我们很容易看出这是装饰模式的实现方式，是不是很巧妙的解决了无需返回值的场景。</p>
<p>最后我们来看下结构类型<code>Unit</code>的定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public struct Unit : IEquatable&lt;Unit&gt;, IComparable&lt;Unit&gt;, IComparable</span><br><span class="line">&#123;</span><br><span class="line">    public static readonly Unit Value &#x3D; new Unit();</span><br><span class="line"></span><br><span class="line">    public static readonly Task&lt;Unit&gt; Task &#x3D; System.Threading.Tasks.Task.FromResult(Value);</span><br><span class="line">    &#x2F;&#x2F; some other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="IMediator-Vs-Mediator"><a href="#IMediator-Vs-Mediator" class="headerlink" title="IMediator Vs Mediator"></a>IMediator Vs Mediator</h2><p><img src="/images/how-much-you-know-about-the-MediatR/2799767-19d4eebd2a6dda89.png" alt="MediatR 类图"></p>
<p><code>IMediator</code>主要定义了两个方法<code>Send</code>和<code>Publish</code>，分别用于发送消息和发布通知。其默认实现Mediator中定义了两个集合，分别用来保存请求与请求处理的映射关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Mediator.cs</span><br><span class="line">&#x2F;&#x2F;保存request和requesthandler的映射关系，1对1。</span><br><span class="line">private static readonly ConcurrentDictionary&lt;Type, object&gt; _requestHandlers &#x3D; new ConcurrentDictionary&lt;Type, object&gt;();</span><br><span class="line">&#x2F;&#x2F;保存notification与notificationhandler的映射关系，</span><br><span class="line">private static readonly ConcurrentDictionary&lt;Type, NotificationHandlerWrapper&gt; _notificationHandlers &#x3D; new ConcurrentDictionary&lt;Type, NotificationHandlerWrapper&gt;();</span><br></pre></td></tr></table></figure>
<p>这里面其又引入了两个包装类：<code>RequestHandlerWrapper</code>和<code>NotificationHandlerWrapper</code>。这两个包装类的作用就是用来传递<code>ServiceFactory</code>委托进行依赖解析。</p>
<p>所以说<code>Mediator</code>借助<code>public delegate object ServiceFactory(Type serviceType);</code>完成对Ioc容器的一层抽象。这样就可以对接任意你喜欢用的Ioc容器，比如：Autofac、Windsor或ASP.NET Core默认的Ioc容器，只需要在注册<code>IMediator</code>时指定<code>ServiceFactory</code>类型的委托即可，比如ASP.NET Core中的做法：<br><img src="/images/how-much-you-know-about-the-MediatR/2799767-609f3008b14751ec.png" alt="ASP.NET Core注册IMediatr"></p>
<p><em>在使用ASP.NET Core提供的原生Ioc容器有些问题：<a href="https://github.com/jbogard/MediatR.Extensions.Microsoft.DependencyInjection/issues/12" target="_blank" rel="noopener">Service registration crashes when registering generic handlers</a></em></p>
<h2 id="IPipelineBehavior"><a href="#IPipelineBehavior" class="headerlink" title="IPipelineBehavior"></a>IPipelineBehavior</h2><p><img src="/images/how-much-you-know-about-the-MediatR/2799767-42380e9ad9028a7e.png" alt="处理管道"></p>
<p>MeidatR支持按需配置请求管道进行消息处理。即支持在请求处理前和请求处理后添加额外行为。仅需实现以下两个接口，并注册到Ioc容器即可。</p>
<ul>
<li>IRequestPreProcessor<in TRequest> 请求处理前接口</li>
<li>IRequestPostProcessor&lt;in TRequest, in TResponse&gt; 请求处理后接口</li>
</ul>
<p>其中<code>IPipelineBehavior</code>的默认实现：<code>RequestPreProcessorBehavior</code>和<code>RequestPostProcessorBehavior</code>分别用来处理所有实现<code>IRequestPreProcessor</code>和<code>IRequestPostProcessor</code>接口定义的管道行为。</p>
<p>而处理管道是如何构建的呢？我们来看下<code>RequestHandlerWrapperImpl</code>的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">internal class RequestHandlerWrapperImpl&lt;TRequest, TResponse&gt; : RequestHandlerWrapper&lt;TResponse&gt;</span><br><span class="line">    where TRequest : IRequest&lt;TResponse&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public override Task&lt;TResponse&gt; Handle(IRequest&lt;TResponse&gt; request, CancellationToken cancellationToken,</span><br><span class="line">        ServiceFactory serviceFactory)</span><br><span class="line">    &#123;</span><br><span class="line">        Task&lt;TResponse&gt; Handler() &#x3D;&gt; GetHandler&lt;IRequestHandler&lt;TRequest, TResponse&gt;&gt;(serviceFactory).Handle((TRequest) request, cancellationToken);</span><br><span class="line"></span><br><span class="line">        return serviceFactory</span><br><span class="line">            .GetInstances&lt;IPipelineBehavior&lt;TRequest, TResponse&gt;&gt;()</span><br><span class="line">            .Reverse()</span><br><span class="line">            .Aggregate((RequestHandlerDelegate&lt;TResponse&gt;) Handler, (next, pipeline) &#x3D;&gt; () &#x3D;&gt; pipeline.Handle((TRequest)request, cancellationToken, next))();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就这样一个简单的函数，涉及的知识点还真不少，说实话我花了不少时间来理清这个逻辑。<br>那都涉及到哪些知识点呢？我们一个一个的来理一理。</p>
<ol>
<li>C# 7.0的新特性 - 局部函数</li>
<li>C# 6.0的新特性 - 表达式形式的成员函数</li>
<li>Linq高阶函数 - <code>Aggregate</code></li>
<li>匿名委托</li>
<li>构造委托函数链</li>
</ol>
<p>关于第1、2个知识点，请看下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public delegate int SumDelegate();&#x2F;&#x2F;定义委托</span><br><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;局部函数(在函数内部定义函数)</span><br><span class="line">    &#x2F;&#x2F;表达式形式的成员函数， 相当于 int Sum() &#123; return 1 + 2;&#125;</span><br><span class="line">    int Sum() &#x3D;&gt; 1 + 2;</span><br><span class="line"></span><br><span class="line">    var sumDelegate &#x3D; (SumDelegate)Sum;&#x2F;&#x2F;转换为委托</span><br><span class="line">    Console.WriteLine(sumDelegate());&#x2F;&#x2F;委托调用，输出：3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看第4个知识点，匿名委托：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public delegate int SumDelegate();</span><br><span class="line"></span><br><span class="line">SumDelegate delegater1 &#x3D; delegate()&#123; return 1+2; &#125;</span><br><span class="line">&#x2F;&#x2F;也相当于</span><br><span class="line">SumDelegate delegater2 &#x3D;&gt; 1+2;</span><br></pre></td></tr></table></figure>

<p>下面再来介绍一下<code>Aggregate</code>这个Linq高阶函数。<code>Aggregate</code>是对一个集合序列进行累加操作，通过指定初始值，累加函数，以及结果处理函数完成计算。</p>
<p>函数定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static TResult Aggregate&lt;TSource,TAccumulate,TResult&gt;</span><br><span class="line">(this IEnumerable&lt;TSource&gt; source, </span><br><span class="line">TAccumulate seed, </span><br><span class="line">Func&lt;TAccumulate,TSource,TAccumulate&gt; func, </span><br><span class="line">Func&lt;TAccumulate,TResult&gt; resultSelector);</span><br></pre></td></tr></table></figure>

<p>根据函数定义我们来写个简单的demo：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var nums &#x3D; Enumerable.Range(2, 3);&#x2F;&#x2F;[2,3,4]</span><br><span class="line">&#x2F;&#x2F; 计算1到5的累加之和，再将结果乘以2</span><br><span class="line">var sum &#x3D; nums.Aggregate(1, (total, next) &#x3D;&gt; total + next, result &#x3D;&gt; result * 2);&#x2F;&#x2F; 相当于 (((1+2)+3)+4)*2&#x3D;20</span><br><span class="line">Console.WriteLine(sum);&#x2F;&#x2F;20</span><br></pre></td></tr></table></figure>
<p>和函数参数进行一一对应：</p>
<ol>
<li>seed : 1</li>
<li>Func&lt;TAccumulate,TSource,TAccumulate&gt; func : (total, next) =&gt; total + next</li>
<li>Func&lt;TAccumulate,TResult&gt; resultSelector : result =&gt; result * 2</li>
</ol>
<p>基于上面的认识，我们再来回过头梳理一下<code>RequestHandlerWrapperImpl</code>。<br>其主要是借助委托：<code>public delegate Task&lt;TResponse&gt; RequestHandlerDelegate&lt;TResponse&gt;();</code>来构造委托函数链来构建处理管道。</p>
<p>对<code>Aggregate</code>函数了解后，我们就不难理解处理管道的构建了。请看下图中的代码解读：</p>
<p><img src="/images/how-much-you-know-about-the-MediatR/2799767-4f2985f53e955b6b.png" alt="请求处理管道代码解读"></p>
<p><img src="/images/how-much-you-know-about-the-MediatR/2799767-ea1971598e09240a.png" alt="构建流程解析"></p>
<p>那如何保证先执行<code>IRequestPreProcessor</code>再执行<code>IRequestPostProcessor</code>呢？<br>就是在注册到Ioc容器时必须保证顺序，先注册<code>IRequestPreProcessor</code>再注册<code>IRequestPostProcessor</code>。（这一点很重要！！！）</p>
<p><em>看到这里有没有想到ASP.NET Core中请求管道中中间件的构建呢？是不是很像俄罗斯套娃？先由内而外构建管道，再由外而内执行！</em></p>
<p>至此，MediatR的实现思路算是理清了。</p>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>如文章开头提到：MediatR是一种进程内消息传递机制。 支持以同步或异步的形式进行请求/响应，命令，查询，通知和事件的消息传递，并通过C#泛型支持消息的智能调度。</p>
<p>那么我们就应该明白，其核心是<strong>消息的解耦</strong>。因为我们几乎都是在与消息打交道，那因此它的应用场景就很广泛，比如我们可以基于MediatR实现CQRS、EventBus等。</p>
<p>另外，还有一种应用场景：我们知道借助依赖注入的好处是，就是解除依赖，但我们又不得不思考一个问题，随着业务逻辑复杂度的增加，构造函数可能要注入更多的服务，当注入的依赖太多时，其会导致构造函数膨胀。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public DashboardController(</span><br><span class="line">    ICustomerRepository customerRepository,</span><br><span class="line">    IOrderService orderService,</span><br><span class="line">    ICustomerHistoryRepository historyRepository,</span><br><span class="line">    IOrderRepository orderRepository,</span><br><span class="line">    IProductRespoitory productRespoitory,</span><br><span class="line">    IRelatedProductsRepository relatedProductsRepository,</span><br><span class="line">    ISupportService supportService,</span><br><span class="line">    ILog logger</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>如果借助<code>MediatR</code>进行改造，也许仅需注入<code>IMediatR</code>就可以了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public DashboardController(IMediatR mediatr)</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>看到这里，也许你应该明白MediatR实质上并不是严格意义上的中介者模式实现，我更倾向于其是基于Ioc容器的一层抽象，根据请求定位相应的请求处理器进行消息处理，也就是服务定位。<br>那到这里似乎也恍然大悟MediatR这个笔误可能是有意为之了。序员，你怎么看？</p>
<blockquote>
<p>参考资料：<br><a href="https://lostechies.com/jimmybogard/2016/10/27/cqrsmediatr-implementation-patterns/" target="_blank" rel="noopener">CQRS/MediatR implementation patterns</a><br><a href="https://stackoverflow.com/questions/50663501/mediatr-when-and-why-i-should-use-it-vs-2017-webapi" target="_blank" rel="noopener">MediatR when and why I should use it? vs 2017 webapi</a><br><a href="https://www.jianshu.com/p/c28500ec9439?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">ABP CQRS 实现案例:基于 MediatR 实现</a></p>
</blockquote>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
        <tag>中介者模式</tag>
        <tag>发布订阅模式</tag>
      </tags>
  </entry>
  <entry>
    <title>事件总线知多少(1)</title>
    <url>/post/how-much-you-know-about-the-eventbus-1/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>事件总线这个概念对你来说可能很陌生，但提到观察者（发布-订阅）模式，你也许就很熟悉。事件总线是对发布-订阅模式的一种实现。它是一种集中式事件处理机制，允许不同的组件之间进行彼此通信而又不需要相互依赖，达到一种解耦的目的。</p>
<p>我们来看看事件总线的处理流程：</p>
<p><img src="/images/how-much-you-know-about-the-eventbus-1/2799767-6f44bdefa88a23a2.png" alt="图1：EventBus流程"></p>
<p>了解了事件总线的基本概念和处理流程，下面我们就来分析下如何去实现事件总线。</p>
<h1 id="2-回归本质"><a href="#2-回归本质" class="headerlink" title="2.回归本质"></a>2.回归本质</h1><p>在动手实现事件总线之前，我们还是要追本溯源，探索一下事件的本质和发布订阅模式的实现机制。</p>
<h2 id="2-1-事件的本质"><a href="#2-1-事件的本质" class="headerlink" title="2.1.事件的本质"></a>2.1.事件的本质</h2><p>我们先来探讨一下事件的概念。都是读过书的，应该都还记得记叙文的六要素：时间、地点、人物、事件（起因、经过、结果）。</p>
<blockquote>
<p>我们拿注册的案例，来解释一下。<br>用户输入用户名、邮箱、密码后，点击注册，输入无误校验通过后，注册成功并发送邮件给用户，要求用户进行邮箱验证激活。</p>
</blockquote>
<p>这里面就涉及了两个主要事件：</p>
<ol>
<li>注册事件：起因是用户点击了注册按钮，经过是输入校验，结果是是否注册成功。</li>
<li>发送邮件事件：起因是用户使用邮箱注册成功需要验证邮箱，经过是邮件发送，结果是邮件是否发送成功。</li>
</ol>
<p>其实这六要素也适用于我们程序中事件的处理过程。开发过WinForm程序的都知道，我们在做UI设计的时候，从工具箱拖入一个注册按钮（btnRegister），双击它，VS就会自动帮我们生成如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void btnRegister_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line"> &#x2F;&#x2F; 事件的处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>object sender</code>指代发出事件的对象，这里也就是button对象；<code>EventArgs e</code> 事件参数，可以理解为对事件的描述 ，它们可以统称为<strong>事件源</strong>。其中的代码逻辑，就是对事件的处理。我们可以统称为<strong>事件处理</strong>。</p>
<p>说了这么多，无非是想透过现象看本质：<strong>事件是由事件源触发并由事件处理消费（An event is raised by an event source and consumed by an event handler</strong>）。</p>
<h2 id="2-2-发布订阅模式"><a href="#2-2-发布订阅模式" class="headerlink" title="2.2. 发布订阅模式"></a>2.2. 发布订阅模式</h2><blockquote>
<p>定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。 ——发布订阅模式</p>
</blockquote>
<p>发布订阅模式主要有两个角色：</p>
<ul>
<li>发布方（Publisher）：也称为被观察者，当状态改变时负责通知所有订阅者。</li>
<li>订阅方（Subscriber）：也称为观察者，订阅事件并对接收到的事件进行处理。</li>
</ul>
<p>发布订阅模式有两种实现方式：</p>
<ul>
<li>简单的实现方式：由Publisher维护一个订阅者列表，当状态改变时循环遍历列表通知订阅者。</li>
<li>委托的实现方式：由Publisher定义事件委托，Subscriber实现委托。</li>
</ul>
<p>总的来说，发布订阅模式中有两个关键字，通知和更新。<br>被观察者状态改变通知观察者做出相应更新。<br>解决的是当对象改变时需要通知其他对象做出相应改变的问题。</p>
<p>如果画一个图来表示这个流程的画，图形应该是这样的：</p>
<p><img src="/images/how-much-you-know-about-the-eventbus-1/2799767-8a17f6e834278167.png" alt="图2：发布订阅模式流程"></p>
<h1 id="3-实现发布订阅模式"><a href="#3-实现发布订阅模式" class="headerlink" title="3. 实现发布订阅模式"></a>3. 实现发布订阅模式</h1><p>相信通过上面的解释，对事件和发布订阅模式有了一个大概的印象。都说理论要与实践相结合，所以我们还是动动手指敲敲代码比较好。<br>我将以<a href="http://www.jianshu.com/p/45675c73296d" target="_blank" rel="noopener">『观察者模式』来钓鱼</a>这个例子为基础，通过重构的方式来完善一个更加通用的发布订阅模式。<br>先上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 鱼的品类枚举</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public enum FishType</span><br><span class="line">&#123;</span><br><span class="line">    鲫鱼,</span><br><span class="line">    鲤鱼,</span><br><span class="line">    黑鱼,</span><br><span class="line">    青鱼,</span><br><span class="line">    草鱼,</span><br><span class="line">    鲈鱼</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>钓鱼竿的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F;     鱼竿（被观察者）</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public class FishingRod</span><br><span class="line">&#123;</span><br><span class="line">    public delegate void FishingHandler(FishType type); &#x2F;&#x2F;声明委托</span><br><span class="line">    public event FishingHandler FishingEvent; &#x2F;&#x2F;声明事件</span><br><span class="line"></span><br><span class="line">    public void ThrowHook(FishingMan man)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(&quot;开始下钩！&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;用随机数模拟鱼咬钩，若随机数为偶数，则为鱼咬钩</span><br><span class="line">        if (new Random().Next() % 2 &#x3D;&#x3D; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            var type &#x3D; (FishType) new Random().Next(0, 5);</span><br><span class="line">            Console.WriteLine(&quot;铃铛：叮叮叮，鱼儿咬钩了&quot;);</span><br><span class="line">            if (FishingEvent !&#x3D; null)</span><br><span class="line">                FishingEvent(type);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>垂钓者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F;     垂钓者（观察者）</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public class FishingMan</span><br><span class="line">&#123;</span><br><span class="line">    public FishingMan(string name)</span><br><span class="line">    &#123;</span><br><span class="line">        Name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public string Name &#123; get; set; &#125;</span><br><span class="line">    public int FishCount &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 垂钓者自然要有鱼竿啊</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    public FishingRod FishingRod &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public void Fishing()</span><br><span class="line">    &#123;</span><br><span class="line">        this.FishingRod.ThrowHook(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Update(FishType type)</span><br><span class="line">    &#123;</span><br><span class="line">        FishCount++;</span><br><span class="line">        Console.WriteLine(&quot;&#123;0&#125;：钓到一条[&#123;2&#125;]，已经钓到&#123;1&#125;条鱼了！&quot;, Name, FishCount, type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>场景类也很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1、初始化鱼竿</span><br><span class="line">var fishingRod &#x3D; new FishingRod();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;2、声明垂钓者</span><br><span class="line">var jeff &#x3D; new FishingMan(&quot;圣杰&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;3.分配鱼竿</span><br><span class="line">jeff.FishingRod &#x3D; fishingRod;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;4、注册观察者</span><br><span class="line">fishingRod.FishingEvent +&#x3D; jeff.Update;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;5、循环钓鱼</span><br><span class="line">while (jeff.FishCount &lt; 5)</span><br><span class="line">&#123;</span><br><span class="line">    jeff.Fishing();</span><br><span class="line">    Console.WriteLine(&quot;-------------------&quot;);</span><br><span class="line">    &#x2F;&#x2F;睡眠5s</span><br><span class="line">    Thread.Sleep(5000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，相信你一看就明白。但很显然这个代码实现仅适用于当前这个钓鱼场景，假如有其他场景也想使用这个模式，我们还需要重新定义委托，重新定义事件处理，岂不很累。本着”Don’t repeat yourself“的原则，我们要对其进行重构。</p>
<p>结合我们对事件本质的探讨，事件是由事件源和事件处理组成。针对我们上面的案例来说，<code>public delegate void FishingHandler(FishType type);</code>这句代码就已经说明了事件源和事件处理。事件源就是<code>FishType type</code>，事件处理自然是注册到<code>FishingHandler</code>上面的委托实例。<br>问题找到了，很显然是我们的事件源和事件处理不够抽象，所以不能通用，下面咱们就来动手改造。</p>
<h2 id="3-1-提取事件源"><a href="#3-1-提取事件源" class="headerlink" title="3.1. 提取事件源"></a>3.1. 提取事件源</h2><p>事件源应该至少包含事件发生的时间和触发事件的对象。<br>我们提取<code>IEventData</code>接口来封装事件源：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 定义事件源接口，所有的事件源都要实现该接口</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public interface IEventData</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 事件发生的时间</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    DateTime EventTime &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 触发事件的对象</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    object EventSource &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自然我们应该给一个默认的实现<code>EventData</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 事件源：描述事件信息，用于参数传递</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public class EventData : IEventData</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 事件发生的时间</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    public DateTime EventTime &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 触发事件的对象</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    public Object EventSource &#123; get; set; &#125;</span><br><span class="line"></span><br><span class="line">    public EventData()</span><br><span class="line">    &#123;</span><br><span class="line">        EventTime &#x3D; DateTime.Now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>针对Demo，扩展事件源如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FishingEventData : EventData</span><br><span class="line">&#123;</span><br><span class="line">    public FishType FishType &#123; get; set; &#125;</span><br><span class="line">    public FishingMan FisingMan &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成后，我们就可以去把在<code>FishingRod</code>声明的委托参数类型改为<code>FishingEventData</code>类型了，即<code>public delegate void FishingHandler(FishingEventData eventData); //声明委托</code>；<br>然后修改<code>FishingMan</code>的<code>Update</code>方法按委托定义的参数类型修改即可，代码我就不放了，大家自行脑补。</p>
<p>到这一步我们就统一了事件源的定义方式。</p>
<h2 id="3-2-提取事件处理器"><a href="#3-2-提取事件处理器" class="headerlink" title="3.2.提取事件处理器"></a>3.2.提取事件处理器</h2><p>事件源统一了，那事件处理也得加以限制。比如如果随意命名事件处理方法名，那在进行事件注册的时候还要去按照委托定义的参数类型去匹配，岂不麻烦。</p>
<p>我们提取一个<code>IEventHandler</code>接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 定义事件处理器公共接口，所有的事件处理都要实现该接口</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public interface IEventHandler</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件处理要与事件源进行绑定，所以我们再来定义一个泛型接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 泛型事件处理器接口</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TEventData&quot;&gt;&lt;&#x2F;typeparam&gt;</span><br><span class="line">public interface IEventHandler&lt;TEventData&gt; : IEventHandler where TEventData : IEventData</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 事件处理器实现该方法来处理事件</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventData&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">    void HandleEvent(TEventData eventData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你可能会纳闷，为什么先定义了一个空接口？这里就留给自己思考吧。</p>
<p>至此我们就完成了事件处理的抽象。我们再继续去改造我们的Demo。我们让<code>FishingMan</code>实现<code>IEventHandler</code>接口，然后修改场景类中将<code>fishingRod.FishingEvent += jeff.Update;</code>改为<code>fishingRod.FishingEvent += jeff.HandleEvent;</code>即可。代码改动很简单，同样在此略去。</p>
<p>至此你可能觉得我们完成了对Demo的改造。但事实上呢，我们还要弄清一个问题——如果这个<code>FishingMan</code>订阅的有其他的事件，我们该如何处理？<br>聪颖如你，你立马想到了可以<strong>通过事件源来进行区分处理</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FishingMan : IEventHandler&lt;IEventData&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他代码</span><br><span class="line">    public void HandleEvent(IEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        if (eventData is FishingEventData)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;do something</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if(eventData is XxxEventData)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;do something else</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，这个模式实现到这个地步基本已经可以通用了。</p>
<h1 id="4-实现事件总线"><a href="#4-实现事件总线" class="headerlink" title="4. 实现事件总线"></a>4. 实现事件总线</h1><p>通用的发布订阅模式不是我们的目的，我们的目的是一个集中式的事件处理机制，且各个模块之间相互不产生依赖。那我们如何做到呢？同样我们还是一步一步的进行分析改造。</p>
<h2 id="4-1-分析问题"><a href="#4-1-分析问题" class="headerlink" title="4.1.分析问题"></a>4.1.分析问题</h2><p>思考一下，每次为了实现这个模式，都要完成以下三步：</p>
<ol>
<li>事件发布方定义事件委托</li>
<li>事件订阅方定义事件处理逻辑</li>
<li>显示的订阅事件</li>
</ol>
<p>虽然只有三步，但这三步已经很繁琐了。而且事件发布方和事件订阅方还存在着依赖（体现在订阅者要显示的进行事件的注册和注销上）。而且当事件过多时，直接在订阅者中实现<code>IEventHandler</code>接口处理多个事件逻辑显然不太合适，违法单一职责原则。这里就暴露了三个问题：</p>
<ol>
<li>如何精简步骤？</li>
<li>如何解除发布方与订阅方的依赖？</li>
<li>如何避免在订阅者中同时处理多个事件逻辑？</li>
</ol>
<p>带着问题思考，我们就会更接近真相。</p>
<p>想要精简步骤，那我们需要寻找共性。共性就是事件的本质，也就是我们针对事件源和事件处理提取出来的两个接口。</p>
<p>想要解除依赖，那就要在发布方和订阅方之间添加一个中介。</p>
<p>想要避免订阅者同时处理过多事件逻辑，那我们就把事件逻辑的处理提取到订阅者外部。</p>
<p>思路有了，下面我们就来实施吧。</p>
<h2 id="4-2-解决问题"><a href="#4-2-解决问题" class="headerlink" title="4.2.解决问题"></a>4.2.解决问题</h2><p>本着先易后难的思想，我们下面就来解决以上问题。</p>
<h3 id="4-2-1-实现IEventHandler"><a href="#4-2-1-实现IEventHandler" class="headerlink" title="4.2.1. 实现IEventHandler"></a>4.2.1. 实现IEventHandler</h3><p>我们先解决上面的第三个问题：如何避免在订阅者中同时处理多个事件逻辑？</p>
<p>自然是针对不同的事件源<code>IEventData</code>实现不同的<code>IEventHandler</code>。改造后的钓鱼事件处理逻辑如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 钓鱼事件处理</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public class FishingEventHandler : IEventHandler&lt;FishingEventData&gt;</span><br><span class="line">&#123;</span><br><span class="line">    public void HandleEvent(FishingEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        eventData.FishingMan.FishCount++;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(&quot;&#123;0&#125;：钓到一条[&#123;2&#125;]，已经钓到&#123;1&#125;条鱼了！&quot;,</span><br><span class="line">            eventData.FishingMan.Name, eventData.FishingMan.FishCount, eventData.FishType);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时我们就可以移除在<code>FishingMan</code>中实现的<code>IEventHandler</code>接口了。<br>然后将事件注册改为<code>fishingRod.FishingEvent += new FishingEventHandler().HandleEvent;</code>即可。</p>
<h3 id="4-2-2-统一注册事件"><a href="#4-2-2-统一注册事件" class="headerlink" title="4.2.2. 统一注册事件"></a>4.2.2. 统一注册事件</h3><p>上一个问题的解决，有助于我们解决第一个问题：如何精简流程？<br>为什么呢，因为我们是根据事件源定义相应的事件处理的。也就是我们之前说的可以根据事件源来区分事件。<br>然后呢？反射，我们可以通过反射来进行事件的统一注册。<br>在<code>FishingRod</code>的构造函数中使用反射，统一注册实现了<code>IEventHandler&lt;FishingEventData&gt;</code>类型的实例方法<code>HandleEvent</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public FishingRod()</span><br><span class="line">&#123;</span><br><span class="line">    Assembly assembly &#x3D; Assembly.GetExecutingAssembly();</span><br><span class="line"></span><br><span class="line">    foreach (var type in assembly.GetTypes())</span><br><span class="line">    &#123;</span><br><span class="line">        if (typeof(IEventHandler).IsAssignableFrom(type))&#x2F;&#x2F;判断当前类型是否实现了IEventHandler接口</span><br><span class="line">        &#123;</span><br><span class="line">            Type handlerInterface &#x3D; type.GetInterface(&quot;IEventHandler&#96;1&quot;);&#x2F;&#x2F;获取该类实现的泛型接口</span><br><span class="line">            Type eventDataType &#x3D; handlerInterface.GetGenericArguments()[0]; &#x2F;&#x2F; 获取泛型接口指定的参数类型</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;如果参数类型是FishingEventData，则说明事件源匹配</span><br><span class="line">            if (eventDataType.Equals(typeof(FishingEventData)))</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;创建实例</span><br><span class="line">                var handler &#x3D; Activator.CreateInstance(type) as IEventHandler&lt;FishingEventData&gt;;</span><br><span class="line">                &#x2F;&#x2F;注册事件</span><br><span class="line">                FishingEvent +&#x3D; handler.HandleEvent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就可以移出场景类中的显示注册代码<code>fishingRod.FishingEvent += new FishingEventHandler().HandleEvent;</code>。</p>
<h3 id="4-2-3-解除依赖"><a href="#4-2-3-解除依赖" class="headerlink" title="4.2.3. 解除依赖"></a>4.2.3. 解除依赖</h3><p>如何解除依赖呢？其实答案就在本文的两张图上，仔细对比我们可以很直观的看到，Event Bus就相当于一个介于Publisher和Subscriber中间的桥梁。它隔离了Publlisher和Subscriber之间的直接依赖，接管了所有事件的发布和订阅逻辑，并负责事件的中转。</p>
<p><strong>Event Bus终于要粉墨登场了！！！</strong><br>分析一下，如果EventBus要接管所有事件的发布和订阅，那它则需要有一个容器来记录事件源和事件处理。那又如何触发呢？有了事件源，我们就自然能找到绑定的事件处理逻辑，通过反射触发。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 事件总线</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public class EventBus</span><br><span class="line">&#123;</span><br><span class="line">    public static EventBus Default &#x3D;&gt; new EventBus();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 定义线程安全集合</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    private readonly ConcurrentDictionary&lt;Type, List&lt;Type&gt;&gt; _eventAndHandlerMapping;</span><br><span class="line"></span><br><span class="line">    public EventBus()</span><br><span class="line">    &#123;</span><br><span class="line">        _eventAndHandlerMapping &#x3D; new ConcurrentDictionary&lt;Type, List&lt;Type&gt;&gt;();</span><br><span class="line">        MapEventToHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F;通过反射，将事件源与事件处理绑定</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    private void MapEventToHandler()</span><br><span class="line">    &#123;</span><br><span class="line">        Assembly assembly &#x3D; Assembly.GetEntryAssembly();</span><br><span class="line">        foreach (var type in assembly.GetTypes())</span><br><span class="line">        &#123;</span><br><span class="line">            if (typeof(IEventHandler).IsAssignableFrom(type))&#x2F;&#x2F;判断当前类型是否实现了IEventHandler接口</span><br><span class="line">            &#123;</span><br><span class="line">                Type handlerInterface &#x3D; type.GetInterface(&quot;IEventHandler&#96;1&quot;);&#x2F;&#x2F;获取该类实现的泛型接口</span><br><span class="line">                if (handlerInterface !&#x3D; null)</span><br><span class="line">                &#123;</span><br><span class="line">                    Type eventDataType &#x3D; handlerInterface.GetGenericArguments()[0]; &#x2F;&#x2F; 获取泛型接口指定的参数类型</span><br><span class="line"></span><br><span class="line">                    if (_eventAndHandlerMapping.ContainsKey(eventDataType))</span><br><span class="line">                    &#123;</span><br><span class="line">                        List&lt;Type&gt; handlerTypes &#x3D; _eventAndHandlerMapping[eventDataType];</span><br><span class="line">                        handlerTypes.Add(type);</span><br><span class="line">                        _eventAndHandlerMapping[eventDataType] &#x3D; handlerTypes;</span><br><span class="line">                    &#125;</span><br><span class="line">                    else</span><br><span class="line">                    &#123;</span><br><span class="line">                        var handlerTypes &#x3D; new List&lt;Type&gt; &#123; type &#125;;</span><br><span class="line">                        _eventAndHandlerMapping[eventDataType] &#x3D; handlerTypes;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 手动绑定事件源与事件处理</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TEventData&quot;&gt;&lt;&#x2F;typeparam&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventHandler&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">    public void Register&lt;TEventData&gt;(Type eventHandler)</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Type&gt; handlerTypes &#x3D; _eventAndHandlerMapping[typeof(TEventData)];</span><br><span class="line">        if (!handlerTypes.Contains(eventHandler))</span><br><span class="line">        &#123;</span><br><span class="line">            handlerTypes.Add(eventHandler);</span><br><span class="line">            _eventAndHandlerMapping[typeof(TEventData)] &#x3D; handlerTypes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 手动解除事件源与事件处理的绑定</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TEventData&quot;&gt;&lt;&#x2F;typeparam&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventHandler&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">    public void UnRegister&lt;TEventData&gt;(Type eventHandler)</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Type&gt; handlerTypes &#x3D; _eventAndHandlerMapping[typeof(TEventData)];</span><br><span class="line">        if (handlerTypes.Contains(eventHandler))</span><br><span class="line">        &#123;</span><br><span class="line">            handlerTypes.Remove(eventHandler);</span><br><span class="line">            _eventAndHandlerMapping[typeof(TEventData)] &#x3D; handlerTypes;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 根据事件源触发绑定的事件处理</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TEventData&quot;&gt;&lt;&#x2F;typeparam&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventData&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">    public void Trigger&lt;TEventData&gt;(TEventData eventData) where TEventData : IEventData</span><br><span class="line">    &#123;</span><br><span class="line">        List&lt;Type&gt; handlers &#x3D; _eventAndHandlerMapping[eventData.GetType()];</span><br><span class="line"></span><br><span class="line">        if (handlers !&#x3D; null &amp;&amp; handlers.Count &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            foreach (var handler in handlers)</span><br><span class="line">            &#123;</span><br><span class="line">                MethodInfo methodInfo &#x3D; handler.GetMethod(&quot;HandleEvent&quot;);</span><br><span class="line">                if (methodInfo !&#x3D; null)</span><br><span class="line">                &#123;</span><br><span class="line">                    object obj &#x3D; Activator.CreateInstance(handler);</span><br><span class="line">                    methodInfo.Invoke(obj, new object[] &#123; eventData &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事件总线主要定义三个方法，注册、取消注册、事件触发。还有一点就是我们在构造函数中通过反射去进行事件源和事件处理的绑定。<br>代码注释已经很清楚了，这里就不过多解释了。</p>
<p>下面我们就来修改Demo，修改<code>FishingRod</code>的事件触发：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 下钩</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public void ThrowHook(FishingMan man)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;开始下钩！&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;用随机数模拟鱼咬钩，若随机数为偶数，则为鱼咬钩</span><br><span class="line">    if (new Random().Next() % 2 &#x3D;&#x3D; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        var a &#x3D; new Random(10).Next();</span><br><span class="line">        var type &#x3D; (FishType)new Random().Next(0, 5);</span><br><span class="line">        Console.WriteLine(&quot;铃铛：叮叮叮，鱼儿咬钩了&quot;);</span><br><span class="line">        if (FishingEvent !&#x3D; null)</span><br><span class="line">        &#123;</span><br><span class="line">            var eventData &#x3D; new FishingEventData() &#123; FishType &#x3D; type, FishingMan &#x3D; man &#125;;</span><br><span class="line">            &#x2F;&#x2F;FishingEvent(eventData);&#x2F;&#x2F;不再需要通过事件委托触发</span><br><span class="line">            EventBus.Default.Trigger&lt;FishingEventData&gt;(eventData);&#x2F;&#x2F;直接通过事件总线触发即可</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，事件总线的雏形已经形成！</p>
<h1 id="5-事件总线的总结"><a href="#5-事件总线的总结" class="headerlink" title="5.事件总线的总结"></a>5.事件总线的总结</h1><p>通过上面一步一步的分析和实践，发现事件总线也不是什么高深的概念，只要我们自己善于思考，勤于动手，也能实现自己的事件总线。<br>根据我们的实现，大概总结出以下几条：</p>
<ol>
<li>事件总线维护一个事件源与事件处理的映射字典；</li>
<li>通过单例模式，确保事件总线的唯一入口；</li>
<li>利用反射完成事件源与事件处理的初始化绑定；</li>
<li>提供统一的事件注册、取消注册和触发接口。</li>
</ol>
<p>最后，以上事件总线的实现只是一个雏形，还有很多潜在的问题。有兴趣的不妨思考完善一下，我也会继续更新，尽情期待。<a href="https://github.com/yanshengjie/EventBus" target="_blank" rel="noopener">源码路径：Github-EventBus</a></p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote>
<p><a href="https://github.com/aspnetboilerplate/aspnetboilerplate/tree/dev/src/Abp/Events/Bus" target="_blank" rel="noopener">ABP EventBus</a><br><a href="http://www.cnblogs.com/lori/p/3476703.html" target="_blank" rel="noopener">DDD~领域事件与事件总线</a><br><a href="http://www.cnblogs.com/dehai/p/4887998.html" target="_blank" rel="noopener">DDD事件总线的实现</a></p>
</blockquote>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
        <tag>发布订阅模式</tag>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title>事件总线知多少(2)</title>
    <url>/post/how-much-you-know-about-the-eventbus-2/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><p>之前的一篇文章<a href="/how-much-you-know-about-the-eventbus-1/">事件总线知多少(1)</a>，介绍了什么是事件总线，并通过发布订阅模式一步一步的分析重构，形成了事件总线的Alpha版本，这篇文章也得到了大家的肯定和积极的反馈和建议，在此谢谢大家。本着继续学习和回馈大家的思想，我决定继续完善。本文将继续延续上一篇循序渐进的写作风格，来完成对事件总线的分析和优化。<br><img src="/images/how-much-you-know-about-the-eventbus-2/2799767-6f44bdefa88a23a2.png" alt=""></p>
<h1 id="2-回顾事件总线"><a href="#2-回顾事件总线" class="headerlink" title="2.回顾事件总线"></a>2.回顾事件总线</h1><p>在进行具体分析之前，我们还是先对我们实现的事件总线进行一个简单的回顾：</p>
<ol>
<li>针对事件源，抽象<code>IEventData</code>接口；</li>
<li>针对事件处理，抽象<code>IEventHandler&lt;TEventData&gt;</code>接口，定义唯一事件处理方法<code>void HandleEvent(IEventData eventData)</code>；</li>
<li>事件总线维护一个事件源和事件处理的类型映射字典<code>ConcurrentDictionary&lt;Type, List&lt;Type&gt;&gt; _eventAndHandlerMapping</code>；</li>
<li>通过单例模式，确保事件总线的唯一入口；</li>
<li>利用反射完成事件源与事件处理的动态初始化绑定；</li>
<li>提供入口支持事件的手动注册/取消注册；</li>
<li>提供统一的事件触发接口，通过反射动态创建<code>IEventHandler</code>实例完成具体事件处理逻辑的调用。</li>
</ol>
<h1 id="3-发现反射问题"><a href="#3-发现反射问题" class="headerlink" title="3.发现反射问题"></a>3.发现反射问题</h1><p>基于以上的简单回顾，我们可以发现Alpha版本事件总线的成功离不开反射的支持。从动态绑定到动态触发，都是反射在默默的处理着业务逻辑。如果我们只是简单学习了解事件总线，使用反射无可厚非。但如果在实际的项目中，使用反射却不是一个很明智的行为，因为其性能问题。尤其是事件总线要集中处理整个应用程序的所有事件，更易导致程序性能瓶颈。<br>既然说到了反射性能，那就顺便解释下为什么反射性能差？</p>
<ol>
<li>类型绑定（元数据字符串匹配）</li>
<li>参数校验</li>
<li>安全校验</li>
<li>基于运行时</li>
<li>反射产生大量临时对象，增加GC负担</li>
</ol>
<p>那既然反射有性能瓶颈，我们该如何是好呢？<br>你可能会说，既然反射有问题，那就对反射进行性能优化，比如增加缓存机制。出发点是好的，但最终还是在反射问题的阴影之下。对于反射我们应该持以这样一种态度：能不用反射，则不用反射。</p>
<p>那既然要推翻反射这条路，那如何解决动态绑定和动态触发的问题呢？<br>办法总比问题多。额，啊，嗯。就不饶圈子了，咱们上IOC。</p>
<h1 id="4-使用IOC解除依赖"><a href="#4-使用IOC解除依赖" class="headerlink" title="4.使用IOC解除依赖"></a>4.使用IOC解除依赖</h1><p>先看下面一张图，来了解下DIP、IOC、DI与SL之间的关系，详细可参考<a href="http://www.jianshu.com/p/96947ec3e508" target="_blank" rel="noopener">Asp.net mvc 知多少（十）</a>。<br><img src="/images/how-much-you-know-about-the-eventbus-2/2799767-5b46dd0a9842ddd5.png" alt="DIP&amp;IOC&amp;DI&amp;SL"></p>
<p>下面我们就以<a href="https://github.com/castleproject/Windsor" target="_blank" rel="noopener">Castle Windsor</a>作为我们的IOC容器为例，来讲解下如何解除依赖。</p>
<h2 id="4-1-了解Castle-Windsor"><a href="#4-1-了解Castle-Windsor" class="headerlink" title="4.1. 了解Castle Windsor"></a>4.1. 了解Castle Windsor</h2><p>使用Castle Windsor主要包含以下几步：</p>
<ol>
<li>初始化容器：<code>var container = new WindsorContainer();</code></li>
<li>使用WindsorInstallers从执行程序集添加和配置所有组件：<code>container.Install(FromAssembly.This());</code></li>
<li>实现<code>IWindsorInstaller</code>自定义安装器：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RepositoriesInstaller : IWindsorInstaller</span><br><span class="line">&#123;</span><br><span class="line">	public void Install(IWindsorContainer container, IConfigurationStore store)</span><br><span class="line">	&#123;</span><br><span class="line">		container.Register(Classes.FromThisAssembly()</span><br><span class="line">			                .Where(Component.IsInSameNamespaceAs&lt;King&gt;())</span><br><span class="line">			                .WithService.DefaultInterfaces()</span><br><span class="line">			                .LifestyleTransient());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注册和解析依赖</li>
<li>程序退出时，释放容器</li>
</ol>
<h2 id="4-2-使用Castle-Windsor"><a href="#4-2-使用Castle-Windsor" class="headerlink" title="4.2. 使用Castle Windsor"></a>4.2. 使用Castle Windsor</h2><p>使用IOC容器的目的很明确，一个是在注册事件时完成依赖的注入，一个是在触发事件时完成依赖的解析。从而完成事件的动态绑定和触发。</p>
<h3 id="4-2-1-初始化容器"><a href="#4-2-1-初始化容器" class="headerlink" title="4.2.1. 初始化容器"></a>4.2.1. 初始化容器</h3><p>要在<code>EventBus</code>这个类中完成事件依赖的注入和解析，就需要在本类中持有一个对<code>IWindsorContainer</code>的引用。<br>可以直接定义一个只读属性，并在构造函数中进行初始化即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public IWindsorContainer IocContainer &#123; get; private set; &#125;&#x2F;&#x2F;定义IOC容器</span><br><span class="line">private readonly ConcurrentDictionary&lt;Type, List&lt;Type&gt;&gt; _eventAndHandlerMapping;</span><br><span class="line">public EventBus()</span><br><span class="line">&#123;</span><br><span class="line">      IocContainer &#x3D; new WindsorContainer();</span><br><span class="line">      _eventAndHandlerMapping &#x3D; new ConcurrentDictionary&lt;Type, List&lt;Type&gt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-注册和取消注册依赖"><a href="#4-2-2-注册和取消注册依赖" class="headerlink" title="4.2.2.注册和取消注册依赖"></a>4.2.2.注册和取消注册依赖</h3><p>初始化完容器，我们需要在手动注册和取消注册事件API上分别完成依赖的注册和取消注册。因为Castle Windsor在3.0版本取消了UnRegister方法，所以在进行事件注册时，就不再手动卸载IOC容器中已注册的依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 手动绑定事件源与事件处理</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventType&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;handlerType&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line"> public void Register(Type eventType, Type handlerType)</span><br><span class="line"> &#123;</span><br><span class="line">     &#x2F;&#x2F;注册IEventHandler&lt;T&gt;到IOC容器</span><br><span class="line">     var handlerInterface &#x3D; handlerType.GetInterface(&quot;IEventHandler&#96;1&quot;);</span><br><span class="line">     if (!IocContainer.Kernel.HasComponent(handlerInterface))</span><br><span class="line">     &#123;</span><br><span class="line">         IocContainer.Register(Component.For(handlerInterface, handlerType));</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     &#x2F;&#x2F;注册到事件总线</span><br><span class="line">     &#x2F;&#x2F;省略其他代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 手动解除事件源与事件处理的绑定</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TEventData&quot;&gt;&lt;&#x2F;typeparam&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;handlerType&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">public void UnRegister&lt;TEventData&gt;(Type handlerType)</span><br><span class="line">&#123;</span><br><span class="line">    _eventAndHandlerMapping.GetOrAdd(typeof(TEventData), (type) &#x3D;&gt; new List&lt;Type&gt;())</span><br><span class="line">        .RemoveAll(t &#x3D;&gt; t &#x3D;&#x3D; handlerType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-3-动态事件绑定"><a href="#4-2-3-动态事件绑定" class="headerlink" title="4.2.3. 动态事件绑定"></a>4.2.3. 动态事件绑定</h3><p>要实现事件的动态绑定，我们要拿到所有<code>IEventHandler&lt;T&gt;</code>的实现。而遍历所有类型最好的办法就是拿到程序集（Assembly）。拿到程序集后就可以将所有<code>IEventHandler&lt;T&gt;</code>的实现注册到IOC容器，然后再基于IOC容器注册的<code>IEventHandler&lt;T&gt;</code>动态映射事件源和事件处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 提供入口支持注册其它程序集中实现的IEventHandler</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;assembly&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">public void RegisterAllEventHandlerFromAssembly(Assembly assembly)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;1.将IEventHandler注册到Ioc容器</span><br><span class="line">    IocContainer.Register(Classes.FromAssembly(assembly)</span><br><span class="line">        .BasedOn(typeof(IEventHandler&lt;&gt;))</span><br><span class="line">        .WithService.AllInterfaces()</span><br><span class="line">        .LifestyleSingleton());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2.从IOC容器中获取注册的所有IEventHandler</span><br><span class="line">    var handlers &#x3D; IocContainer.Kernel.GetHandlers(typeof(IEventHandler));</span><br><span class="line">    foreach (var handler in handlers)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;循环遍历所有的IEventHandler&lt;T&gt;</span><br><span class="line">        var interfaces &#x3D; handler.ComponentModel.Implementation.GetInterfaces();</span><br><span class="line">        foreach (var @interface in interfaces)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!typeof(IEventHandler).IsAssignableFrom(@interface))</span><br><span class="line">            &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;获取泛型参数类型</span><br><span class="line">            var genericArgs &#x3D; @interface.GetGenericArguments();</span><br><span class="line">            if (genericArgs.Length &#x3D;&#x3D; 1)</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;注册到事件源与事件处理的映射字典中</span><br><span class="line">                Register(genericArgs[0], handler.ComponentModel.Implementation);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过这种方式，我们就可以再其他需要使用事件总线的项目中，添加引用后，通过调用以下代码，来完成程序集中<code>IEventHandler&lt;T&gt;</code>的动态绑定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注册当前程序集中实现的所有IEventHandler&lt;T&gt;</span><br><span class="line">EventBus.Default.RegisterAllEventHandlerFromAssembly(Assembly.GetExecutingAssembly());</span><br></pre></td></tr></table></figure>

<h3 id="4-2-4-动态事件触发"><a href="#4-2-4-动态事件触发" class="headerlink" title="4.2.4. 动态事件触发"></a>4.2.4. 动态事件触发</h3><p>触发事件时主要分三步，第一步从事件源与事件处理的字典中取出映射的<code>IEventHandler</code>集合，第二步使用IOC容器解析依赖，第三步调用<code>HandleEvent</code>方法。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 根据事件源触发绑定的事件处理</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TEventData&quot;&gt;&lt;&#x2F;typeparam&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventData&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">public void Trigger&lt;TEventData&gt;(TEventData eventData) where TEventData : IEventData</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取所有映射的EventHandler</span><br><span class="line">    List&lt;Type&gt; handlerTypes &#x3D; _eventAndHandlerMapping[typeof(TEventData)];</span><br><span class="line"></span><br><span class="line">    if (handlerTypes !&#x3D; null &amp;&amp; handlerTypes.Count &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        foreach (var handlerType in handlerTypes)</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;从Ioc容器中获取所有的实例</span><br><span class="line">            var handlerInterface &#x3D; handlerType.GetInterface(&quot;IEventHandler&#96;1&quot;);</span><br><span class="line">            var eventHandlers &#x3D; IocContainer.ResolveAll(handlerInterface);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F;循环遍历，仅当解析的实例类型与映射字典中事件处理类型一致时，才触发事件</span><br><span class="line">            foreach (var eventHandler in eventHandlers)</span><br><span class="line">            &#123;</span><br><span class="line">                if (eventHandler.GetType() &#x3D;&#x3D; handlerType)</span><br><span class="line">                &#123;</span><br><span class="line">                    var handler &#x3D; eventHandler as IEventHandler&lt;TEventData&gt;;</span><br><span class="line">                    handler.HandleEvent(eventData);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-用例完善"><a href="#5-用例完善" class="headerlink" title="5.用例完善"></a>5.用例完善</h1><p>我们上面使用IOC容器替换了反射，在程序的易用性和性能上都有所提升。但很显然，用例不够完善且存在一些潜在问题，比如：</p>
<ol>
<li>支持Action EventHandler的绑定和触发</li>
<li>异步触发</li>
<li>触发指定的EventHandler</li>
<li>线程安全</li>
<li>等等等</li>
</ol>
<p>下面我们就来先一一完善以上几个问题。</p>
<h2 id="5-1-支持Action事件处理器"><a href="#5-1-支持Action事件处理器" class="headerlink" title="5.1.支持Action事件处理器"></a>5.1.支持Action事件处理器</h2><p>如果每一个事件处理都要定义一个类去实现<code>IEventHandler&lt;T&gt;</code>接口，很显然会造成类急剧膨胀。且在一些简单场景，定义一个类又大才小用。这时我们应该立刻想到Action。<br>使用Action，第一步我们要对其进行封装，提供一个公共的<code>ActionEventHandler</code>来统一处理所有的Action事件处理器。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 支持Action的事件处理器</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TEventData&quot;&gt;&lt;&#x2F;typeparam&gt;</span><br><span class="line">internal class ActionEventHandler&lt;TEventData&gt; : IEventHandler&lt;TEventData&gt; where TEventData : IEventData</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 定义Action的引用，并通过构造函数传参初始化</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    public Action&lt;TEventData&gt; Action &#123; get; private set; &#125;</span><br><span class="line"></span><br><span class="line">    public ActionEventHandler(Action&lt;TEventData&gt; handler)</span><br><span class="line">    &#123;</span><br><span class="line">        Action &#x3D; handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; 调用具体的Action来处理事件逻辑</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventData&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">    public void HandleEvent(TEventData eventData)</span><br><span class="line">    &#123;</span><br><span class="line">        Action(eventData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了<code>ActionEventHandler</code>做封装，下一步就是注入IOC容器并注册到事件总线了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 注册Action事件处理器</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TEventData&quot;&gt;&lt;&#x2F;typeparam&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;action&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">public void Register&lt;TEventData&gt;(Action&lt;TEventData&gt; action) where TEventData : IEventData</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;1.构造ActionEventHandler</span><br><span class="line">    var actionHandler &#x3D; new ActionEventHandler&lt;TEventData&gt;(action);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;2.将ActionEventHandler的实例注入到Ioc容器</span><br><span class="line">    IocContainer.Register(</span><br><span class="line">        Component.For&lt;IEventHandler&lt;TEventData&gt;&gt;()</span><br><span class="line">        .UsingFactoryMethod(() &#x3D;&gt; actionHandler)</span><br><span class="line">        .LifestyleSingleton());</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;3.注册到事件总线</span><br><span class="line">    Register&lt;TEventData&gt;(actionHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用起来就很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注册Action事件处理器</span><br><span class="line">EventBus.Default.Register&lt;EventData&gt;(</span><br><span class="line">    actionEventData &#x3D;&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Trace.TraceInformation(actionEventData.EventTime.ToLongDateString());</span><br><span class="line">    &#125;);</span><br><span class="line">&#x2F;&#x2F;触发</span><br><span class="line">EventBus.Default.Trigger(new EventData());</span><br></pre></td></tr></table></figure>

<h2 id="5-2-支持异步触发"><a href="#5-2-支持异步触发" class="headerlink" title="5.2. 支持异步触发"></a>5.2. 支持异步触发</h2><p>异步触发很简单直接使用<code>Task.Run</code>包装一下就ok了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 异步触发</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TEventData&quot;&gt;&lt;&#x2F;typeparam&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventData&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;</span><br><span class="line">public Task TriggerAsync&lt;TEventData&gt;(TEventData eventData) where TEventData : IEventData</span><br><span class="line">&#123;</span><br><span class="line">    return Task.Run(() &#x3D;&gt; Trigger&lt;TEventData&gt;(eventData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-触发指定EventHandler"><a href="#5-3-触发指定EventHandler" class="headerlink" title="5.3.触发指定EventHandler"></a>5.3.触发指定EventHandler</h2><p>在我们的<code>Trigger</code>方法中我们会将某一个事件源绑定的事件处理全部触发。但在某些场景下，我们可能并不需要全部触发，仅需要触发指定的EventHandler。这个需求很实际，我们来实现一下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 触发指定EventHandler</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventHandlerType&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventData&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line"></span><br><span class="line">public void Trigger&lt;TEventData&gt;(Type eventHandlerType, TEventData eventData) </span><br><span class="line">    where TEventData : IEventData</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;获取类型实现的泛型接口</span><br><span class="line">    var handlerInterface &#x3D; eventHandlerType.GetInterface(&quot;IEventHandler&#96;1&quot;);</span><br><span class="line"></span><br><span class="line">    var eventHandlers &#x3D; IocContainer.ResolveAll(handlerInterface);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;循环遍历，仅当解析的实例类型与映射字典中事件处理类型一致时，才触发事件</span><br><span class="line">    foreach (var eventHandler in eventHandlers)</span><br><span class="line">    &#123;</span><br><span class="line">        if (eventHandler.GetType() &#x3D;&#x3D; eventHandlerType)</span><br><span class="line">        &#123;</span><br><span class="line">            var handler &#x3D; eventHandler as IEventHandler&lt;TEventData&gt;;</span><br><span class="line">            handler?.HandleEvent(eventData);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 异步触发指定EventHandler</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventHandlerType&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventData&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;</span><br><span class="line">public Task TriggerAsycn&lt;TEventData&gt;(Type eventHandlerType, TEventData eventData)</span><br><span class="line">    where TEventData : IEventData</span><br><span class="line">&#123;</span><br><span class="line">    return Task.Run(() &#x3D;&gt; Trigger(eventHandlerType, eventData));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上个测试用例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> [Fact]</span><br><span class="line">public async void Should_Call_Specified_Handler_Async()</span><br><span class="line">&#123;</span><br><span class="line">    TestEventBus.Register&lt;TestEventData&gt;(new TestEventHandler());</span><br><span class="line"></span><br><span class="line">    var count &#x3D; 0;</span><br><span class="line">    TestEventBus.Register&lt;TestEventData&gt;(</span><br><span class="line">        actionEventData &#x3D;&gt; &#123; count++; &#125;</span><br><span class="line">    );</span><br><span class="line">    await TestEventBus.TriggerAsycn&lt;TestEventData&gt;</span><br><span class="line">        (typeof(TestEventHandler), new TestEventData(999));</span><br><span class="line"></span><br><span class="line">    TestEventHandler.TestValue.ShouldBe(999);</span><br><span class="line">    count.ShouldBe(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-4-线程安全问题"><a href="#5-4-线程安全问题" class="headerlink" title="5.4.线程安全问题"></a>5.4.线程安全问题</h2><p>在事件总线中，维护的事件源和事件处理的映射字典是整个程序中的重中之重。我们选择了使用<code>ConcurrentDictionary</code>线程安全字典来规避线程安全问题。但实际我们真正做到线程安全了吗？我们看下映射字典申明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 定义线程安全集合</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">private readonly ConcurrentDictionary&lt;Type, List&lt;Type&gt;&gt; _eventAndHandlerMapping;</span><br></pre></td></tr></table></figure>
<p>聪慧如你，我们的事件源支持绑定多个事件处理，<code>ConcurrentDictionary</code>确保了对key值（事件源）修改的线程安全，但无法确保事件处理的列表<code>List&lt;Type&gt;</code>的线程安全。那我们就来动手改造吧。同样代码很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 定义锁对象</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">private static object lockObj&#x3D; new object();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; 获取事件总线映射字典中指定事件源的事件列表</span><br><span class="line">&#x2F;&#x2F;&#x2F; 若有，返回列表</span><br><span class="line">&#x2F;&#x2F;&#x2F; 若无，构造空列表返回</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;param name&#x3D;&quot;eventType&quot;&gt;&lt;&#x2F;param&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;returns&gt;&lt;&#x2F;returns&gt;</span><br><span class="line">private List&lt;Type&gt; GetOrCreateHandlers(Type eventType)</span><br><span class="line">&#123;</span><br><span class="line">    return _eventAndHandlerMapping.GetOrAdd(eventType, (type) &#x3D;&gt; new List&lt;Type&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void Register(Type eventType, Type handlerType)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他代码</span><br><span class="line">    &#x2F;&#x2F;注册到事件总线</span><br><span class="line">    lock (lockObj)</span><br><span class="line">    &#123;</span><br><span class="line">        GetOrCreateHandlers(eventType).Add(handlerType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public void UnRegister&lt;TEventData&gt;(Type handlerType)</span><br><span class="line">&#123;</span><br><span class="line">    lock (lockObj)</span><br><span class="line">    &#123;</span><br><span class="line">        GetOrCreateHandlers(typeof(TEventData)).RemoveAll(t &#x3D;&gt; t &#x3D;&#x3D; handlerType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-单元测试"><a href="#6-单元测试" class="headerlink" title="6.单元测试"></a>6.单元测试</h1><p>为了确保重构的正确性和业务的完整性，以上的改进都是基于单元测试进行改进的，使用的是Xunit+Shouldly。虽然不能保证单元测试的覆盖度，但至少确保了正常业务的流转。</p>
<p><img src="/images/how-much-you-know-about-the-eventbus-2/2799767-37bc5bdd93f0445c.png" alt="UnitTest"></p>
<h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h1><p>这一次，通过单元测试，一步一步的推进事件总线的重构和完善。主要完成了使用IOC替换反射来解耦和一些用例的完善。源码已上传至Github（<a href="https://github.com/yanshengjie/EventBus" target="_blank" rel="noopener">源码路径：Github-EventBus</a>）。<br><img src="/images/how-much-you-know-about-the-eventbus-2/2799767-4106f2960f6ff8aa.png" alt=""><br>至此，事件总线进入Beta版本。但很显然还有许多细节有待完善，比如异常处理等，后续就不再继续这个系列，我会直接维护Github的源码，感兴趣的可自行参阅。<a href="https://github.com/yanshengjie/EventBus" target="_blank" rel="noopener">源码路径：Github-EventBus</a></p>
<hr>
<blockquote>
<p>参考资料：<br><a href="https://github.com/aspnetboilerplate/aspnetboilerplate/tree/dev/src/Abp/Events/Bus" target="_blank" rel="noopener">ABP EventBus</a><br><a href="http://www.cnblogs.com/lwhkdash/archive/2012/09/28/2707549.html" target="_blank" rel="noopener">[c#] 反射真的很可怕吗？</a></p>
</blockquote>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
        <tag>发布订阅模式</tag>
        <tag>EventBus</tag>
      </tags>
  </entry>
  <entry>
    <title>IdentityServer4 知多少</title>
    <url>/post/how-much-you-know-about-the-identityserver4/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a><img src="/images/how-much-you-know-about-the-identityserver4/2799767-c17b64e06a2d4f71-1588585455631.png" alt=""></h1><h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>现在的应用开发层出不穷，基于浏览器的网页应用，基于微信的公众号、小程序，基于IOS、Android的App，基于Windows系统的桌面应用和UWP应用等等，这么多种类的应用，就给应用的开发带来的挑战，我们除了分别实现各个应用外，我们还要考虑各个应用之间的交互，通用模块的提炼，其中身份的认证和授权就是每个应用必不可少的的一部分。而现在的互联网，对于信息安全要求又十分苛刻，所以一套统一的身份认证和授权就至关重要。</p>
<p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-edb5904a988bb3a6.png" alt="IdentityServer 4"></p>
<blockquote>
<p>IdentityServer4就是这样一个框架，IdentityServer4是为ASP.NET CORE量身定制的实现了OpenId Connect和OAuth2.0协议的认证授权中间件。</p>
</blockquote>
<p>下面我们就来介绍一下相关概念，并梳理下如何集成IdentityServer4。<br>也可浏览自行整理的<strong><a href="http://naotu.baidu.com/file/75b251257ce27cfa62e0ad7f47b75576?token=e2db617be22b6274" target="_blank" rel="noopener">IdentityServer4 百度脑图</a></strong>快速了解。</p>
<h1 id="2-OAuth2-0-amp-amp-OpenId-Connect"><a href="#2-OAuth2-0-amp-amp-OpenId-Connect" class="headerlink" title="2.OAuth2.0 &amp;&amp; OpenId Connect"></a>2.OAuth2.0 &amp;&amp; OpenId Connect</h1><p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-4cd2e40d9b5d84b5.png" alt=""></p>
<h2 id="2-1-OpenId"><a href="#2-1-OpenId" class="headerlink" title="2.1. OpenId"></a>2.1. OpenId</h2><blockquote>
<p>OpenID 是一个<strong>以用户为中心的数字身份识别框架</strong>，它具有开放、分散性。OpenID 的创建基于这样一个概念：我们可以通过 URI （又叫 URL 或网站地址）来认证一个网站的唯一身份，同理，我们也可以通过这种方式来作为用户的身份认证。</p>
</blockquote>
<p>简而言之：<strong>OpenId用于身份认证（Authentication）</strong>。</p>
<h2 id="2-2-OAuth-2-0"><a href="#2-2-OAuth-2-0" class="headerlink" title="2.2. OAuth 2.0"></a>2.2. OAuth 2.0</h2><blockquote>
<p>OAuth（<strong>开放授权</strong>）是一个开放标准，目前的版本是2.0。允许用户授权第三方移动应用访问他们存储在其他服务商上存储的私密的资源（如照片，视频，联系人列表），而无需将用户名和密码提供给第三方应用。<br>OAuth允许用户提供一个<strong>令牌</strong>而不是用户名和密码来访问他们存放在特定服务商上的数据。每一个令牌授权一个特定的网站内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth可以允许用户授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。<br>OAuth是OpenID的一个补充，但是完全不同的服务。</p>
</blockquote>
<p>简而言之：<strong>OAuth2.0 用于授权（Authorization）</strong>。<br>关于OAuth2.0也可参考我的另一篇博文<a href="https://www.cnblogs.com/sheng-jie/p/6564520.html" target="_blank" rel="noopener">OAuth2.0 知多少</a>。</p>
<h2 id="2-3-OpenId-Connect"><a href="#2-3-OpenId-Connect" class="headerlink" title="2.3. OpenId Connect"></a>2.3. OpenId Connect</h2><blockquote>
<p>OpenID Connect 1.0 是基于OAuth 2.0协议之上的简单身份层，它允许客户端根据授权服务器的认证结果最终确认终端用户的身份，以及获取基本的用户信息；它支持包括Web、移动、JavaScript在内的所有客户端类型去请求和接收终端用户信息和身份认证会话信息；它是可扩展的协议，允许你使用某些可选功能，如身份数据加密、OpenID提供商发现、会话管理等。</p>
</blockquote>
<p>简而言之：<strong>OpenId Connect = OIDC = Authentication + Authorization + OAuth2.0</strong>。</p>
<p>比如，Facebook、Google、QQ、微博都是比较知名的OpenId  Connect提供商。</p>
<h1 id="3-术语解释"><a href="#3-术语解释" class="headerlink" title="3. 术语解释"></a>3. 术语解释</h1><p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-00eec4bc3482dd66.png" alt=""></p>
<p>了解完OpenId Connect和OAuth2.0的基本概念，我们再来梳理下涉及到的相关术语：</p>
<ol>
<li>User：用户</li>
<li>Client：客户端</li>
<li>Resources：Identity Data（身份数据）、Apis</li>
<li>Identity Server：认证授权服务器</li>
<li>Token：Access Token（访问令牌）和 Identity Token（身份令牌）</li>
</ol>
<p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-3f778baddaf58043.png" alt=""></p>
<h1 id="4-JwtBearer-认证"><a href="#4-JwtBearer-认证" class="headerlink" title="4. JwtBearer 认证"></a>4. JwtBearer 认证</h1><h2 id="4-1-HTTP身份验证流程"><a href="#4-1-HTTP身份验证流程" class="headerlink" title="4.1. HTTP身份验证流程"></a>4.1. HTTP身份验证流程</h2><blockquote>
<p>HTTP提供了一套标准的身份验证框架：服务器可以用来针对客户端的请求发送质询(challenge)，客户端根据质询提供身份验证凭证。质询与应答的工作流程如下：服务器端向客户端返回401（Unauthorized，未授权）状态码，并在WWW-Authenticate头中添加如何进行验证的信息，其中至少包含有一种质询方式。然后客户端可以在请求中添加Authorization头进行验证，其Value为身份验证的凭证信息。</p>
</blockquote>
<p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-6d9e1014fd3bca72.png" alt="HTTP身份验证流程"></p>
<p>Bearer认证（也叫做令牌认证）是一种HTTP认证方案，其中包含的安全令牌的叫做Bearer Token。因此Bearer认证的核心是Token。那如何确保Token的安全是重中之重。一种方式是使用Https，另一种方式就是对Token进行加密签名。而JWT就是一种比较流行的Token编码方式。</p>
<h2 id="4-2-JWT（Json-Web-Token"><a href="#4-2-JWT（Json-Web-Token" class="headerlink" title="4.2. JWT（Json Web Token)"></a>4.2. JWT（Json Web Token)</h2><blockquote>
<p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（<a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener">RFC 7519</a>）。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p>
</blockquote>
<p>JWT有三部分组成：</p>
<blockquote>
<header>.<payload>.<signature>
</blockquote>
<ol>
<li>Header：由<code>alg</code>和<code>typ</code>组成，<code>alg</code>是algorithm的缩写，<code>typ</code>是type的缩写，指定token的类型。该部分使用<code>Base64Url</code>编码。</li>
<li>Payload：主要用来存储信息，包含各种声明，同样该部分也由<code>BaseURL</code>编码。</li>
<li>Signature：签名，使用服务器端的密钥进行签名。以确保Token未被篡改。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>

<h1 id="5-授权模式"><a href="#5-授权模式" class="headerlink" title="5. 授权模式"></a>5. 授权模式</h1><p>OAuth2.0 定义了四种授权模式：</p>
<ol>
<li>Implicit：简化模式；直接通过浏览器的链接跳转申请令牌。</li>
<li>Client Credentials：客户端凭证模式；该方法通常用于服务器之间的通讯；该模式仅发生在Client与Identity Server之间。</li>
<li>Resource Owner Password Credentials：密码模式</li>
<li>Authorization Code：授权码模式； </li>
</ol>
<h2 id="5-1-Client-Credentials"><a href="#5-1-Client-Credentials" class="headerlink" title="5.1. Client Credentials"></a>5.1. Client Credentials</h2><p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-b8f1275cda8b204d.png" alt="客户端凭证模式"></p>
<p>客户端凭证模式，是最简单的授权模式，因为授权的流程仅发生在Client与Identity Server之间。</p>
<p>该模式的适用场景为服务器与服务器之间的通信。比如对于一个电子商务网站，将订单和物流系统分拆为两个服务分别部署。订单系统需要访问物流系统进行物流信息的跟踪，物流系统需要访问订单系统的快递单号信息进行物流信息的定时刷新。而这两个系统之间服务的授权就可以通过这种模式来实现。</p>
<h2 id="5-2-Resource-Owner-Password-Credentials"><a href="#5-2-Resource-Owner-Password-Credentials" class="headerlink" title="5.2. Resource Owner Password Credentials"></a>5.2. Resource Owner Password Credentials</h2><p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-934f091397d7234b.png" alt="密码模式"></p>
<p>Resource Owner其实就是User，所以可以直译为用户名密码模式。密码模式相较于客户端凭证模式，多了一个参与者，就是User。通过User的用户名和密码向Identity Server申请访问令牌。这种模式下要求客户端不得储存密码。但我们并不能确保客户端是否储存了密码，所以该模式仅适用于受信任的客户端。否则会发生密码泄露的危险。<strong>该模式不推荐使用</strong>。</p>
<h2 id="5-3-Authorization-Code"><a href="#5-3-Authorization-Code" class="headerlink" title="5.3. Authorization Code"></a>5.3. Authorization Code</h2><p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-15e218058b896231.png" alt="image.png"></p>
<p>授权码模式是一种混合模式，是目前功能最完整、流程最严密的授权模式。它主要分为两大步骤：认证和授权。<br>其流程为：</p>
<ol>
<li>用户访问客户端，客户端将用户导向Identity Server。</li>
<li>用户填写凭证信息向客户端授权，认证服务器根据客户端指定的重定向URI，并返回一个【Authorization Code】给客户端。</li>
<li>客户端根据【Authorization Code】向Identity Server申请【Access Token】</li>
</ol>
<h2 id="5-4-Implicit"><a href="#5-4-Implicit" class="headerlink" title="5.4. Implicit"></a>5.4. Implicit</h2><p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-890a555d2a3922d3.png" alt="简化模式"></p>
<p>简化模式是相对于授权码模式而言的。其不再需要【Client】的参与，所有的认证和授权都是通过浏览器来完成的。</p>
<h1 id="6-IdentityServer4-集成"><a href="#6-IdentityServer4-集成" class="headerlink" title="6. IdentityServer4 集成"></a>6. IdentityServer4 集成</h1><p><img src="/images/how-much-you-know-about-the-identityserver4/2799767-6708925e096c8510.png" alt="如何集成Identity Server"></p>
<p>通过以上知识点的梳理，我们对OpenId Connect 和OAuth2.0的一些相关概念有了大致认识。而IdentityServer4是为ASP.NET CORE量身定制的实现了OpenId Connect和OAuth2.0协议的认证授权中间件。<br>所以自然而然我们对IdentityServer4有了基础的认识。下面就来介绍如何集成IdentityServer4。其主要分为三步：</p>
<ol>
<li>IdentityServer如何配置和启用IdentityServer中间件</li>
<li>Resources如何配置和启用认证授权中间件</li>
<li>Client如何认证和授权</li>
</ol>
<h2 id="6-1-Identity-Server-中间件的配置和启用"><a href="#6-1-Identity-Server-中间件的配置和启用" class="headerlink" title="6.1. Identity Server 中间件的配置和启用"></a>6.1. Identity Server 中间件的配置和启用</h2><p>作为一个独立的Identity Server，它必须知道哪些资源需要保护，必须知道哪些客户端能够允许访问，这是配置的基础。<br>所以IdentityServer中间件的配置的核心就是：</p>
<ol>
<li>配置受保护的资源列表</li>
<li>配置允许验证的Client</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Startup</span><br><span class="line">&#123;</span><br><span class="line">    public void ConfigureServices(IServiceCollection services)</span><br><span class="line">    &#123;</span><br><span class="line">        services.AddMvc();</span><br><span class="line">        &#x2F;&#x2F; configure identity server with in-memory stores, keys, clients and scopes</span><br><span class="line">        services.AddIdentityServer()</span><br><span class="line">            .AddDeveloperSigningCredential()</span><br><span class="line">             &#x2F;&#x2F;配置身份资源</span><br><span class="line">            .AddInMemoryIdentityResources(Config.GetIdentityResources())</span><br><span class="line">              &#x2F;&#x2F;配置API资源</span><br><span class="line">            .AddInMemoryApiResources(Config.GetApiResources())</span><br><span class="line">             &#x2F;&#x2F;预置允许验证的Client</span><br><span class="line">            .AddInMemoryClients(Config.GetClients())</span><br><span class="line">            .AddTestUsers(Config.GetUsers());</span><br><span class="line">        services.AddAuthentication()</span><br><span class="line">              &#x2F;&#x2F;添加Google第三方身份认证服务（按需添加）</span><br><span class="line">            .AddGoogle(&quot;Google&quot;, options &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                options.SignInScheme &#x3D; IdentityServerConstants.ExternalCookieAuthenticationScheme;</span><br><span class="line">                options.ClientId &#x3D; &quot;434483408261-55tc8n0cs4ff1fe21ea8df2o443v2iuc.apps.googleusercontent.com&quot;;</span><br><span class="line">                options.ClientSecret &#x3D; &quot;3gcoTrEDPPJ0ukn_aYYT6PWo&quot;;</span><br><span class="line">            &#125;)</span><br><span class="line">            &#x2F;&#x2F;如果当前IdentityServer不提供身份认证服务，还可以添加其他身份认证服                务提供商</span><br><span class="line">            .AddOpenIdConnect(&quot;oidc&quot;, &quot;OpenID Connect&quot;, options &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                options.SignInScheme &#x3D; IdentityServerConstants.ExternalCookieAuthenticationScheme;</span><br><span class="line">                options.SignOutScheme &#x3D; IdentityServerConstants.SignoutScheme;</span><br><span class="line">                options.Authority &#x3D; &quot;https:&#x2F;&#x2F;demo.identityserver.io&#x2F;&quot;;</span><br><span class="line">                options.ClientId &#x3D; &quot;implicit&quot;;</span><br><span class="line">                options.TokenValidationParameters &#x3D; new TokenValidationParameters</span><br><span class="line">                &#123;</span><br><span class="line">                    NameClaimType &#x3D; &quot;name&quot;,</span><br><span class="line">                    RoleClaimType &#x3D; &quot;role&quot;</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void Configure(IApplicationBuilder app, IHostingEnvironment env)</span><br><span class="line">    &#123;</span><br><span class="line">        if (env.IsDevelopment())</span><br><span class="line">        &#123;</span><br><span class="line">            app.UseDeveloperExceptionPage();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;添加IdentityServer中间件到Pipeline</span><br><span class="line">        app.UseIdentityServer();</span><br><span class="line">        app.UseStaticFiles();</span><br><span class="line">        app.UseMvcWithDefaultRoute();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>配置完，添加IdentityServer到Pipeline即可。</p>
<p>如果要支持第三方登录服务或自己实现的OpenId Connect服务，则需要额外配置下身份认证中间件。</p>
<h2 id="6-2-Resources的保护配置"><a href="#6-2-Resources的保护配置" class="headerlink" title="6.2. Resources的保护配置"></a>6.2. Resources的保护配置</h2><p>配置完Identity Server，接下来我们该思考如何来保护Resources，以及如何将所有的认证和授权请求导流到Identity Server呢？<br>在此之前，我们还是要梳理下Client访问Resources的请求顺序：</p>
<ol>
<li>Client请求资源，资源如果需要进行身份认证和授权，则将请求导流到Identity Server。</li>
<li>Identity Server根据Client配置的授权类型，返回【Token】。</li>
<li>Client携带【Token】请求资源。</li>
<li>受保护的资源服务器要能够验证【Token】的正确性。</li>
</ol>
<p>所以针对要保护的资源，我们需要以下配置：</p>
<ol>
<li>指定资源是否需要保护；</li>
<li>指定IdentityServer用来进行认证和授权跳转；</li>
<li>指定Token验证；</li>
</ol>
<p>代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;使用[Authorize]特性，来显式指定受保护的资源</span><br><span class="line">[Route(&quot;[controller]&quot;)]</span><br><span class="line">[Authorize]</span><br><span class="line">public class IdentityController : ControllerBase</span><br><span class="line">&#123;</span><br><span class="line">    [HttpGet]</span><br><span class="line">    public IActionResult Get()</span><br><span class="line">    &#123;</span><br><span class="line">        return new JsonResult(from c in User.Claims select new &#123; c.Type, c.Value &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Startup</span><br><span class="line">&#123;</span><br><span class="line">    public void ConfigureServices(IServiceCollection services)</span><br><span class="line">    &#123;</span><br><span class="line">        services.AddMvcCore()</span><br><span class="line">            .AddAuthorization()</span><br><span class="line">            .AddJsonFormatters();</span><br><span class="line">        &#x2F;&#x2F;指定认证方案</span><br><span class="line">        services.AddAuthentication(&quot;Bearer&quot;)</span><br><span class="line">              &#x2F;&#x2F;添加Token验证服务到DI</span><br><span class="line">            .AddIdentityServerAuthentication(options &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                &#x2F;&#x2F;指定授权地址</span><br><span class="line">                options.Authority &#x3D; &quot;http:&#x2F;&#x2F;localhost:5000&quot;;</span><br><span class="line">                options.RequireHttpsMetadata &#x3D; false;</span><br><span class="line">                options.ApiName &#x3D; &quot;api1&quot;;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void Configure(IApplicationBuilder app)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;添加认证中间件到Pipeline</span><br><span class="line">        app.UseAuthentication();</span><br><span class="line">        app.UseMvc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-Client的请求配置"><a href="#6-3-Client的请求配置" class="headerlink" title="6.3. Client的请求配置"></a>6.3. Client的请求配置</h2><p>资源和认证服务器都配置完毕，接下来客户端就可以直接访问了。<br>如果针对控制台客户端应用，三步走就可以访问Api：</p>
<ol>
<li>使用DiscoverClient发现Token Endpoint</li>
<li>使用TokenClient请求Access Token</li>
<li>使用HttpClient访问Api<br>代码示例如下：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; discover endpoints from metadata</span><br><span class="line">var disco &#x3D; await DiscoveryClient.GetAsync(&quot;http:&#x2F;&#x2F;localhost:5000&quot;);</span><br><span class="line">&#x2F;&#x2F; request token（使用的是ClientCredentials授权类型）</span><br><span class="line">var tokenClient &#x3D; new TokenClient(disco.TokenEndpoint, &quot;client&quot;, &quot;secret&quot;);</span><br><span class="line">var tokenResponse &#x3D; await tokenClient.RequestClientCredentialsAsync(&quot;api1&quot;)</span><br><span class="line">if (tokenResponse.IsError)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(tokenResponse.Error);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(tokenResponse.Json);</span><br><span class="line">Console.WriteLine(&quot;\n\n&quot;);</span><br><span class="line">&#x2F;&#x2F; call api</span><br><span class="line">var client &#x3D; new HttpClient();</span><br><span class="line">client.SetBearerToken(tokenResponse.AccessToken);</span><br></pre></td></tr></table></figure>

<p>如果针对ASP.NET Web控制台客户端，我们先来回答一个问题：</p>
<ol>
<li>如果Web应用是否需要登录？</li>
<li>如果需要登录，就需要进行身份认证。</li>
<li>身份认证成功后，也就需要会话状态的维持。</li>
</ol>
<p>回答完上面的问题，我们也就梳理出了配置要点：</p>
<ol>
<li>添加身份认证中间件</li>
<li>启用Cookie进行会话保持</li>
<li>添加OIDC，使用我们自己定义的IdentityServer提供的认证服务</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void ConfigureServices(IServiceCollection services)</span><br><span class="line">&#123;</span><br><span class="line">    services.AddMvc();</span><br><span class="line">    JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear();</span><br><span class="line">    services.AddAuthentication(options &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            options.DefaultScheme &#x3D; &quot;Cookies&quot;;</span><br><span class="line">            options.DefaultChallengeScheme &#x3D; &quot;oidc&quot;;</span><br><span class="line">        &#125;)</span><br><span class="line">        .AddCookie(&quot;Cookies&quot;)</span><br><span class="line">        .AddOpenIdConnect(&quot;oidc&quot;, options &#x3D;&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            options.SignInScheme &#x3D; &quot;Cookies&quot;;</span><br><span class="line">            options.Authority &#x3D; &quot;http:&#x2F;&#x2F;localhost:5000&quot;;</span><br><span class="line">            options.RequireHttpsMetadata &#x3D; false;</span><br><span class="line">            options.ClientId &#x3D; &quot;mvc&quot;;</span><br><span class="line">            options.SaveTokens &#x3D; true;</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">public void Configure(IApplicationBuilder app, IHostingEnvironment env</span><br><span class="line">&#123;</span><br><span class="line">    if (env.IsDevelopment())</span><br><span class="line">    &#123;</span><br><span class="line">        app.UseDeveloperExceptionPage();</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        app.UseExceptionHandler(&quot;&#x2F;Home&#x2F;Error&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    app.UseAuthentication();</span><br><span class="line">    app.UseStaticFiles();</span><br><span class="line">    app.UseMvcWithDefaultRoute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="7-最后"><a href="#7-最后" class="headerlink" title="7. 最后"></a>7. 最后</h1><p>本文通过介绍IdentityServer4涉及到的术语和相关概念，再结合官方实例，梳理了集成IdentityServer4的大致思路。而关于如何与ASP.NET Identity、EF Core集成，本文并未涉及，详参官方文档。</p>
<blockquote>
<p><a href="http://docs.identityserver.io/en/release/index.html" target="_blank" rel="noopener">Identity Server 官方文档</a><br><a href="https://www.cnblogs.com/stulzq/p/8119928.html" target="_blank" rel="noopener">dentityServer4 中文文档与实战</a></p>
<p><a href="https://www.cnblogs.com/RainingNight/p/jwtbearer-authentication-in-asp-net-core.html" target="_blank" rel="noopener">JwtBearer认证</a></p>
<p><a href="https://swagger.io/docs/specification/authentication/bearer-authentication/" target="_blank" rel="noopener">Bearer Authentication</a><br><a href="https://jwt.io/introduction/" target="_blank" rel="noopener">JSON Web Token</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html" target="_blank" rel="noopener">理解OAuth 2.0</a><br><a href="http://docs.identityserver.io/en/release/topics/grant_types.html" target="_blank" rel="noopener">Identity Server 授权类型</a></p>
</blockquote>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>id4</tag>
        <tag>OAuth2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>IO模型知多少 | 代码篇</title>
    <url>/post/how-much-you-know-about-the-io-model-demo/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>之前的一篇介绍IO 模型的文章比较偏理论，很多同学反应不是很好理解。这一篇咱们换一个角度，从代码角度来分析一下。</p>
<h1 id="socket-编程基础"><a href="#socket-编程基础" class="headerlink" title="socket 编程基础"></a>socket 编程基础</h1><p>开始之前，我们先来梳理一下，需要提前了解的几个概念：</p>
<blockquote>
<p>socket: 直译为“插座”，在计算机通信领域，socket 被翻译为“套接字”，它是计算机之间进行通信的一种约定或一种方式。通过 socket 这种约定，一台计算机可以接收其他计算机的数据，也可以向其他计算机发送数据。我们把插头插到插座上就能从电网获得电力供应，同样，应用程序为了与远程计算机进行数据传输，需要连接到因特网，而 socket 就是用来连接到因特网的工具。</p>
</blockquote>
<p>另外还需要知道的是，socket 编程的基本流程。<br><img src="/images/how-much-you-know-about-the-io-model-demo/2799767-5f95e14aac563bce.png" alt="Socket 编程流程"></p>
<h1 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h1><p>先回顾下概念：阻塞IO是指，应用进程中线程在发起IO调用后至内核执行IO操作返回结果之前，若发起系统调用的线程一直处于等待状态，则此次IO操作为阻塞IO。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void Start()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;1. 创建Tcp Socket对象</span><br><span class="line">    var serverSocket &#x3D; new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">    var ipEndpoint &#x3D; new IPEndPoint(IPAddress.Loopback, 5001);</span><br><span class="line">    &#x2F;&#x2F;2. 绑定Ip端口</span><br><span class="line">    serverSocket.Bind(ipEndpoint);</span><br><span class="line">    &#x2F;&#x2F;3. 开启监听，指定最大连接数</span><br><span class="line">    serverSocket.Listen(10);</span><br><span class="line">    Console.WriteLine($&quot;服务端已启动(&#123;ipEndpoint&#125;)-等待连接...&quot;);</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;4. 等待客户端连接</span><br><span class="line">        var clientSocket &#x3D; serverSocket.Accept();&#x2F;&#x2F;阻塞</span><br><span class="line">        Console.WriteLine($&quot;&#123;clientSocket.RemoteEndPoint&#125;-已连接&quot;);</span><br><span class="line">        Span&lt;byte&gt; buffer &#x3D; new Span&lt;byte&gt;(new byte[512]);</span><br><span class="line">        Console.WriteLine($&quot;&#123;clientSocket.RemoteEndPoint&#125;-开始接收数据...&quot;);</span><br><span class="line">        int readLength &#x3D; clientSocket.Receive(buffer);&#x2F;&#x2F;阻塞</span><br><span class="line">        var msg &#x3D; Encoding.UTF8.GetString(buffer.ToArray(), 0, readLength);</span><br><span class="line">        Console.WriteLine($&quot;&#123;clientSocket.RemoteEndPoint&#125;-接收数据：&#123;msg&#125;&quot;);</span><br><span class="line">        var sendBuffer &#x3D; Encoding.UTF8.GetBytes($&quot;received:&#123;msg&#125;&quot;);</span><br><span class="line">        clientSocket.Send(sendBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/how-much-you-know-about-the-io-model-demo/2799767-c4034c0af2e3b32f.gif" alt=""></p>
<p>代码很简单，直接看注释就OK了，运行结果如上图所示，但有几个问题点需要着重说明下：</p>
<ol>
<li>等待连接处<code>serverSocket.Accept()</code>，线程阻塞！</li>
<li>接收数据处<code>clientSocket.Receive(buffer)</code>，线程阻塞！</li>
</ol>
<p>会导致什么问题呢：</p>
<ol>
<li>只有一次数据读取完成后，才可以接受下一个连接请求</li>
<li>一个连接，只能接收一次数据</li>
</ol>
<h1 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h1><p>看完，你可能会说，这两个问题很好解决啊，创建一个新线程去接收数据就是了。于是就有了下面的代码改进。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void Start2()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;1. 创建Tcp Socket对象</span><br><span class="line">    var serverSocket &#x3D; new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">    var ipEndpoint &#x3D; new IPEndPoint(IPAddress.Loopback, 5001);</span><br><span class="line">    &#x2F;&#x2F;2. 绑定Ip端口</span><br><span class="line">    serverSocket.Bind(ipEndpoint);</span><br><span class="line">    &#x2F;&#x2F;3. 开启监听，指定最大连接数</span><br><span class="line">    serverSocket.Listen(10);</span><br><span class="line">    Console.WriteLine($&quot;服务端已启动(&#123;ipEndpoint&#125;)-等待连接...&quot;);</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;4. 等待客户端连接</span><br><span class="line">        var clientSocket &#x3D; serverSocket.Accept();&#x2F;&#x2F;阻塞</span><br><span class="line">        Task.Run(() &#x3D;&gt; ReceiveData(clientSocket));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void ReceiveData(Socket clientSocket)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine($&quot;&#123;clientSocket.RemoteEndPoint&#125;-已连接&quot;);</span><br><span class="line">    Span&lt;byte&gt; buffer &#x3D; new Span&lt;byte&gt;(new byte[512]);</span><br><span class="line"></span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        if (clientSocket.Available &#x3D;&#x3D; 0) continue;</span><br><span class="line">        Console.WriteLine($&quot;&#123;clientSocket.RemoteEndPoint&#125;-开始接收数据...&quot;);</span><br><span class="line">        int readLength &#x3D; clientSocket.Receive(buffer);&#x2F;&#x2F;阻塞</span><br><span class="line">        var msg &#x3D; Encoding.UTF8.GetString(buffer.ToArray(), 0, readLength);</span><br><span class="line">        Console.WriteLine($&quot;&#123;clientSocket.RemoteEndPoint&#125;-接收数据：&#123;msg&#125;&quot;);</span><br><span class="line">        var sendBuffer &#x3D; Encoding.UTF8.GetBytes($&quot;received:&#123;msg&#125;&quot;);</span><br><span class="line">        clientSocket.Send(sendBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/how-much-you-know-about-the-io-model-demo/2799767-12046ce197b2f2b3.gif" alt="多线程"></p>
<p>是的，多线程解决了上述的问题，但如果你观察以上动图后，你应该能发现个问题：<strong>才建立4个客户端连接，CPU的占用率就开始直线上升了。</strong></p>
<p>而这个问题的本质就是，服务端的IO模型为阻塞IO模型，为了解决阻塞导致的问题，采用重复轮询，导致无效的系统调用，从而导致CPU持续走高。</p>
<h1 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><p>既然知道原因所在，咱们就来予以改造。适用异步方式来处理连接、接收和发送数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class NioServer</span><br><span class="line">&#123;</span><br><span class="line">    private static ManualResetEvent _acceptEvent &#x3D; new ManualResetEvent(true);</span><br><span class="line">    private static ManualResetEvent _readEvent &#x3D; new ManualResetEvent(true);</span><br><span class="line">    public static void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;1. 创建Tcp Socket对象</span><br><span class="line">        var serverSocket &#x3D; new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);</span><br><span class="line">        &#x2F;&#x2F; serverSocket.Blocking &#x3D; false;&#x2F;&#x2F;设置为非阻塞</span><br><span class="line">        var ipEndpoint &#x3D; new IPEndPoint(IPAddress.Loopback, 5001);</span><br><span class="line">        &#x2F;&#x2F;2. 绑定Ip端口</span><br><span class="line">        serverSocket.Bind(ipEndpoint);</span><br><span class="line">        &#x2F;&#x2F;3. 开启监听，指定最大连接数</span><br><span class="line">        serverSocket.Listen(10);</span><br><span class="line">        Console.WriteLine($&quot;服务端已启动(&#123;ipEndpoint&#125;)-等待连接...&quot;);</span><br><span class="line"></span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            _acceptEvent.Reset();&#x2F;&#x2F;重置信号量</span><br><span class="line">            serverSocket.BeginAccept(OnClientConnected, serverSocket);</span><br><span class="line">            _acceptEvent.WaitOne();&#x2F;&#x2F;阻塞</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void OnClientConnected(IAsyncResult ar)</span><br><span class="line">    &#123;</span><br><span class="line">        _acceptEvent.Set();&#x2F;&#x2F;当有客户端连接进来后，则释放信号量</span><br><span class="line">        var serverSocket &#x3D; ar.AsyncState as Socket;</span><br><span class="line">        Debug.Assert(serverSocket !&#x3D; null, nameof(serverSocket) + &quot; !&#x3D; null&quot;);</span><br><span class="line"></span><br><span class="line">        var clientSocket &#x3D; serverSocket.EndAccept(ar);</span><br><span class="line">        Console.WriteLine($&quot;&#123;clientSocket.RemoteEndPoint&#125;-已连接&quot;);</span><br><span class="line">        </span><br><span class="line">        while (true)</span><br><span class="line">        &#123;</span><br><span class="line">            _readEvent.Reset();&#x2F;&#x2F;重置信号量</span><br><span class="line">            var stateObj &#x3D; new StateObject &#123; ClientSocket &#x3D; clientSocket &#125;;</span><br><span class="line">            clientSocket.BeginReceive(stateObj.Buffer, 0, stateObj.Buffer.Length, SocketFlags.None, OnMessageReceived, stateObj);</span><br><span class="line">            _readEvent.WaitOne();&#x2F;&#x2F;阻塞等待</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void OnMessageReceived(IAsyncResult ar)</span><br><span class="line">    &#123;</span><br><span class="line">        var state &#x3D; ar.AsyncState as StateObject;</span><br><span class="line">        Debug.Assert(state !&#x3D; null, nameof(state) + &quot; !&#x3D; null&quot;);</span><br><span class="line">        var receiveLength &#x3D; state.ClientSocket.EndReceive(ar);</span><br><span class="line"></span><br><span class="line">        if (receiveLength &gt; 0)</span><br><span class="line">        &#123;</span><br><span class="line">            var msg &#x3D; Encoding.UTF8.GetString(state.Buffer, 0, receiveLength);</span><br><span class="line">            Console.WriteLine($&quot;&#123;state.ClientSocket.RemoteEndPoint&#125;-接收数据：&#123;msg&#125;&quot;);</span><br><span class="line"></span><br><span class="line">            var sendBuffer &#x3D; Encoding.UTF8.GetBytes($&quot;received:&#123;msg&#125;&quot;);</span><br><span class="line">            state.ClientSocket.BeginSend(sendBuffer, 0, sendBuffer.Length, SocketFlags.None,</span><br><span class="line">                SendMessage, state.ClientSocket);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void SendMessage(IAsyncResult ar)</span><br><span class="line">    &#123;</span><br><span class="line">        var clientSocket &#x3D; ar.AsyncState as Socket;</span><br><span class="line">        Debug.Assert(clientSocket !&#x3D; null, nameof(clientSocket) + &quot; !&#x3D; null&quot;);</span><br><span class="line">        clientSocket.EndSend(ar);</span><br><span class="line">        _readEvent.Set(); &#x2F;&#x2F;发送完毕后，释放信号量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class StateObject</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; Client  socket.  </span><br><span class="line">    public Socket ClientSocket &#x3D; null;</span><br><span class="line">    &#x2F;&#x2F; Size of receive buffer.  </span><br><span class="line">    public const int BufferSize &#x3D; 1024;</span><br><span class="line">    &#x2F;&#x2F; Receive buffer.  </span><br><span class="line">    public byte[] Buffer &#x3D; new byte[BufferSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先来看运行结果，从下图可以看到，除了建立连接时CPU出现抖动外，在消息接收和发送阶段，CPU占有率趋于平缓，且占用率低。</p>
<p><img src="/images/how-much-you-know-about-the-io-model-demo/2799767-bf36d3ea3c3ec980.gif" alt=""></p>
<p>分析代码后我们发现：</p>
<ol>
<li>CPU使用率是下来了，但代码复杂度上升了。</li>
<li>使用异步接口处理客户端连接：<code>BeginAccept</code>和<code>EndAccept</code></li>
<li>使用异步接口接收数据：<code>BeginReceive</code>和<code>EndReceive</code></li>
<li>使用异步接口发送数据：<code>BeginSend</code>和<code>EndSend</code></li>
<li>使用<code>ManualResetEvent</code>进行线程同步，避免线程空转</li>
</ol>
<p>那你可能好奇，以上模型是何种IO多路复用模型呢？<br>好问题，我们来一探究竟。</p>
<h1 id="验证I-O模型"><a href="#验证I-O模型" class="headerlink" title="验证I/O模型"></a>验证I/O模型</h1><p>要想验证应用使用的何种IO模型，只需要确定应用运行时发起了哪些系统调用即可。对于Linux系统来说，我们可以借助<code>strace</code>命令来跟踪指定应用发起的系统调用和信号。</p>
<h2 id="验证同步阻塞I-O发起的系统调用"><a href="#验证同步阻塞I-O发起的系统调用" class="headerlink" title="验证同步阻塞I/O发起的系统调用"></a>验证同步阻塞I/O发起的系统调用</h2><p>可以使用VSCode Remote 连接到自己的Linux系统上，然后新建项目<code>Io.Demo</code>，以上面非阻塞IO的代码进行测试，执行以下启动跟踪命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet$ ls</span><br><span class="line">Io.Demo</span><br><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet$ strace -ff -o Io.Demo&#x2F;strace&#x2F;io dotnet run --project Io.Demo&#x2F;</span><br><span class="line">Press any key to start!</span><br><span class="line">服务端已启动(127.0.0.1:5001)-等待连接...</span><br><span class="line">127.0.0.1:36876-已连接</span><br><span class="line">127.0.0.1:36876-开始接收数据...</span><br><span class="line">127.0.0.1:36876-接收数据：1</span><br></pre></td></tr></table></figure>

<p>另起命令行，执行’nc localhost 5001`模拟客户端连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ nc localhost 5001</span><br><span class="line">1</span><br><span class="line">received:1</span><br></pre></td></tr></table></figure>

<p>使用<code>netstat</code>命令查看建立的连接。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:&#x2F;proc&#x2F;3763$ netstat -natp | grep 5001</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 127.0.0.1:5001          0.0.0.0:*               LISTEN      3763&#x2F;Io.Demo        </span><br><span class="line">tcp        0      0 127.0.0.1:36920         127.0.0.1:5001          ESTABLISHED 3798&#x2F;nc             </span><br><span class="line">tcp        0      0 127.0.0.1:5001          127.0.0.1:36920         ESTABLISHED 3763&#x2F;Io.Demo </span><br><span class="line">&#96;</span><br></pre></td></tr></table></figure>

<p>另起命令行，执行<code>ps -h | grep dotnet</code>  抓取进程Id。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ ps -h | grep dotnet</span><br><span class="line"> 3694 pts&#x2F;1    S+     0:11 strace -ff -o Io.Demo&#x2F;strace&#x2F;io dotnet run --project Io.Demo&#x2F;</span><br><span class="line"> 3696 pts&#x2F;1    Sl+    0:01 dotnet run --project Io.Demo&#x2F;</span><br><span class="line"> 3763 pts&#x2F;1    Sl+    0:00 &#x2F;home&#x2F;shengjie&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;bin&#x2F;Debug&#x2F;netcoreapp3.0&#x2F;Io.Demo</span><br><span class="line"> 3779 pts&#x2F;2    S+     0:00 grep --color&#x3D;auto dotnet</span><br><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet$ ls Io.Demo&#x2F;strace&#x2F; # 查看生成的系统调用文件</span><br><span class="line">io.3696  io.3702  io.3708  io.3714  io.3720  io.3726  io.3732  io.3738  io.3744  io.3750  io.3766  io.3772  io.3782  io.3827</span><br><span class="line">io.3697  io.3703  io.3709  io.3715  io.3721  io.3727  io.3733  io.3739  io.3745  io.3751  io.3767  io.3773  io.3786  io.3828</span><br><span class="line">io.3698  io.3704  io.3710  io.3716  io.3722  io.3728  io.3734  io.3740  io.3746  io.3752  io.3768  io.3774  io.3787</span><br><span class="line">io.3699  io.3705  io.3711  io.3717  io.3723  io.3729  io.3735  io.3741  io.3747  io.3763  io.3769  io.3777  io.3797</span><br><span class="line">io.3700  io.3706  io.3712  io.3718  io.3724  io.3730  io.3736  io.3742  io.3748  io.3764  io.3770  io.3780  io.3799</span><br><span class="line">io.3701  io.3707  io.3713  io.3719  io.3725  io.3731  io.3737  io.3743  io.3749  io.3765  io.3771  io.3781  io.3800</span><br></pre></td></tr></table></figure>
<p>有上可知，进程Id为3763，依次执行以下命令可以查看该进程的线程和产生的文件描述符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ cd &#x2F;proc&#x2F;3763 # 进入进程目录</span><br><span class="line">shengjie@ubuntu:&#x2F;proc&#x2F;3763$ ls</span><br><span class="line">attr        cmdline          environ  io         mem         ns             pagemap      sched      smaps_rollup  syscall        wchan</span><br><span class="line">autogroup   comm             exe      limits     mountinfo   numa_maps      patch_state  schedstat  stack         task</span><br><span class="line">auxv        coredump_filter  fd       loginuid   mounts      oom_adj        personality  sessionid  stat          timers</span><br><span class="line">cgroup      cpuset           fdinfo   map_files  mountstats  oom_score      projid_map   setgroups  statm         timerslack_ns</span><br><span class="line">clear_refs  cwd              gid_map  maps       net         oom_score_adj  root         smaps      status        uid_map</span><br><span class="line">shengjie@ubuntu:&#x2F;proc&#x2F;3763$ ll task # 查看当前进程启动的线程</span><br><span class="line">total 0</span><br><span class="line">dr-xr-xr-x 9 shengjie shengjie 0 5月  10 16:36 .&#x2F;</span><br><span class="line">dr-xr-xr-x 9 shengjie shengjie 0 5月  10 16:34 ..&#x2F;</span><br><span class="line">dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3763&#x2F;</span><br><span class="line">dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3765&#x2F;</span><br><span class="line">dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3766&#x2F;</span><br><span class="line">dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3767&#x2F;</span><br><span class="line">dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3768&#x2F;</span><br><span class="line">dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3769&#x2F;</span><br><span class="line">dr-xr-xr-x 7 shengjie shengjie 0 5月  10 16:36 3770&#x2F;</span><br><span class="line">shengjie@ubuntu:&#x2F;proc&#x2F;3763$ ll fd 查看当前进程系统调用产生的文件描述符</span><br><span class="line">total 0</span><br><span class="line">dr-x------ 2 shengjie shengjie  0 5月  10 16:36 .&#x2F;</span><br><span class="line">dr-xr-xr-x 9 shengjie shengjie  0 5月  10 16:34 ..&#x2F;</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 0 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 1 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 10 -&gt; &#39;socket:[44292]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 100 -&gt; &#x2F;dev&#x2F;random</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 11 -&gt; &#39;socket:[41675]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 13 -&gt; &#39;pipe:[45206]&#39;</span><br><span class="line">l-wx------ 1 shengjie shengjie 64 5月  10 16:37 14 -&gt; &#39;pipe:[45206]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 15 -&gt; &#x2F;home&#x2F;shengjie&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;bin&#x2F;Debug&#x2F;netcoreapp3.0&#x2F;Io.Demo.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 16 -&gt; &#x2F;home&#x2F;shengjie&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;bin&#x2F;Debug&#x2F;netcoreapp3.0&#x2F;Io.Demo.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 17 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Runtime.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 18 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Console.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 19 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Threading.dll</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 2 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 20 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Runtime.Extensions.dll</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 21 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 22 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Text.Encoding.Extensions.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 23 -&gt; &#x2F;dev&#x2F;urandom</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 24 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Net.Sockets.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 25 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Net.Primitives.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 26 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;Microsoft.Win32.Primitives.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 27 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Diagnostics.Tracing.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 28 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Threading.Tasks.dll</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 29 -&gt; &#39;socket:[43429]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 3 -&gt; &#39;pipe:[42148]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 30 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Threading.ThreadPool.dll</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 31 -&gt; &#39;socket:[42149]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 32 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Memory.dll</span><br><span class="line">l-wx------ 1 shengjie shengjie 64 5月  10 16:37 4 -&gt; &#39;pipe:[42148]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 42 -&gt; &#x2F;dev&#x2F;urandom</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 5 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 6 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 16:37 7 -&gt; &#x2F;dev&#x2F;pts&#x2F;1</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 9 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Private.CoreLib.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 16:37 99 -&gt; &#x2F;dev&#x2F;urandom</span><br></pre></td></tr></table></figure>
<p>从上面的输出来看，.NET Core控制台应用启动时启动了多个线程，并在10、11、29、31号文件描述符启动了socket监听。那哪一个文件描述符监听的是5001端口呢。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ cat &#x2F;proc&#x2F;net&#x2F;tcp | grep 1389 # 查看5001端口号相关的tcp链接（0x1389 为5001十六进制)</span><br><span class="line">   4: 0100007F:1389 00000000:0000 0A 00000000:00000000 00:00000000 00000000  1000        0 43429 1 0000000000000000 100 0 0 10 0                     </span><br><span class="line">  12: 0100007F:9038 0100007F:1389 01 00000000:00000000 00:00000000 00000000  1000        0 44343 1 0000000000000000 20 4 30 10 -1                    </span><br><span class="line">  13: 0100007F:1389 0100007F:9038 01 00000000:00000000 00:00000000 00000000  1000        0 42149 1 0000000000000000 20 4 29 10 -1</span><br></pre></td></tr></table></figure>
<p>从中可以看到inode为[43429]的socket监听在5001端口号，所以可以找到上面的输出行<code>lrwx------ 1 shengjie shengjie 64 5月  10 16:37 29 -&gt; &#39;socket:[43429]&#39;</code>，进而判断监听5001端口号socket对应的文件描述符为29。</p>
<p>当然，也可以从记录到<code>strace</code>目录的日志文件找到线索。在文中我们已经提及，socket服务端编程的一般流程，都要经过socket-&gt;bind-&gt;accept-&gt;read-&gt;write流程。所以可以通过抓取关键字，查看相关系统调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ grep &#39;bind&#39; strace&#x2F; -rn</span><br><span class="line">strace&#x2F;io.3696:4570:bind(10, &#123;sa_family&#x3D;AF_UNIX, sun_path&#x3D;&quot;&#x2F;tmp&#x2F;dotnet-diagnostic-3696-327175-socket&quot;&#125;, 110) &#x3D; 0</span><br><span class="line">strace&#x2F;io.3763:2241:bind(11, &#123;sa_family&#x3D;AF_UNIX, sun_path&#x3D;&quot;&#x2F;tmp&#x2F;dotnet-diagnostic-3763-328365-socket&quot;&#125;, 110) &#x3D; 0</span><br><span class="line">strace&#x2F;io.3763:2949:bind(29, &#123;sa_family&#x3D;AF_INET, sin_port&#x3D;htons(5001), sin_addr&#x3D;inet_addr(&quot;127.0.0.1&quot;)&#125;, 16) &#x3D; 0</span><br><span class="line">strace&#x2F;io.3713:4634:bind(11, &#123;sa_family&#x3D;AF_UNIX, sun_path&#x3D;&quot;&#x2F;tmp&#x2F;dotnet-diagnostic-3713-327405-socket&quot;&#125;, 110) &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>从上可知，在主线程也就是<code>io.3763</code>线程的系统调用文件中，将29号文件描述符与监听在<code>127.0.0.1:5001</code>的socket进行了绑定。同时也明白了.NET Core自动建立的另外2个socket是与diagnostic相关。<br>接下来咱们重点看下3763号线程产生的系统调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ cd strace&#x2F;</span><br><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;strace$ cat io.3763 # 仅截取相关片段</span><br><span class="line">socket(AF_INET, SOCK_STREAM|SOCK_CLOEXEC, IPPROTO_TCP) &#x3D; 29</span><br><span class="line">setsockopt(29, SOL_SOCKET, SO_REUSEADDR, [1], 4) &#x3D; 0</span><br><span class="line">bind(29, &#123;sa_family&#x3D;AF_INET, sin_port&#x3D;htons(5001), sin_addr&#x3D;inet_addr(&quot;127.0.0.1&quot;)&#125;, 16) &#x3D; 0</span><br><span class="line">listen(29, 10)       </span><br><span class="line">write(21, &quot;\346\234\215\345\212\241\347\253\257\345\267\262\345\220\257\345\212\250(127.0.0.1:500&quot;..., 51) &#x3D; 51</span><br><span class="line">accept4(29, &#123;sa_family&#x3D;AF_INET, sin_port&#x3D;htons(36920), sin_addr&#x3D;inet_addr(&quot;127.0.0.1&quot;)&#125;, [16], SOCK_CLOEXEC) &#x3D; 31</span><br><span class="line">write(21, &quot;127.0.0.1:36920-\345\267\262\350\277\236\346\216\245\n&quot;, 26) &#x3D; 26</span><br><span class="line">write(21, &quot;127.0.0.1:36920-\345\274\200\345\247\213\346\216\245\346\224\266\346\225\260\346&quot;..., 38) &#x3D; 38</span><br><span class="line">recvmsg(31, &#123;msg_name&#x3D;NULL, msg_namelen&#x3D;0, msg_iov&#x3D;[&#123;iov_base&#x3D;&quot;1\n&quot;, iov_len&#x3D;512&#125;], msg_iovlen&#x3D;1, msg_controllen&#x3D;0, msg_flags&#x3D;0&#125;, 0) &#x3D; 2</span><br><span class="line">write(21, &quot;127.0.0.1:36920-\346\216\245\346\224\266\346\225\260\346\215\256\357\274\2321&quot;..., 34) &#x3D; 34</span><br><span class="line">sendmsg(31, &#123;msg_name&#x3D;NULL, msg_namelen&#x3D;0, msg_iov&#x3D;[&#123;iov_base&#x3D;&quot;received:1\n&quot;, iov_len&#x3D;11&#125;], msg_iovlen&#x3D;1, msg_controllen&#x3D;0, msg_flags&#x3D;0&#125;, 0) &#x3D; 11</span><br><span class="line">accept4(29, 0x7fecf001c978, [16], SOCK_CLOEXEC) &#x3D; ? ERESTARTSYS (To be restarted if SA_RESTART is set)</span><br><span class="line">--- SIGWINCH &#123;si_signo&#x3D;SIGWINCH, si_code&#x3D;SI_KERNEL&#125; ---</span><br></pre></td></tr></table></figure>
<p>从中我们可以发现几个关键的系统调用：</p>
<ol>
<li>socket</li>
<li>bind</li>
<li>listen</li>
<li>accept4</li>
<li>recvmsg</li>
<li>sendmsg<br>通过命令<code>man</code>命令可以查看下<code>accept4</code>和<code>recvmsg</code>系统调用的相关说明：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;strace$ man accept4</span><br><span class="line">If no pending connections are present on the queue, and the socket is not marked as nonblocking, accept() blocks the caller until a</span><br><span class="line">       connection  is  present.</span><br><span class="line"></span><br><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;strace$ man recvmsg</span><br><span class="line">If  no  messages are available at the socket, the receive calls wait for a message to arrive, unless the socket is nonblocking (see fcntl(2))</span><br></pre></td></tr></table></figure>
也就是说<code>accept4</code>和<code>recvmsg</code>是阻塞式系统调用。</li>
</ol>
<h2 id="验证I-O多路复用发起的系统调用"><a href="#验证I-O多路复用发起的系统调用" class="headerlink" title="验证I/O多路复用发起的系统调用"></a>验证I/O多路复用发起的系统调用</h2><p>同样以上面I/O多路复用的代码进行验证，验证步骤类似：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet$ strace -ff -o Io.Demo&#x2F;strace2&#x2F;io dotnet run --project Io.Demo&#x2F;</span><br><span class="line">Press any key to start!</span><br><span class="line">服务端已启动(127.0.0.1:5001)-等待连接...</span><br><span class="line">127.0.0.1:37098-已连接</span><br><span class="line">127.0.0.1:37098-接收数据：1</span><br><span class="line"></span><br><span class="line">127.0.0.1:37098-接收数据：2</span><br><span class="line"></span><br><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ nc localhost 5001</span><br><span class="line">1</span><br><span class="line">received:1</span><br><span class="line">2</span><br><span class="line">received:2</span><br><span class="line"></span><br><span class="line">shengjie@ubuntu:&#x2F;proc&#x2F;2449$ netstat -natp | grep 5001</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 127.0.0.1:5001          0.0.0.0:*               LISTEN      2449&#x2F;Io.Demo        </span><br><span class="line">tcp        0      0 127.0.0.1:5001          127.0.0.1:56296         ESTABLISHED 2449&#x2F;Io.Demo        </span><br><span class="line">tcp        0      0 127.0.0.1:56296         127.0.0.1:5001          ESTABLISHED 2499&#x2F;nc        </span><br><span class="line"></span><br><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ ps -h | grep dotnet</span><br><span class="line"> 2400 pts&#x2F;3    S+     0:10 strace -ff -o .&#x2F;Io.Demo&#x2F;strace2&#x2F;io dotnet run --project Io.Demo&#x2F;</span><br><span class="line"> 2402 pts&#x2F;3    Sl+    0:01 dotnet run --project Io.Demo&#x2F;</span><br><span class="line"> 2449 pts&#x2F;3    Sl+    0:00 &#x2F;home&#x2F;shengjie&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;bin&#x2F;Debug&#x2F;netcoreapp3.0&#x2F;Io.Demo</span><br><span class="line"> 2516 pts&#x2F;5    S+     0:00 grep --color&#x3D;auto dotnet</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ cd &#x2F;proc&#x2F;2449&#x2F;</span><br><span class="line">shengjie@ubuntu:&#x2F;proc&#x2F;2449$ ll task</span><br><span class="line">total 0</span><br><span class="line">dr-xr-xr-x 11 shengjie shengjie 0 5月  10 22:15 .&#x2F;</span><br><span class="line">dr-xr-xr-x  9 shengjie shengjie 0 5月  10 22:15 ..&#x2F;</span><br><span class="line">dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2449&#x2F;</span><br><span class="line">dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2451&#x2F;</span><br><span class="line">dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2452&#x2F;</span><br><span class="line">dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2453&#x2F;</span><br><span class="line">dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2454&#x2F;</span><br><span class="line">dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2455&#x2F;</span><br><span class="line">dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2456&#x2F;</span><br><span class="line">dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2459&#x2F;</span><br><span class="line">dr-xr-xr-x  7 shengjie shengjie 0 5月  10 22:15 2462&#x2F;</span><br><span class="line">shengjie@ubuntu:&#x2F;proc&#x2F;2449$ ll fd</span><br><span class="line">total 0</span><br><span class="line">dr-x------ 2 shengjie shengjie  0 5月  10 22:15 .&#x2F;</span><br><span class="line">dr-xr-xr-x 9 shengjie shengjie  0 5月  10 22:15 ..&#x2F;</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 0 -&gt; &#x2F;dev&#x2F;pts&#x2F;3</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 1 -&gt; &#x2F;dev&#x2F;pts&#x2F;3</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 10 -&gt; &#39;socket:[35001]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 100 -&gt; &#x2F;dev&#x2F;random</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 11 -&gt; &#39;socket:[34304]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 13 -&gt; &#39;pipe:[31528]&#39;</span><br><span class="line">l-wx------ 1 shengjie shengjie 64 5月  10 22:16 14 -&gt; &#39;pipe:[31528]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 15 -&gt; &#x2F;home&#x2F;shengjie&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;bin&#x2F;Debug&#x2F;netcoreapp3.0&#x2F;Io.Demo.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 16 -&gt; &#x2F;home&#x2F;shengjie&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;bin&#x2F;Debug&#x2F;netcoreapp3.0&#x2F;Io.Demo.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 17 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Runtime.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 18 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Console.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 19 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Threading.dll</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 2 -&gt; &#x2F;dev&#x2F;pts&#x2F;3</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 20 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Runtime.Extensions.dll</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 21 -&gt; &#x2F;dev&#x2F;pts&#x2F;3</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 22 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Text.Encoding.Extensions.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 23 -&gt; &#x2F;dev&#x2F;urandom</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 24 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Net.Sockets.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 25 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Net.Primitives.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 26 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;Microsoft.Win32.Primitives.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 27 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Diagnostics.Tracing.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 28 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Threading.Tasks.dll</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 29 -&gt; &#39;socket:[31529]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 3 -&gt; &#39;pipe:[32055]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 30 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Threading.ThreadPool.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 31 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Collections.Concurrent.dll</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 32 -&gt; &#39;anon_inode:[eventpoll]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 33 -&gt; &#39;pipe:[32059]&#39;</span><br><span class="line">l-wx------ 1 shengjie shengjie 64 5月  10 22:16 34 -&gt; &#39;pipe:[32059]&#39;</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 35 -&gt; &#39;socket:[35017]&#39;</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 36 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Memory.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 37 -&gt; &#x2F;dev&#x2F;urandom</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 38 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Diagnostics.Debug.dll</span><br><span class="line">l-wx------ 1 shengjie shengjie 64 5月  10 22:16 4 -&gt; &#39;pipe:[32055]&#39;</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 5 -&gt; &#x2F;dev&#x2F;pts&#x2F;3</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 6 -&gt; &#x2F;dev&#x2F;pts&#x2F;3</span><br><span class="line">lrwx------ 1 shengjie shengjie 64 5月  10 22:16 7 -&gt; &#x2F;dev&#x2F;pts&#x2F;3</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 9 -&gt; &#x2F;usr&#x2F;share&#x2F;dotnet&#x2F;shared&#x2F;Microsoft.NETCore.App&#x2F;3.0.0&#x2F;System.Private.CoreLib.dll</span><br><span class="line">lr-x------ 1 shengjie shengjie 64 5月  10 22:16 99 -&gt; &#x2F;dev&#x2F;urandom</span><br><span class="line">shengjie@ubuntu:&#x2F;proc&#x2F;2449$ cat &#x2F;proc&#x2F;net&#x2F;tcp | grep 1389</span><br><span class="line">   0: 0100007F:1389 00000000:0000 0A 00000000:00000000 00:00000000 00000000  1000        0 31529 1 0000000000000000 100 0 0 10 0                     </span><br><span class="line">   8: 0100007F:1389 0100007F:DBE8 01 00000000:00000000 00:00000000 00000000  1000        0 35017 1 0000000000000000 20 4 29 10 -1                    </span><br><span class="line">  12: 0100007F:DBE8 0100007F:1389 01 00000000:00000000 00:00000000 00000000  1000        0 28496 1 0000000000000000 20 4 30 10 -1</span><br></pre></td></tr></table></figure>
<p>过滤<code>strace2</code> 目录日志，抓取监听在<code>localhost:5001</code>socket对应的文件描述符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ grep &#39;bind&#39; strace2&#x2F; -rn</span><br><span class="line">strace2&#x2F;io.2449:2243:bind(11, &#123;sa_family&#x3D;AF_UNIX, sun_path&#x3D;&quot;&#x2F;tmp&#x2F;dotnet-diagnostic-2449-23147-socket&quot;&#125;, 110) &#x3D; 0</span><br><span class="line">strace2&#x2F;io.2449:2950:bind(29, &#123;sa_family&#x3D;AF_INET, sin_port&#x3D;htons(5001), sin_addr&#x3D;inet_addr(&quot;127.0.0.1&quot;)&#125;, 16) &#x3D; 0</span><br><span class="line">strace2&#x2F;io.2365:4568:bind(10, &#123;sa_family&#x3D;AF_UNIX, sun_path&#x3D;&quot;&#x2F;tmp&#x2F;dotnet-diagnostic-2365-19043-socket&quot;&#125;, 110) &#x3D; 0</span><br><span class="line">strace2&#x2F;io.2420:4634:bind(11, &#123;sa_family&#x3D;AF_UNIX, sun_path&#x3D;&quot;&#x2F;tmp&#x2F;dotnet-diagnostic-2420-22262-socket&quot;&#125;, 110) &#x3D; 0</span><br><span class="line">strace2&#x2F;io.2402:4569:bind(10, &#123;sa_family&#x3D;AF_UNIX, sun_path&#x3D;&quot;&#x2F;tmp&#x2F;dotnet-diagnostic-2402-22042-socket&quot;&#125;, 110) &#x3D; 0</span><br></pre></td></tr></table></figure>
<p>从中可以看出同样是29号文件描述符，相关系统调用记录中<code>io.2449</code>文件中，打开文件，可以发现相关系统调用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ cat strace2&#x2F;io.2449 # 截取相关系统调用</span><br><span class="line">socket(AF_INET, SOCK_STREAM|SOCK_CLOEXEC, IPPROTO_TCP) &#x3D; 29</span><br><span class="line">setsockopt(29, SOL_SOCKET, SO_REUSEADDR, [1], 4) &#x3D; 0</span><br><span class="line">bind(29, &#123;sa_family&#x3D;AF_INET, sin_port&#x3D;htons(5001), sin_addr&#x3D;inet_addr(&quot;127.0.0.1&quot;)&#125;, 16) &#x3D; 0</span><br><span class="line">listen(29, 10) </span><br><span class="line">accept4(29, 0x7fa16c01b9e8, [16], SOCK_CLOEXEC) &#x3D; -1 EAGAIN (Resource temporarily unavailable)</span><br><span class="line">epoll_create1(EPOLL_CLOEXEC)            &#x3D; 32</span><br><span class="line">epoll_ctl(32, EPOLL_CTL_ADD, 29, &#123;EPOLLIN|EPOLLOUT|EPOLLET, &#123;u32&#x3D;0, u64&#x3D;0&#125;&#125;) &#x3D; 0</span><br><span class="line">accept4(29, 0x7fa16c01cd60, [16], SOCK_CLOEXEC) &#x3D; -1 EAGAIN (Resource temporarily unavailable)</span><br></pre></td></tr></table></figure>
<p>从中我们可以发现<code>accept4</code>直接返回-1而不阻塞，监听在<code>127.0.0.1:5001</code>的socket对应的29号文件描述符最终作为<code>epoll_ctl</code>的参数关联到<code>epoll_create1</code>创建的32号文件描述符上。最终32号文件描述符会被<code>epoll_wait</code>阻塞，以等待连接请求。我们可以抓取<code>epoll</code>相关的系统调用来验证：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo$ grep &#39;epoll&#39; strace2&#x2F; -rn</span><br><span class="line">strace2&#x2F;io.2459:364:epoll_ctl(32, EPOLL_CTL_ADD, 35, &#123;EPOLLIN|EPOLLOUT|EPOLLET, &#123;u32&#x3D;1, u64&#x3D;1&#125;&#125;) &#x3D; 0</span><br><span class="line">strace2&#x2F;io.2462:21:epoll_wait(32, [&#123;EPOLLIN, &#123;u32&#x3D;0, u64&#x3D;0&#125;&#125;], 1024, -1) &#x3D; 1</span><br><span class="line">strace2&#x2F;io.2462:42:epoll_wait(32, [&#123;EPOLLOUT, &#123;u32&#x3D;1, u64&#x3D;1&#125;&#125;], 1024, -1) &#x3D; 1</span><br><span class="line">strace2&#x2F;io.2462:43:epoll_wait(32, [&#123;EPOLLIN|EPOLLOUT, &#123;u32&#x3D;1, u64&#x3D;1&#125;&#125;], 1024, -1) &#x3D; 1</span><br><span class="line">strace2&#x2F;io.2462:53:epoll_wait(32, </span><br><span class="line">strace2&#x2F;io.2449:3033:epoll_create1(EPOLL_CLOEXEC)            &#x3D; 32</span><br><span class="line">strace2&#x2F;io.2449:3035:epoll_ctl(32, EPOLL_CTL_ADD, 33, &#123;EPOLLIN|EPOLLET, &#123;u32&#x3D;4294967295, u64&#x3D;18446744073709551615&#125;&#125;) &#x3D; 0</span><br><span class="line">strace2&#x2F;io.2449:3061:epoll_ctl(32, EPOLL_CTL_ADD, 29, &#123;EPOLLIN|EPOLLOUT|EPOLLET, &#123;u32&#x3D;0, u64&#x3D;0&#125;&#125;) &#x3D; 0</span><br></pre></td></tr></table></figure>

<p>因此我们可以断定同步非阻塞I/O的示例使用的时IO多路复用的epoll模型。</p>
<p>关于epoll相关命令，man命令可以查看下<code>epoll_create1</code>、<code>epoll_ctl</code>和、<code>epoll_wait</code>系统调用的相关说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;strace$ man epoll_create</span><br><span class="line">DESCRIPTION</span><br><span class="line">       epoll_create() creates a new epoll(7) instance.  Since Linux 2.6.8, the size argument is ignored, but must be</span><br><span class="line">       greater than zero; see NOTES below.</span><br><span class="line"></span><br><span class="line">       epoll_create() returns a file descriptor referring to the new epoll instance.  This file descriptor  is  used</span><br><span class="line">       for  all  the subsequent calls to the epoll interface.</span><br><span class="line"></span><br><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;strace$ man epoll_ctl</span><br><span class="line">DESCRIPTION</span><br><span class="line">       This  system  call  performs  control  operations on the epoll(7) instance referred to by the file descriptor</span><br><span class="line">       epfd.  It requests that the operation op be performed for the target file descriptor, fd.</span><br><span class="line"></span><br><span class="line">       Valid values for the op argument are:</span><br><span class="line"></span><br><span class="line">       EPOLL_CTL_ADD</span><br><span class="line">              Register the target file descriptor fd on the epoll instance referred to by the file  descriptor  epfd</span><br><span class="line">              and associate the event event with the internal file linked to fd.</span><br><span class="line"></span><br><span class="line">       EPOLL_CTL_MOD</span><br><span class="line">              Change the event event associated with the target file descriptor fd.</span><br><span class="line"></span><br><span class="line">       EPOLL_CTL_DEL</span><br><span class="line">              Remove  (deregister)  the  target file descriptor fd from the epoll instance referred to by epfd.  The</span><br><span class="line">              event is ignored and can be NULL (but see BUGS below).</span><br><span class="line"></span><br><span class="line">shengjie@ubuntu:~&#x2F;coding&#x2F;dotnet&#x2F;Io.Demo&#x2F;strace$ man epoll_wait</span><br><span class="line">DESCRIPTION</span><br><span class="line">       The  epoll_wait()  system  call  waits for events on the epoll(7) instance referred to by the file descriptor</span><br><span class="line">       epfd.  The memory area pointed to by events will contain the events that will be available  for  the  caller.</span><br><span class="line">       Up to maxevents are returned by epoll_wait().  The maxevents argument must be greater than zero.</span><br><span class="line"></span><br><span class="line">       The  timeout  argument  specifies  the number of milliseconds that epoll_wait() will block.  Time is measured</span><br><span class="line">       against the CLOCK_MONOTONIC clock.  The call will block until either:</span><br><span class="line"></span><br><span class="line">       *  a file descriptor delivers an event;</span><br><span class="line"></span><br><span class="line">       *  the call is interrupted by a signal handler; or</span><br><span class="line"></span><br><span class="line">       *  the timeout expires.</span><br></pre></td></tr></table></figure>
<p>简而言之，epoll通过创建一个新的文件描述符来替换旧的文件描述符来完成阻塞工作，当有事件或超时时通知原有文件描述符进行处理，以实现非阻塞的线程模型。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>写完这篇文章，对I/O模型的理解有所加深，但由于对Linux系统的了解不深，所以难免有纰漏之处，大家多多指教。<br>同时也不仅感叹Linux的强大之处，一切皆文件的设计思想，让一切都有迹可循。现在.NET 已经完全实现跨平台了，那么Linux操作系统大家就有必要熟悉起来了。</p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>I/O</tag>
        <tag>EPOLL</tag>
      </tags>
  </entry>
  <entry>
    <title>IO模型知多少 | 理论篇</title>
    <url>/post/how-much-you-know-about-the-io-models/</url>
    <content><![CDATA[<p><img src="/images/how-much-you-know-about-the-io-models/2799767-3cd8adef311e9e24-1588340611809.png" alt=""></p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>同步异步I/O，阻塞非阻塞I/O是程序员老生常谈的话题了，也是自己一直以来懵懵懂懂的一个话题。比如：何为同步异步？何为阻塞与非阻塞？二者的区别在哪里？阻塞在何处？为什么会有多种IO模型，分别用来解决问题？常用的框架采用的是何种I/O模型？各种IO模型的优劣势在哪里，适用于何种应用场景？</p>
<p>简而言之，对于I/O的认知，不能仅仅停留在字面上认识，了解内部玄机，才能深刻理解I/O，才能看清I/O相关问题的本质。</p>
<h1 id="2-I-O-的定义"><a href="#2-I-O-的定义" class="headerlink" title="2. I/O 的定义"></a>2. I/O 的定义</h1><p>I/O 的全称是Input/Output。虽常谈及I/O，但想必你也一时不能给出一个完整的定义。搜索了谷歌，发现也尽是些冗长的论述。要想厘清I/O这个概念，我们需要从不同的视角去理解它。</p>
<h2 id="2-1-计算机视角"><a href="#2-1-计算机视角" class="headerlink" title="2.1. 计算机视角"></a>2.1. 计算机视角</h2><p> 冯•诺伊曼计算机的基本思想中有提到计算机硬件组成应为五大部分：控制器，运算器，存储器，输入和输出。其中输入是指将数据输入到计算机的设备，比如键盘鼠标；输出是指从计算机中获取数据的设备，比如显示器；以及既是输入又是输出设备，硬盘，网卡等。</p>
<p>用户通过操作系统才能完成对计算机的操作。计算机启动时，第一个启动的程序是操作系统的内核，它将负责计算机的资源管理和进程的调度。换句话说：操作系统负责从输入设备读取数据并将数据写入到输出设备。</p>
<p>所以I/O之于计算机，有两层意思：</p>
<ol>
<li>I/O设备</li>
<li>对I/O设备的数据读写</li>
</ol>
<p><em>对于一次I/O操作，必然涉及2个参与方，一个输入端，一个输出端，而又根据参与双方的设备类型，我们又可以分为磁盘I/O，网络I/O（一次网络的请求响应，网卡）等。</em></p>
<h2 id="2-2-程序视角"><a href="#2-2-程序视角" class="headerlink" title="2.2. 程序视角"></a>2.2. 程序视角</h2><p>应用程序作为一个文件保存在磁盘中，只有加载到内存到成为一个进程才能运行。应用程序运行在计算机内存中，必然会涉及到数据交换，比如读写磁盘文件，访问数据库，调用远程API等等。但我们编写的程序并不能像操作系统内核一样直接进行I/O操作。</p>
<p>因为为了确保操作系统的安全稳定运行，操作系统启动后，将会开启保护模式：将内存分为内核空间（内核对应进程所在内存空间）和用户空间，进行内存隔离。我们构建的程序将运行在用户空间，用户空间无法操作内核空间，也就意味着用户空间的程序不能直接访问由内核管理的I/O，比如：硬盘、网卡等。</p>
<p>但操作系统向外提供API，其由各种类型的系统调用（System Call）组成，以提供安全的访问控制。<br>所以应用程序要想访问内核管理的I/O，必须通过调用内核提供的系统调用(system call）进行间接访问。</p>
<p>所以I/O之于应用程序来说，强调的通过<strong>向内核发起系统调用完成对I/O的间接访问</strong>。换句话说应用程序发起的一次IO操作实际包含两个阶段：</p>
<ol>
<li>IO调用阶段：应用程序进程向内核发起系统调用</li>
<li>IO执行阶段：内核执行IO操作并返回<br>2.1. 准备数据阶段：内核等待I/O设备准备好数据<br>  2.2. 拷贝数据阶段：将数据从内核缓冲区拷贝到用户空间缓冲区</li>
</ol>
<p>怎么理解准备数据阶段呢？<br>对于写请求：等待系统调用的完整请求数据，并写入内核缓冲区；<br>对于读请求：等待系统调用的完整请求数据；（若请求数据不存在于内核缓冲区）则将外围设备的数据读入到内核缓冲区。</p>
<p> <img src="/images/how-much-you-know-about-the-io-models/2799767-8747395df72a42a1-1588340715108.png" alt="IO操作执行流程"></p>
<p>而应用程序进程在发起IO调用至内核执行IO返回之前，应用程序进程/线程所处状态，就是我们下面要讨论的第二个话题阻塞IO与非阻塞IO。</p>
<h1 id="3-IO-模型之阻塞I-O-BIO"><a href="#3-IO-模型之阻塞I-O-BIO" class="headerlink" title="3. IO 模型之阻塞I/O(BIO)"></a>3. IO 模型之阻塞I/O(BIO)</h1><p>应用程序中进程在发起IO调用后至内核执行IO操作返回结果之前，若发起系统调用的线程一直处于等待状态，则此次IO操作为阻塞IO。阻塞IO简称BIO，Blocking IO。其处理流程如下图所示：</p>
<p><img src="/images/how-much-you-know-about-the-io-models/2799767-69017b641db18e97.png" alt="BIO"></p>
<p>从上图可知当用户进程发起IO系统调用后，内核从准备数据到拷贝数据到用户空间的两个阶段期间<strong>用户调用线程选择阻塞等待</strong>数据返回。</p>
<p>因此BIO带来了一个问题：如果内核数据需要耗时很久才能准备好，那么用户进程将被阻塞，浪费性能。为了提升应用的性能，虽然可以通过多线程来提升性能，但线程的创建依然会借助系统调用，同时多线程会导致频繁的线程上下文的切换，同样会影响性能。所以要想解决BIO带来的问题，我们就得看到问题的本质，那就是<strong>阻塞</strong>二字。</p>
<h1 id="4-IO-模型之非阻塞I-O-NIO"><a href="#4-IO-模型之非阻塞I-O-NIO" class="headerlink" title="4. IO 模型之非阻塞I/O(NIO)"></a>4. IO 模型之非阻塞I/O(NIO)</h1><p>那解决方案自然也容易想到，将阻塞变为非阻塞，那就是用户进程在发起系统调用时指定为非阻塞，内核接收到请求后，就会立即返回，然后用户进程通过轮询的方式来拉取处理结果。也就是如下图所示：</p>
<p><img src="/images/how-much-you-know-about-the-io-models/2799767-bd1dc37ed4733004.png" alt="NIO"></p>
<p>应用程序中进程在发起IO调用后至内核执行IO操作返回结果之前，若发起系统调用的线程不会等待而是立即返回，则此次IO操作为非阻塞IO模型。非阻塞IO简称NIO，Non-Blocking IO。</p>
<p>然而，非阻塞IO虽然相对于阻塞IO大幅提升了性能，但依旧不是完美的解决方案，其依然存在性能问题，也就是频繁的轮询导致频繁的系统调用，会耗费大量的CPU资源。比如当并发很高时，假设有1000个并发，那么单位时间循环内将会有1000次系统调用去轮询执行结果，而实际上可能只有2个请求结果执行完毕，这就会有998次无效的系统调用，造成严重的性能浪费。有问题就要解决，那<strong>NIO问题的本质就是频繁轮询导致的无效系统调用</strong>。</p>
<h1 id="5-IO模型之IO多路复用"><a href="#5-IO模型之IO多路复用" class="headerlink" title="5. IO模型之IO多路复用"></a>5. IO模型之IO多路复用</h1><p>解决NIO的思路就是降解无效的系统调用，如何降解呢？我们一起来看看以下几种IO多路复用的解决思路。</p>
<h2 id="5-1-IO多路复用之select-poll"><a href="#5-1-IO多路复用之select-poll" class="headerlink" title="5.1. IO多路复用之select/poll"></a>5.1. IO多路复用之select/poll</h2><p>Select是内核提供的系统调用，它支持一次查询多个系统调用的可用状态，当任意一个结果状态可用时就会返回，用户进程再发起一次系统调用进行数据读取。换句话说，就是NIO中N次的系统调用，借助Select，只需要发起一次系统调用就够了。其IO流程如下所示：<br><img src="/images/how-much-you-know-about-the-io-models/2799767-48611e945482d71b.png" alt="I/O Multiplexing"></p>
<p>但是，select有一个限制，就是存在连接数限制，针对于此，又提出了poll。其与select相比，主要是解决了连接限制。</p>
<p>select/epoll 虽然解决了NIO重复无效系统调用用的问题，但同时又引入了新的问题。问题是：</p>
<ol>
<li>用户空间和内核空间之间，大量的数据拷贝</li>
<li>内核循环遍历IO状态，浪费CPU时间</li>
</ol>
<p>换句话说，select/poll虽然减少了用户进程的发起的系统调用，但内核的工作量只增不减。在高并发的情况下，内核的性能问题依旧。所以select/poll的问题本质是：内核存在无效的循环遍历。</p>
<h2 id="5-2-IO多路复用之epoll"><a href="#5-2-IO多路复用之epoll" class="headerlink" title="5.2. IO多路复用之epoll"></a>5.2. IO多路复用之epoll</h2><p>针对select/pool引入的问题，我们把解决问题的思路转回到内核上，如何减少内核重复无效的循环遍历呢？变主动为被动，基于事件驱动来实现。其流程图如下所示：</p>
<p><img src="/images/how-much-you-know-about-the-io-models/2799767-7732b124e1fec05b.png" alt="epoll"></p>
<p>epoll相较于select/poll，多了两次系统调用，其中epoll_create建立与内核的连接，epoll_ctl注册事件，epoll_wait阻塞用户进程，等待IO事件。</p>
<p><img src="/images/how-much-you-know-about-the-io-models/2799767-dd1831740358d111.png" alt="select,poll,epoll"></p>
<p>epoll，已经大大优化了IO的执行效率，但在IO执行的第一阶段：数据准备阶段都还是被阻塞的。所以这是一个可以继续优化的点。</p>
<h1 id="6-IO-模型之信号驱动IO-SIGIO"><a href="#6-IO-模型之信号驱动IO-SIGIO" class="headerlink" title="6. IO 模型之信号驱动IO(SIGIO)"></a>6. IO 模型之信号驱动IO(SIGIO)</h1><p>信号驱动IO与BIO和NIO最大的区别就在于，在IO执行的数据准备阶段，不会阻塞用户进程。<br>如下图所示：当用户进程需要等待数据的时候，会向内核发送一个信号，告诉内核我要什么数据，然后用户进程就继续做别的事情去了，而当内核中的数据准备好之后，内核立马发给用户进程一个信号，说”数据准备好了，快来查收“，用户进程收到信号之后，立马调用recvfrom，去查收数据。</p>
<p><img src="/images/how-much-you-know-about-the-io-models/2799767-dcc2492e5d47920b.png" alt="SIGIO"></p>
<p>乍一看，信号驱动式I/O模型有种异步操作的感觉，但是在IO执行的第二阶段，也就是将数据从内核空间复制到用户空间这个阶段，用户进程还是被阻塞的。</p>
<p>综上，你会发现，不管是BIO还是NIO还是SIGIO，它们最终都会被阻塞在IO执行的第二阶段。<br>那如果能将IO执行的第二阶段变成非阻塞，那就完美了。</p>
<h1 id="7-IO-模型之异步IO-AIO"><a href="#7-IO-模型之异步IO-AIO" class="headerlink" title="7. IO 模型之异步IO(AIO)"></a>7. IO 模型之异步IO(AIO)</h1><p>异步IO真正实现了IO全流程的非阻塞。用户进程发出系统调用后立即返回，内核等待数据准备完成，然后将数据拷贝到用户进程缓冲区，然后发送信号告诉用户进程<strong>IO操作执行完毕</strong>（与SIGIO相比，一个是发送信号告诉用户进程数据准备完毕，一个是IO执行完毕）。其流程如下：<br><img src="/images/how-much-you-know-about-the-io-models/2799767-5ad4ff656fac53d5.png" alt="AIO"></p>
<p>所以，之所以称为异步IO，取决于IO执行的第二阶段是否阻塞。因此前面讲的BIO，NIO和SIGIO均为同步IO。</p>
<p><img src="/images/how-much-you-know-about-the-io-models/2799767-b92b0e6f572ce8a5.png" alt=""></p>
<h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h1><p>梳理完这些IO模型后，之前一直处于懵懂状态的阻塞，非阻塞，同步异步IO，终于算是有个概念了。同时也纠正了自己一直以来的误解，所以一路走来，愈发觉得返璞归真的重要性，只有如此，才能在快速更迭的技术演进中，以不变应万变。</p>
<p><em>本片综合多方资料写就，难免纰漏，但只有写下来，才能得以指正。所以，烦请各位看官不吝赐教。</em></p>
<blockquote>
<p>参考资料：</p>
<ol>
<li><a href="https://www.jianshu.com/p/fa7bdc4f3de7" target="_blank" rel="noopener">程序员应该这样理解IO</a></li>
<li><a href="https://www.jianshu.com/p/511b9cffbdac" target="_blank" rel="noopener">IO复用模型同步，异步，阻塞，非阻塞及实例详解</a></li>
<li><a href="https://juejin.im/post/5ca4c044e51d4565372e47cf" target="_blank" rel="noopener">服务器网络编程之 IO 模型</a></li>
<li><a href="http://www.c-jump.com/CIS77/CPU/VonNeumann/lecture.html" target="_blank" rel="noopener">http://www.c-jump.com/CIS77/CPU/VonNeumann/lecture.html</a></li>
<li><a href="https://cllc.fun/2019/03/07/synchronous-asynchronous-io/" target="_blank" rel="noopener">同步I/O(阻塞I/O，非阻塞I/O)，异步I/O</a></li>
<li><a href="https://www.bilibili.com/video/BV11K4y1C7rm?p=2" target="_blank" rel="noopener">马士兵：权威讲解nio,epoll,多路复用</a></li>
<li><a href="https://blog.csdn.net/DLUTBruceZhang/article/details/9050467" target="_blank" rel="noopener">Linux 内核详解以及内核缓冲区技术</a></li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>I/O</tag>
        <tag>EPOLL</tag>
      </tags>
  </entry>
  <entry>
    <title>OAtuth2.0 知多少</title>
    <url>/post/how-much-you-know-about-the-oauth2-0/</url>
    <content><![CDATA[<p><img src="/images/how-much-you-know-about-the-oauth2-0/2799767-a43df1862b414722.png" alt=""></p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>周末逛简书，看了一篇写的极好的文章，点击大红心点赞，就直接给我跳转到登录界面了，原来点赞是需要登录的。</p>
<p><img src="/images/how-much-you-know-about-the-oauth2-0/2799767-264c5378f5c255b1.png" alt="简书登录界面"></p>
<p>可是没有我并没有简书账号，一直使用的QQ的集成登录。下面有一排社交登录按钮，我们可以用第三方社交账号登陆即可。点击QQ图标，就给我跳转到了QQ登录授权页面，如下图：</p>
<p><img src="/images/how-much-you-know-about-the-oauth2-0/2799767-54cf4032678fe331.png" alt="QQ登录授权页面"></p>
<p>从图片上我们可以看到主要包括两个部分，一个是左边的用户登录，一个是右边告知简书将获取哪些权限。输入QQ账号和密码，点击授权并登录，就成功登录到简书了，并成功获取到了我QQ的账号和昵称，如下图：</p>
<p><img src="/images/how-much-you-know-about-the-oauth2-0/2799767-bce90f200d70a514.png" alt="简书成功获取到QQ昵称和头像"></p>
<p>简书集成的社交登录，大大简化了我们的注册登录流程，真是一号在手上网无忧啊。<br>这看似简单的集成，但背后的技术原理『OAuth2.0』可没那么简单，那我们废话不多说，一探究竟吧。</p>
<h1 id="2-OAuth-2-0"><a href="#2-OAuth-2-0" class="headerlink" title="2. OAuth 2.0"></a>2. OAuth 2.0</h1><blockquote>
<p><a href="https://oauth.net/2/" target="_blank" rel="noopener">OAuth 2.0</a>是用于授权的行业标准协议。OAuth 2.0取代了在2006年创建的原始OAuth协议上所做的工作。OAuth 2.0专注于客户端开发人员的简单性，同时为Web应用程序，桌面应用程序，手机和客厅设备提供特定的授权流程。</p>
</blockquote>
<p>在传统的client-server认证模型中，客户端请求访问服务器上受限的资源（protected resource），需要通过使用资源所有者（resource owner）的凭证在服务器上进行认证。为了支持第三方应用程序访问受限资源，资源所有者需要向第三方应用共享其凭证。这就会造成以下问题：</p>
<ol>
<li>第三方应用为了后续使用，会存储资源所有者的凭证主要是密码。</li>
<li>服务端需要支持密码认证，尽管密码认证不安全。</li>
<li>第三方应用获得对资源的过度访问而不仅局限于受限资源，且资源所有者没有办法对其进行限制。</li>
<li>资源所有者无法收回权限，除非修改密码。</li>
<li>如果第三方应用的密码被破解，就会导致所有被该密码保护的数据被泄露。</li>
</ol>
<p>想一想这样一个场景，如果简书是直接使用QQ用户名密码登录，简书就很有可能会为了后续业务的需要而擅自保存QQ用户名及密码，简书只要拿到了QQ用户名密码就可以访问不仅仅QQ昵称、头像等信息，甚至可以获取到QQ用户的所有通讯录列表。如果简书的账号密码泄露，就会直接影响到QQ数据的安全。这是一个可怕的问题。</p>
<p>所以OAuth应运而生，来解决这一问题。</p>
<h1 id="3-OAuth-2-0授权流程"><a href="#3-OAuth-2-0授权流程" class="headerlink" title="3. OAuth 2.0授权流程"></a>3. OAuth 2.0授权流程</h1><p>下面我们就以简书使用QQ授权登录为例，来捋一捋OAuth 2.0的流程。<br>先来看看OAuth 2.0的流程，如下图所示：<br><img src="/images/how-much-you-know-about-the-oauth2-0/2799767-27b3e30b6563dc2f.png" alt="OAuth 2.0授权流程"></p>
<p>这里面主要包含四个角色：</p>
<ol>
<li>Client：需要授权的客户端，本文中就是【简书】。</li>
<li>Resource Owner：资源所有者，在本文中你可能会以为是 QQ，但要想清楚，QQ是属于个人的，所以在本文中资源所有者是指【QQ用户】。</li>
<li>Authorization Server：认证服务器，本文中特指【QQ互联平台】。</li>
<li>Resource Server：资源服务器，顾名思义，用来专门保存资源的服务器，接受通过访问令牌进行访问。本文特指【QQ用户信息中心】。</li>
</ol>
<h2 id="3-1-第一步：引导用户到认证服务器"><a href="#3-1-第一步：引导用户到认证服务器" class="headerlink" title="3.1. 第一步：引导用户到认证服务器"></a>3.1. 第一步：引导用户到认证服务器</h2><p>圣杰打开简书网页，简书跳转到登录界面，要求用户登录。可是圣杰未在简书注册帐号，所以就点击了QQ图标，使用QQ帐号进行集成登录。跳转到QQ登录界面后，QQ要求用户授权。<br>这一步中简书主要做了这样一件事就是引导用户到认证服务器。<br>很显然【QQ互联平台】就是认证服务器。</p>
<p>如何引导？当然是页面跳转。<br>那认证服务器如何知道是简书过来的认证请求？<br>当然是传参。<br>那需要传递哪些参数呢？</p>
<ul>
<li>response_type：表示响应类型，必选项，此处的值固定为”code”；</li>
<li>client_id：表示客户端的ID，用来标志授权请求的来源，必选项；</li>
<li>redirect_uri：成功授权后的回调地址；</li>
<li>scope：表示申请的权限范围，可选项；</li>
<li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li>
</ul>
<p>咱们看看简书实际发送的授权请求Url是：<br><code>https://graph.qq.com/oauth2.0/authorize?client_id=100410602
&amp;redirect_uri=http://www.jianshu.com/users/auth/qq_connect/callback
&amp;response_type=code
&amp;state=bb38108d1aaf567c72da0f1167e87142d0e20cb2bb24ec5a</code></p>
<p>无图无真相，咱们看看控制台的网络监控：</p>
<p><img src="/images/how-much-you-know-about-the-oauth2-0/2799767-b7dab004998d702d.png" alt="简书跳转到QQ登录的认证请求"></p>
<p>如图所示，除了scope参数外，其他四个参数均有传参。<br>此时你可能唯一对state参数比较迷惑，传递一个state参数，认证服务器会原封不动返回，那还干嘛要传递state参数呢？</p>
<p>我的理解是，简书用一个guid加长版字符串来唯一标识一个授权请求。这样才会正确获取授权服务器返回的授权码。</p>
<p>这里你可能会问了，既然我知道了这些参数，我岂不是可以伪造简书认证请求，修改<code>redirect_uri</code>参数跳转到个人的网站，然后不就可以获取QQ授权？</p>
<p>跟我一样太傻太天真，简书在QQ互联平台申请时肯定已经预留备案了要跳转返回的URL。QQ互联平台在收到简书的授权请求时肯定会验证回调Url的。</p>
<h2 id="3-2-第二步：用户同意为第三方客户端授权"><a href="#3-2-第二步：用户同意为第三方客户端授权" class="headerlink" title="3.2. 第二步：用户同意为第三方客户端授权"></a>3.2. 第二步：用户同意为第三方客户端授权</h2><p>这一步，对于用户来说，只需要使用资源所有者（QQ）的用户名密码登录，并同意授权即可。点击授权并登录后，授权服务器首先会post一个请求回服务器进行用户认证，认证通过后授权服务器会生成一个授权码，然后服务器根据授权请求的<code>redirect_uri</code>进行跳转，并返回授权码<code>code</code>和授权请求中传递的<code>state</code>。<br>这里要注意的是：<strong>授权码有一个短暂的时效</strong></p>
<p>无图无真相，咱们还是看一下控制台网络监控：</p>
<p><img src="/images/how-much-you-know-about-the-oauth2-0/2799767-2ad0271ee9af4618.png" alt="用户授权并登录"></p>
<p>从图中即可验证我们上面所说，最终跳转回简书的Url为：<br><code>http://www.jianshu.com/users/auth/qq_connect/callback?code=093B9307E38DC5A2C3AD147B150F2AB3
&amp;state=bb38108d1aaf567c72da0f1167e87142d0e20cb2bb24ec5a</code><br>和之前的授权请求URL进行对比，可以发现<code>redirect_uri</code>、<code>state</code>完全一致。<br>而<code>code=093B9307E38DC5A2C3AD147B150F2AB3</code>就是返回的授权码。</p>
<h2 id="3-3-第三步：使用授权码向认证服务器申请令牌"><a href="#3-3-第三步：使用授权码向认证服务器申请令牌" class="headerlink" title="3.3. 第三步：使用授权码向认证服务器申请令牌"></a>3.3. 第三步：使用授权码向认证服务器申请令牌</h2><p>从这一步开始，对于用户来说是察觉不到的。简书后台默默的在做后续的工作。</p>
<p>简书拿到QQ互联平台返回的授权码后，需要根据授权码再次向认证服务器申请令牌（access token）。<br>到这里有必要再理清两个概念：</p>
<ul>
<li>授权码（Authorization Code）：相当于授权服务器口头告诉简书，用户同意授权使用他的QQ登录简书了。</li>
<li>令牌（Access Token）：相当于临时身份证。</li>
</ul>
<p>那如何申请令牌呢？<br>简书需要后台发送一个get请求到认证服务器（QQ互联平台）。<br>那要携带哪些必要信息呢？<br>是的，要携带以下参数：</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为”authorization_code”，必选项；</li>
<li>client_id：表示从QQ互联平台申请到的客户端ID，用来标志请求的来源，必选项；</li>
<li>client_secret：这个是从QQ互联平台申请到的客户端认证密钥，机密信息十分重要，必选项；</li>
<li>redirect_uri：成功申请到令牌后的回调地址；</li>
<li>code：上一步申请到的授权码。</li>
</ul>
<p>根据以上信息我们可以模拟一个申请AccessToken的请求：<br><code>https://graph.qq.com/oauth2.0/token?client_id=100410602
&amp;client_secret=123456jianshu
&amp;redirect_uri=http://www.jianshu.com/users/auth/qq_connect/callback
&amp;grant_type=authorization_code
&amp;code=093B9307E38DC5A2C3AD147B150F2AB3</code></p>
<p>发送完该请求后，认证服务器验证通过后就会发放令牌，并跳转会简书，其中应该包含以下信息：</p>
<ul>
<li>access_token：令牌</li>
<li>expires_in：access token的有效期，单位为秒。</li>
<li>refresh_token：在授权自动续期步骤中，获取新的Access_Token时需要提供的参数。</li>
</ul>
<p>同样，我们可以模拟出一个返回的token：<br><code>http://www.jianshu.com/users/auth/qq_connect/callback?access_token=548ADF2D5E1C5E88H4JH15FKUN51F
&amp;expires_in=36000&amp;refresh_token=53AD68JH834HHJF9J349FJADF3</code></p>
<p>这个时候简书还有一件事情要做，就是把用户token写到cookie里，进行用户登录状态的维持。咱们还是打开控制器验证一下。</p>
<p><img src="/images/how-much-you-know-about-the-oauth2-0/2799767-714ba763cb80cd6e.png" alt="保存token到cookie"></p>
<p>从图中可以看出简书把用户token保存在名为<code>remember_user_token</code>的cookie里。<br>不用打cookie的歪主意了，肯定是加密了的。<br>可以尝试下手动把<code>remember_user_token</code>这条cookie删除，保证刷新界面后需要你重新登录简书。</p>
<h2 id="3-4-第四步：向资源服务器申请资源"><a href="#3-4-第四步：向资源服务器申请资源" class="headerlink" title="3.4. 第四步：向资源服务器申请资源"></a>3.4. 第四步：向资源服务器申请资源</h2><p>有了token，向资源服务器提供的资源接口发送一个get请求不就行了，资源服务器校验令牌无误，就会向简书返回资源（QQ用户信息）。</p>
<p>同样咱们也来模拟一个使用token请求QQ用户基本信息资源的URL：<br><code>https://graph.qq.com/user/get_user_info?client_id=100410602
&amp;qq=2098769873
&amp;access_token=548ADF2D5E1C5E88H4JH15FKUN51F</code></p>
<p>到这一步OAuth2.0的流程可以说是结束了，但是对于简书来说还有重要的事情要做。那就是：<br><strong>拿到token、reresh_token和用户数据这么重要的东西不存数据库傻呀？</strong></p>
<h2 id="3-5-第五步：令牌延期（刷新）"><a href="#3-5-第五步：令牌延期（刷新）" class="headerlink" title="3.5. 第五步：令牌延期（刷新）"></a>3.5. 第五步：令牌延期（刷新）</h2><p>你肯定对第四步返回的<code>refresh_token</code>比较好奇。<br>它是用来对令牌进行延期（刷新）的。为什么会有两种说法呢，因为可能认证服务器会重新生成一个令牌，也有可能<br>对过期的令牌进行延期。</p>
<p>比如说，QQ互联平台为了安全性考虑，返回的<code>access_token</code>是有时间限制的，假如用户某天不想授权了呢，总不能给了个<code>access_token</code>你几年后还能用吧。我们上面模拟返回的令牌有效期为10小时。10小时后，用户打开浏览器逛简书，浏览器中用户的token对应的cookie已过期。简书发现浏览器没有携带token信息过来，就明白token失效了，需要重新向认证平台申请授权。如果让用户再点击QQ进行登录授权，这明显用户体验不好。咋搞呢？<code>refresh_token</code>就派上了用场，可以直接跳过前面申请授权码的步骤，当发现token失效了，简书从浏览器携带的cookie中的sessionid找到存储在数据库中的<code>refresh_token</code>，然后再使用<code>refresh_token</code>进行token续期（刷新）。</p>
<p>那用refresh_token进行token续期需要怎么做呢？<br>同样需要向认证服务器发送一个get请求。<br>需要哪些参数？</p>
<ul>
<li>grant_type：表示授权类型，此处的值固定为”refresh_token”，必选项；</li>
<li>client_id：表示从QQ互联平台申请到的客户端ID，用来标志请求的来源，必选项；</li>
<li>client_secret：这个是从QQ互联平台申请到的客户端认证密钥，机密信息十分重要，必选项；</li>
<li>refresh_token：即申请令牌返回的refresh_token。</li>
</ul>
<p>根据上述信息，我们又可以模拟一个令牌刷新的URL：<br><code>https://graph.qq.com/oauth2.0/token?client_id=100410602
&amp;client_secret=123456jianshu
&amp;redirect_uri=http://www.jianshu.com/users/auth/qq_connect/callback
&amp;grant_type=refresh_token
&amp;refresh_token=53AD68JH834HHJF9J349FJADF3</code><br>那返回的结果呢?<br>和第四步返回的结果一样。</p>
<p>这里你可能又有疑问了，那既然每次进行令牌延期后都会重新返回一个<code>refresh_token</code>，那岂不是我可以使用<code>refresh_token</code>无限延期？<br>天真如我啊，<code>refresh_token</code>也是有过期时间的。而这个过期时间具体是由认证服务器决定的。<br>一般来说<code>refresh_token</code>的过期时间要大于<code>access_token</code>的过期时间。只有这样，<code>access_token</code>过期时，才可以使用<code>refresh_token</code>进行令牌延期（刷新）。</p>
<p>举个简单例子：<br>假设简书从QQ互联平台默认获取到的<code>access_token</code>的有效期是1天，<code>refresh_token</code>的有效期为一周。</p>
<p>用户今天使用QQ登录授权后，过了两天再去逛简书，简书发现token失效，立马用<code>refresh_token</code>刷新令牌，默默的完成了授权的延期。<br>假如用户隔了两周再去逛简书，简书一核对，<code>access_token</code>、<code>refresh_token</code>全都失效，就只能乖乖引导用户到授权页面重新授权，也就是回到OAuth2.0的第一步。</p>
<h1 id="4-0-总结"><a href="#4-0-总结" class="headerlink" title="4.0 总结"></a>4.0 总结</h1><p>本文以简书通过QQ进行授权登录为例，对OAuth2.0 的授权流程进行了梳理，希望通读此文，对你有所帮助。</p>
<p>如果对OAuth2.0有所了解的话，你应该明白本文其实是对OAuth2.0中<strong>授权码模式</strong>授权方式的讲解。</p>
<p>如果想了解OAuth2.0其他几种授权方式，建议参考<a href="http://www.baidu.com/link?url=j4_T_fCI4T_gWL2Snyg_xg9DfuYvjKupGPbyr6HnHRJRlpEFAUMPaIEUgszkDxfKUbf_r-dRmYYaFXm13C-BEK" target="_blank" rel="noopener">理解<em>OAuth 2.0</em> - 阮一峰的网络日志</a>。</p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>OAuth2.0</tag>
      </tags>
  </entry>
  <entry>
    <title>Orleans 知多少 | .NET分布式框架</title>
    <url>/post/how-much-you-know-about-the-orleans/</url>
    <content><![CDATA[<p><img src="/images/how-much-you-know-about-the-orleans/2799767-ff59ad0a7485aa58.png" alt=""></p>
<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>公司物联网项目集成Orleans以支持高并发的分布式业务，对于Orleans也是第一次接触，本文就分享下个人对Orleans的理解。</p>
<p>这里先抛出自己的观点：<strong>Orleans 是一个支持有状态云生应用/服务水平伸缩的基于Virtual Actor 模型的.NET分布式框架。</strong></p>
<p>下面我会从以下几个关键点，进行阐述：</p>
<ol>
<li>云生应用的挑战</li>
<li>何为有状态/无状态</li>
<li>什么是 Actor 模型</li>
<li>什么是 Virtual Actor 模型</li>
</ol>
<h1 id="云生应用的挑战"><a href="#云生应用的挑战" class="headerlink" title="云生应用的挑战"></a>云生应用的挑战</h1><p>在讲云生应用之前，我们来先讲讲传统应用，对于传统应用常用的三层结构如下图所示。<br><img src="/images/how-much-you-know-about-the-orleans/2799767-48465d42659fe932.png" alt="传统应用三层结构"></p>
<p>随着业务的发展，数据库层通常存在瓶颈，为了缓解数据库的压力，一般会优先考虑增加一层缓存层。</p>
<p><img src="/images/how-much-you-know-about-the-orleans/2799767-4abc2a898285d382.png" alt="增加了缓存层的四层结构"></p>
<p>而随着业务的继续发展，高并发、大数据量的应用场景逐渐凸显。如果继续在单体应用的基础上进行扩展，能做的无非是增加消息队列、异步、读写分离等机制进行性能优化。总体而言，优化空间不大，但应用的整体复杂度却随着引入的新的技术框架而迅速增加，对于应用的维护，是一个潜在的定时炸弹。</p>
<p>这个时候你可能会想，既然单体应用单机部署不能满足需求，我可以做集群啊。通过将单体应用按照分层结构进行纵向分离，将数据库从应用服务器分离，将缓存从应用服务器分离。这样就可以对分离的各个部分进行分别部署，再借助负载均衡完成集群效应。到这一步，你的应用应该能撑一段时间了。</p>
<p>这个时候，如果回到业务本身去分析，对于一个复杂应用来说，通常的性能瓶颈就是几个核心服务上。如果能够对存在性能瓶颈的服务进行伸缩，既能大大提高应用的整体可用性又能提高资源的利用率。那怎么做呢？服务拆分。</p>
<p>云生应用就是服务拆分的结果，云生应用最大的特点就是：</p>
<ul>
<li><strong>并行</strong>：是指同一时刻能够处理多个任务。这无可厚非，云生应用以多个服务形式提供服务，自然是支持并行的。</li>
<li><strong>分布式</strong>：是指一个应用/服务多次部署，以应对高并发，提升应用/服务的整体性能。</li>
</ul>
<p>或者简单来说，云生应用通过服务拆分支持服务并行，同时各个服务能够快速伸缩以提升系统吞吐量来应对高并发的业务场景。</p>
<p>虽然通过服务拆分简化了整个应用的业务复杂度，但是实现的技术复杂度却只增不减。</p>
<h1 id="有状态-Vs-无状态"><a href="#有状态-Vs-无状态" class="headerlink" title="有状态 Vs 无状态"></a>有状态 Vs 无状态</h1><p>转向云生应用我们面对的第一个难题就是：<strong>如何进行服务拆分，才能确保其能分布式部署，或者说是水平伸缩？！</strong></p>
<p>有经验的同学，可能会立马想到，要将应用/服务设计为<strong>无状态</strong>的。但是这里我要向你讨教几个问题：</p>
<ol>
<li>这个状态是指什么？</li>
<li>何为有状态？</li>
<li>何为无状态？</li>
</ol>
<p>大家不妨先停下来思考一下。（欢迎大家在评论中阐述不同观点。）</p>
<p>这里，我尝试从以下两个角度来谈下自己的看法：</p>
<p><strong>1. 对象</strong></p>
<p>面向对象编程强调的是对现实事物的抽象和封装。通过对事物状态和行为进行抽象然后封装为对象（类），其中状态封装为类的属性、字段，将行为封装为类的方法。这个时候得到的对象是没有生命力的，因为它本质是一个抽象的结果。只有在程序运行中对类进行实例化得到一个对象的实例时，才可以说这个实例对象是有状态和行为的，因为这个状态和行为是其<strong>独自持有</strong>的，这是一个非常核心的条件。独自持有，换句话说，就是非共享成员。<br>独自持有非共享的成员就可以说这个对象实例是有状态的吗？<br>这里面你就要看清<strong>状态</strong>和<strong>有状态</strong>的区别！<br>举个简单例子，大街上你看到一大叔开着豪车，你觉得他很富有。“开着豪车”是你即时看到的状态属性。“富有”是你的状态断言。但这个状态断言是一个假设，毕竟可能是借的嘛。<br>怎样才能断定“富有”就是这位大叔拥有的状态呢？很简单，假设一年365天你天天见到他开豪车，那基本八九不离十了。</p>
<p><strong>所以，如果认定一个对象是否有状态，还要看其状态属性是否持久化！</strong></p>
<p>如果你同意这个观点，那么哪天你看我骑个共享单车，气喘吁吁从你面前经过，就不要简单认为我是苦逼工薪族。毕竟我也是身价上千万，只是偶尔骑个车锻炼锻炼。（身价上千万，昨晚梦到的。）</p>
<blockquote>
<p>所以，从对象角度看，一个对象是否有状态的充分必要条件是：</p>
<ol>
<li>对象已实例化（处于运行时）</li>
<li>拥有非共享的状态属性</li>
<li>状态持久化</li>
</ol>
</blockquote>
<p>那问题来了，我们经常写的类创建的实例，是有状态的吗？</p>
<p><strong>2. 应用</strong></p>
<p>基于上面的总结，我们再来从应用的角度来看分析这个问题。</p>
<p>那应用的状态和行为是什么？<br>首先，只有运行中的应用才有状态和行为。基于这个前提，个人理解运行时应用的状态是应用持有的数据，行为是应用提供的功能。<strong>那应用的有无/无状态界定就要看运行时应用持有的数据能否持久化。</strong></p>
<p>以简单的Web分层应用举例 。从逻辑架构上来讲应用一般分为三层，表示层、业务层和数据访问层。上层进行状态行为的封装，数据层提供数据的持久化。所以从整体的角度来看，其是一个有状态的应用。但单独来看，我们不能对每一层进行有/无状态的界定。第一，每一层不能单独运行；第二，分层的目的是为了职责的隔离，每一层负责相应职责的抽象和封装，其输出的是类文件，是对象的集合，没有生命力。</p>
<p>那从物理架构上来讲，Web应用可以分开两个部分进行部署：Web实例和MySQL实例。也就是说应用和数据库是可以分开部署的。这个时候Web实例就是无状态的。那我们一般常说的无状态服务其实是就是从这个拆分的角度来说的。</p>
<h1 id="Actor-模型"><a href="#Actor-模型" class="headerlink" title="Actor 模型"></a>Actor 模型</h1><p>理清完服务拆分的核心问题后，我们不得不来处理第二个棘手的问题：<strong>如何解决云生应用高并发的应用场景呢？</strong><br>那首先我们需要明确处理高并发的难点在哪？第一个是高性能，第二个就是：资源竞争导致的数据一致性问题。对于第一个难点，通过水平扩展服务可以化解；对于第二个难点，一般就是采用锁机制，而对于云生分布式的应用场景下，处理手段就更加复杂，可能需要使用分布式锁，而这种做法，大大降低了应用的整体响应性能。那有没有更好的解决方案，既兼顾性能又可以确保数据一致性呢？</p>
<p>有，借助Actor模型。</p>
<p>简单来讲：<strong>Actor模型 = 状态 + 行为 + 消息</strong>。一个应用/服务由多个Actor组成，每个Actor都是一个独立的运行单元，拥有隔离的运行空间，在隔离的空间内，其有独立的状态和行为，不被外界干预，Actor之间通过消息进行交互，而同一时刻，每个Actor只能被单个线程执行，这样既有效避免了数据共享和并发问题，又确保了应用的伸缩性。</p>
<p>另外Actor基于事件驱动模型进行异步通信，性能良好。且位置透明，无论Actor是在本机亦或是在集群中的其他机器，都可以直接进行透明调用。</p>
<p>因此Actor模型赋予了应用/服务的生命力（有状态）、高并发的处理能力和弹性伸缩能力。</p>
<p><img src="/images/how-much-you-know-about-the-orleans/2799767-001b915c61c84cb0.png" alt="Actor模型"></p>
<h1 id="Virtual-Actor-模型-与-Orleans"><a href="#Virtual-Actor-模型-与-Orleans" class="headerlink" title="Virtual Actor 模型 与 Orleans"></a>Virtual Actor 模型 与 Orleans</h1><p>对于Actor模型，业界已经有系列的实现框架，比如Erlang、Akka。然而Actor模型作为一个偏底层的技术框架，对于开发者来说，需要有一定分布式应用的开发经验，才能用好Actor（包括Actor的生命周期管理，状态管理等等）。为了进一步简化分布式编程，微软的研究人员引入了 Virtual Actor 模型概念，简单来讲Virtual Actor模型是对Actor模型的进一步封装和抽象。<br>其与Actor模型的最大的区别在于，Actor的物理实例完全被抽象出来，并由Virtual Actor所在的运行时自动管理。</p>
<p>Orleans 就是作为一款面向.NET的Virtual Actor模型的实现框架，提供了开发者友好的编程方式，简化了分布式应用的开发成本。<strong>在Orleans中Virtual Actor由Grain来体现。</strong></p>
<p>Orleans中核心优势：开发效率高、透明可伸缩。</p>
<p>开发效率高具体表现为：</p>
<ol>
<li>面向对象的编程范式去实现Grain</li>
<li>Grain单线程执行</li>
<li>Grain透明实例化：换句话说，应用无需关注Actor实例的创建、销毁，可以直接调用Actor提供的方法。Actor的生命周期由Virtual Actor 运行时进行管理，类似GC，可以把Actor理解为完全托管的状态。</li>
<li>Grain位置透明：Actor之间通过持有彼此的逻辑引用（非实例引用）进行相互调用，而不需要知道Actor所处的实际位置。</li>
<li>Grain状态透明存储</li>
<li>异常的自动传播</li>
</ol>
<p>透明可伸缩体现为：</p>
<ol>
<li>应用状态的隐式细粒度划分</li>
<li>自适应的资源管理：Grain的生命周期完全由Orleans 运行时托管。</li>
<li>多路通信：Grain的位置透明，Grain之间通过一组固定的TCP链接进行多路复用来进行消息传递。</li>
<li>高效调度</li>
<li>显式异步</li>
</ol>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>这篇文章，就简单写到这里，对于Orleans的详细介绍后续会结合实际项目输出更系统的应用细节，下次再见。</p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>Orleans</tag>
        <tag>Distributed .NET</tag>
        <tag>Actor Model</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化知多少</title>
    <url>/post/how-much-you-know-about-the-performance-optimization/</url>
    <content><![CDATA[<p><img src="/images/how-much-you-know-about-the-performance-optimization/2799767-9372ac4442777015.png" alt=""></p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><p>最近一段时间，系统新版本要发布，在beta客户测试期间，暴露了很多问题，除了一些业务和异常问题外，其他都集中在性能上。有幸接触到这些性能调优的机会，当然要学习总结了。</p>
<p>性能优化是一个老生常谈的问题了，典型的性能问题如页面响应慢、接口超时，服务器负载高、并发数低，数据库频繁死锁等。而造成性能问题又有很多种，比如磁盘I/O、内存、网络、算法、大数据量等等。我们可以大致把性能问题分为四个层次：代码层次、数据库层次、算法层次、架构层次。<br>所以下面我会结合实际性能优化案例，和大家分享下性能调优的工具、方法和技巧。</p>
<h1 id="2-先说心态"><a href="#2-先说心态" class="headerlink" title="2. 先说心态"></a>2. 先说心态</h1><p>说到性能问题，你可能首先就想到的是麻烦或者头大，因为一般性能问题都比较紧急，轻则影响客户体验，重则宕机导致财务损失，而且性能问题比较隐蔽，不易发现。因此一时间无从下手，而这时我们就很容易从心底开始去排斥它，不愿接这烫手的山芋。</p>
<p>而恰巧，性能调优是体现程序员水平的一个重要指标。</p>
<blockquote>
<p>因为处理bug、崩溃、调优、入侵等突发事件比编程本身更能体现平庸程序员与理想程序员的差距。当面对一个未知的问题时，如何定位复杂条件下的核心问题、如何抽丝剥茧地分析问题的潜在原因、如何排除干扰还原一个最小的可验证场景、如何抓住关键数据验证自己的猜测与实验，都是体现程序员思考力的最好场景。是的，在衡量理想程序员的标准上，思考力比经验更加重要。</p>
</blockquote>
<p>所以，若你不甘平庸，请拥抱性能调优的每一个机会。当你拥有一个正确的心态，你所面对的性能问题就已经解决了一半。</p>
<h1 id="3-再说技巧"><a href="#3-再说技巧" class="headerlink" title="3. 再说技巧"></a>3. 再说技巧</h1><p>拿到一个性能问题，不要忙着先上工具，先了解问题出现的背景，问题的严重程度。然后大致根据自己的经验积累作出预估。比如客户来了个性能问题说系统宕机了，已经造成资金损失了。这种涉及到钱的问题，大家都比较敏感，根据自己的level，决定是否要接这个锅。这不是逃避，而是自知之明。</p>
<p>了解问题背景之后，下一步就来尝试问题重现。如果在测试环境能够重现，那这种问题就很好跟踪分析。如果问题不能稳定重现或仅能在生产环境重现，那问题就相对比较棘手，这时要立刻收集现场证据，包括但不限于抓dump、收集应用程序以及系统日志、关注CPU内存情况、数据库备份等等，之后不妨再尝试重现，比如恢复客户数据库到测试环境重现。</p>
<p>不管问题能否重现，下一步，我们就要大致对问题进行分类，是代码层次的业务逻辑问题还是数据库层次的操作耗时问题，又或是系统架构的吞吐量问题。那如何确定呢？而我倾向于先从数据库动手。我的习惯做法是，使用数据库监控工具，先跟踪下Sql耗时情况。如果监控到耗时较长的SQL语句，那基本上就是数据库层次的问题，否则就是代码层次。若为代码层次，再研究完代码后，再细化为算法或架构层次问题。</p>
<p>确定问题种类后，是时候上工具来精准定位问题点了：</p>
<ul>
<li>Sql耗时问题，推荐使用免费的<a href="https://www.sentryone.com/plan-explorer" target="_blank" rel="noopener">Plan Explorer </a>分析执行计划。</li>
<li>代码问题定位，优先推荐使用VS自带的Performance Analysis，其次是RedGate的性能分析套件<a href="http://www.red-gate.com/products/dotnet-development/dotnet-developer-bundle/" target="_blank" rel="noopener">.NET Developer Bundle</a>；然后还有Jet Brains的<a href="http://www.jetbrains.com/profiler/?fromMenu" target="_blank" rel="noopener">dotTrace – .NET performance profiler</a>，<a href="http://www.jetbrains.com/dotmemory/?fromMenu" target="_blank" rel="noopener">dotMemory– .NET memory profiler</a>；再然后就是反人类的Windbg；等等。</li>
</ul>
<p>精准定位问题点后，就是着手优化了。相信到这一步，就是优化策略的选择了，这里就不展开了。</p>
<p>优化后，最后当然要进行测试了，毕竟优化了多少，我们也要做到心里有谱才行。</p>
<p>以上啰啰嗦嗦有点多，下面我们直接上案例。</p>
<h1 id="4-案例分享"><a href="#4-案例分享" class="headerlink" title="4. 案例分享"></a>4. 案例分享</h1><p>下面就分享下我针对代码层面、数据库层面和算法层面的优化案例。</p>
<h2 id="4-1-SQL优化案例"><a href="#4-1-SQL优化案例" class="headerlink" title="4.1. SQL优化案例"></a>4.1. SQL优化案例</h2><blockquote>
<p>案例1：客户反馈某结算报表统计十天内的数据耗时10mins左右。</p>
</blockquote>
<p>由于前几天刚学会用RedGate的分析工具，拿到这个问题，本地尝试重现后，就直接想使用工具分析。然而，这工具在使用webdev模式起站点时，总是报错，而当时时一根筋，老是想解决这个工具的报错问题。结果，白白搞了半天也没搞定。最后不得已放弃工具，转而选择使用sql server profiler去监控sql语句耗时。一跟踪不要紧，问题就直接暴露了，整个全屏的重复sql语句，如下图。</p>
<p><img src="/images/how-much-you-know-about-the-performance-optimization/2799767-f2779b1cef7ffb3f.png" alt="Sql Profiler监控结果"></p>
<p>这下问题就很明显了，八成是代码在循环拼接sql执行语句。根据抓取到sql关键字往代码中去搜索，果然如此。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#region更新三张表数据结合的中间临时表数据，有上游单据的直接调拨单分多次下推时，只计算一次的调拨数量和价税合计</span><br><span class="line">string sSql &#x3D; string.Format(@</span><br><span class="line">&quot;SELECT FENTRYID FROM &#123;0&#125; GROUP BY FENTRYID HAVING COUNT(FENTRYID) &gt; 1&quot;, sJoinDataTempTable);</span><br><span class="line">using(IDataReader reader &#x3D; DBUtils.ExecuteReader(this.Context, sSql)) &#123;</span><br><span class="line">    while (reader.Read()) &#123;</span><br><span class="line">        sbSql.AppendFormat(@&quot;</span><br><span class="line">UPDATE &#123;0&#125; SET FDIRECTQTY &#x3D; 0,FALLAMOUNT &#x3D; 0 </span><br><span class="line">WHERE FSEQ NOT IN (</span><br><span class="line">SELECT TOP 1 FSEQ FROM &#123;0&#125; WHERE FENTRYID &#x3D; &#123;1&#125;) AND FENTRYID &#x3D; (&#123;1&#125;);&quot;</span><br><span class="line">, sJoinDataTempTable, Convert.ToInt32(reader[&quot;FENTRYID&quot;]));</span><br><span class="line">        listSqlObj.Add(new SqlObject(sbSql.ToString(), new List &lt; SqlParam &gt; ()));</span><br><span class="line">        sbSql.Clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">#endregion</span><br></pre></td></tr></table></figure>

<p>看到这段代码，咱先不评判这段代码的优劣，因为毕竟代码注释清晰，省了我们理清业务的功夫。这段sql主要是想做去重处理，很显然选用了错误的方案。改后代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string sqlMerge &#x3D; string.Format(@&quot;</span><br><span class="line">merge into &#123;0&#125; t1</span><br><span class="line">using(</span><br><span class="line">select min(Fseq) fseq,Fentryid from &#123;0&#125; t2 group by fentryid</span><br><span class="line">) t3 on (t1.fentryid &#x3D; t3.fentryid and t1.fseq &lt;&gt; t3.fseq)</span><br><span class="line">when matched then</span><br><span class="line">update set t1.FDIRECTQTY &#x3D; 0, t1.FALLAMOUNT &#x3D; 0</span><br><span class="line">&quot;, sJoinDataTempTable);</span><br><span class="line"></span><br><span class="line">listSqlObj.Add(new SqlObject(sqlMerge, new List &lt; SqlParam &gt; ()));</span><br><span class="line">sbSql.Clear();</span><br></pre></td></tr></table></figure>

<p>改后测试相同数据量，耗时由10mins降到10s左右。</p>
<h2 id="4-2-代码优化案例"><a href="#4-2-代码优化案例" class="headerlink" title="4.2. 代码优化案例"></a>4.2. 代码优化案例</h2><blockquote>
<p>案例2：客户反馈销售订单100条分录行，保存进行可发量校验时，耗时7mins左右。</p>
</blockquote>
<p>拿到这个问题后，本地重现后，监控sql耗时没有异常，那就着重分析代码了。因为可发量校验的业务逻辑极其复杂，又加上又直接再一个类文件实现该功能，3500+行的代码，加上零星注释，真是让人避之不及。逃避不是办法，还是上工具分析一把。<br>这次我选用的时VS自带的<strong><a href="https://msdn.microsoft.com/en-us/library/ms182372.aspx" target="_blank" rel="noopener">Performance Profiler</a></strong>，开发环境下极其强大的性能调优工具。针对我们当前案例，我们仅需要跟踪指定服务对应的dll即可，使用步骤如下：</p>
<ol>
<li>Analyze–&gt;Profiler–&gt;New Performance Session</li>
<li>打开Performance Explorer</li>
<li>找到新添加的Performance Session，右键Targets，然后选择Add Target Binary，添加要跟踪的dll文件即可</li>
<li>将应用跑起来</li>
<li>选中Performance Session，右键Attach对应进程即可跟踪分析性能了</li>
<li>在跟踪过程中，可随时暂停跟踪和停止跟踪</li>
</ol>
<p><img src="/images/how-much-you-know-about-the-performance-optimization/2799767-581bab6651172c90.png" alt="图示步骤"></p>
<p>跟踪结束后本案例跟踪到的采样结果如下图：</p>
<p><img src="/images/how-much-you-know-about-the-performance-optimization/2799767-9bd074f58fbe605e.png" alt="VS Performance Profiler分析报告"></p>
<p>同时Performance Profiler也给出了问题的建议，如下图：<br><img src="/images/how-much-you-know-about-the-performance-optimization/2799767-5e091191b829b7da.png" alt="VS Performance Profiler分析提示"></p>
<p>其中第1、4条大致说明程序I/O消耗大，第一代的GC上存在未及时释放的垃圾占比过高。而根据上图的采样结果，我们可以直接看出是由于再代码中频繁操作DataTable引起的性能瓶颈。走读代码发现的确如此，所有的数量统计都是在代码中循环遍历DataTable进行处理的。而最终的优化策略，就相当于一次大的重构，将所有代码中通过遍历DataTable的计算逻辑全部挪到SQL中去做。由于代码过多，就不再放出。</p>
<blockquote>
<p>案例3：客户反馈批量引入1000张订单，耗时40mins左右，且容易中断。</p>
</blockquote>
<p>同样，我们还是先尝试本地重现。经测试批量引入101张单据，就耗时5mins左右。下一步打开Sql监控工具也未发现耗时语句。但考虑到是批量导入操作，虽然单个耗时不多，但乘以100这个基数，就明显了。下面我们就使用RedGate的<a href="http://www.red-gate.com/products/dotnet-development/ants-performance-profiler/" target="_blank" rel="noopener">Ants Performance Profiler</a>跟踪一下。</p>
<p>该工具比较直观，可以同时监控代码和SQL执行情况。第一步，New Profiler Session，第二步进行设置，如下图。根据自己的应用程序类别，选择相应的跟踪方式。</p>
<p><img src="/images/how-much-you-know-about-the-performance-optimization/2799767-6401487a7995b6dc.png" alt="跟踪设置"></p>
<p>针对这个问题，我们跟踪到的调用堆栈和SQL耗时结果如下图：</p>
<p><img src="/images/how-much-you-know-about-the-performance-optimization/2799767-aa1da6373d8fdfc3.png" alt="调用堆栈监控结果"></p>
<p><img src="/images/how-much-you-know-about-the-performance-optimization/2799767-93679e720a28eeb3.png" alt="SQL监控结果"></p>
<p>首先从调用堆栈中的Hit Count，我们可以首先看出它是一个批量过程，因为入口函数仅调用一次；第二个我们可以代码中是循环处理每一个单据，因为Hit Count与我们批量引入的单据数量相符；第三个，突然来了个10201，如果有一定的数字敏感性的话，这次性能问题的原因就被你找到了。这里就不卖关子了，101 x 101 = 10201。<br>是不是明白了什么，存在循环嵌套循环的情况。我们走读代码确定一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Save.cs</span><br><span class="line">public override void EndOperationTransaction(EndOperationTransactionArgs e) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他代码</span><br><span class="line">    foreach(DynamicObject dyItem in e.DataEntitys) &#123;</span><br><span class="line">        &#x2F;&#x2F;反写收款单</span><br><span class="line">        WriteBackReceiveBill wb &#x3D; new WriteBackReceiveBill();</span><br><span class="line">        wb.WriteBackForSave(e, this.Context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;WriteBackReceiveBill .cs</span><br><span class="line">public void WriteBackForSave(EndOperationTransactionArgs e, Context contx) &#123;</span><br><span class="line">    &#x2F;&#x2F;省略其他代码：</span><br><span class="line">    foreach(DynamicObject item in e.DataEntitys) &#123;</span><br><span class="line">        &#x2F;&#x2F;do something </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好嘛，外层套了一个空循环却什么也没做。修改就很简单了，删除无效外层循环即可。</p>
<h2 id="4-3-算法优化案例"><a href="#4-3-算法优化案例" class="headerlink" title="4.3. 算法优化案例"></a>4.3. 算法优化案例</h2><blockquote>
<p>案例4：某全流程跟踪报表超时。</p>
</blockquote>
<p>这个报表是用来跟踪所有单据从下单到出库的业务流程数据流转情况。而所有的流程数据都是按照树形结果存储在数据库表中的，类似这样：</p>
<p><img src="/images/how-much-you-know-about-the-performance-optimization/2799767-b0c94713af838e01.png" alt="流程树表"></p>
<p>图中的流程为：<br>销售合同–&gt;销售订单–&gt;发货通知单–&gt;销售出库单</p>
<p>为了构造流程图，之前的处理方法是把流程数据取回来，通过代码构造流程图。这也就是性能差的原因。</p>
<p>而针对这种情况，就是考验我们平时经验积累了。对于树形结构的表，我们也是可以通过SQL来进行直接查询的，这就要用到了SQL Server的CTE语法来进行递归查询。关于递归查询，可参考我这篇文章：<a href="http://www.jianshu.com/p/ab9d268aa54c" target="_blank" rel="noopener">SQL递归查询知多少</a>。这里就不展开了。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h1><p>性能调优是一个循序渐进的过程，不可能一蹴而就，重在平时的点滴积累。关于工具的选择和使用，本文并未展开，也希望读者也不要纠结与此。当你真正想解决一个问题的时候，相信工具的使用是难不住你的。</p>
<p>最后就大致总结下我的调优思路：</p>
<ol>
<li>调整心态，积极应对</li>
<li>了解性能背景， 收集证据， 尝试重现</li>
<li>问题分类，先监控SQL耗时，大致确定是SQL或是代码层次原因</li>
<li>使用性能分析工具，确定问题点</li>
<li>调优测试</li>
</ol>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>RabbitMQ 知多少</title>
    <url>/post/how-much-you-know-about-the-rabbitmq/</url>
    <content><![CDATA[<p><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-82c5402158929477.png" alt=""></p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1.引言"></a>1.引言</h1><p>RabbitMQ——Rabbit Message Queue的简写，但不能仅仅理解其为消息队列，消息代理更合适。RabbitMQ 是一个由 Erlang 语言开发的AMQP（高级消息队列协议）的开源实现，其内部结构如下：</p>
<p><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-05b3dc7216205c41.png" alt="RabbitMQ 内部结构"></p>
<p>RabbitMQ作为一个消息代理，主要和<strong>消息</strong>打交道，负责接收并转发消息。RabbitMQ提供了可靠的消息机制、跟踪机制和灵活的消息路由，支持消息集群和分布式部署。适用于排队算法、秒杀活动、消息分发、异步处理、数据同步、处理耗时任务、CQRS等应用场景。</p>
<p>下面我们就来学习下RabbitMQ。</p>
<h1 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h1><p>本文主要基于Windows下使用Vs Code 基于.net core进行demo演示。开始之前我们需要准备好以下环境。</p>
<ul>
<li>安装Erlang运行环境<br>下载安装<a href="http://www.erlang.org/downloads" target="_blank" rel="noopener">Erlang</a>。</li>
<li>安装RabbitMQ<br>下载安装Windows版本的<a href="http://www.rabbitmq.com/install-windows.html" target="_blank" rel="noopener">RabbitMQ</a>。</li>
<li>启动RabbitMQ Server<br>点击Windows开始按钮，输入RabbitMQ找到<code>RabbitMQ Comman Prompt</code>，以管理员身份运行。</li>
<li>依次执行以下命令启动RabbitMQ服务<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmq-service install</span><br><span class="line">rabbitmq-service enable</span><br><span class="line">rabbitmq-service start</span><br></pre></td></tr></table></figure></li>
<li>执行<code>rabbitmqlctl status</code>检查RabbitMQ状态</li>
<li>安装管理平台插件<br>执行<code>rabbitmq-plugins enable rabbitmq_management</code>即可成功安装，使用默认账号密码（guest/guest）登录<a href="http://localhost:15672/" target="_blank" rel="noopener">http://localhost:15672/</a>即可。</li>
</ul>
<h1 id="3-Hello-RabbitMQ"><a href="#3-Hello-RabbitMQ" class="headerlink" title="3. Hello RabbitMQ"></a>3. Hello RabbitMQ</h1><p>在开始之前我们先来了解下消息模型：<br><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-a5e45f97bec36c8a.png" alt="消息流"><br>消费者（consumer）订阅某个队列。生产者（producer）创建消息，然后发布到队列（queue）中，队列再将消息发送到监听的消费者。</p>
<p>下面我们我们通过demo来了解RabbitMQ的基本用法。</p>
<h2 id="3-1-消息的发送和接收"><a href="#3-1-消息的发送和接收" class="headerlink" title="3.1.消息的发送和接收"></a>3.1.消息的发送和接收</h2><p>创建RabbitMQ文件夹，打开命令提示符，分别创建两个控制台项目Send、Receive。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dotnet new console --name Send &#x2F;&#x2F;创建发送端控制台应用</span><br><span class="line">cd Send &#x2F;&#x2F;进入Send目录</span><br><span class="line">dotnet add package RabbitMQ.Client &#x2F;&#x2F;添加RabbitMQ.Client包</span><br><span class="line">dotnet restore &#x2F;&#x2F;恢复包</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dotnet new console --name Receive &#x2F;&#x2F;创建接收端控制台应用</span><br><span class="line">cd Receive &#x2F;&#x2F;进入Receive目录</span><br><span class="line">dotnet add package RabbitMQ.Client &#x2F;&#x2F;添加RabbitMQ.Client包</span><br><span class="line">dotnet restore &#x2F;&#x2F;恢复包</span><br></pre></td></tr></table></figure>
<p>我们先来添加消息发送端逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Send.cs </span><br><span class="line">public static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;1.1.实例化连接工厂</span><br><span class="line">    var factory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;localhost&quot; &#125;;</span><br><span class="line">    &#x2F;&#x2F;2. 建立连接</span><br><span class="line">    using (var connection &#x3D; factory.CreateConnection())</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;3. 创建信道</span><br><span class="line">        using (var channel &#x3D; connection.CreateModel())</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;4. 申明队列</span><br><span class="line">            channel.QueueDeclare(queue: &quot;hello&quot;, durable: false, exclusive: false, autoDelete: false, arguments: null);</span><br><span class="line">            &#x2F;&#x2F;5. 构建byte消息数据包</span><br><span class="line">            string message &#x3D; args.Length &gt; 0 ? args[0] : &quot;Hello RabbitMQ!&quot;;</span><br><span class="line">            var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line">            &#x2F;&#x2F;6. 发送数据包</span><br><span class="line">            channel.BasicPublish(exchange: &quot;&quot;, routingKey: &quot;hello&quot;, basicProperties: null, body: body);</span><br><span class="line">            Console.WriteLine(&quot; [x] Sent &#123;0&#125;&quot;, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再来完善消息接收端逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Receive.cs  省略部分代码</span><br><span class="line">public static void Main()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;1.实例化连接工厂</span><br><span class="line">    var factory &#x3D; new ConnectionFactory() &#123; HostName &#x3D; &quot;localhost&quot; &#125;;</span><br><span class="line">    &#x2F;&#x2F;2. 建立连接</span><br><span class="line">    using (var connection &#x3D; factory.CreateConnection())</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F;3. 创建信道</span><br><span class="line">        using (var channel &#x3D; connection.CreateModel())</span><br><span class="line">        &#123;</span><br><span class="line">            &#x2F;&#x2F;4. 申明队列</span><br><span class="line">            channel.QueueDeclare(queue: &quot;hello&quot;, durable: false, exclusive: false, autoDelete: false, arguments: null);</span><br><span class="line">            &#x2F;&#x2F;5. 构造消费者实例</span><br><span class="line">            var consumer &#x3D; new EventingBasicConsumer(channel);</span><br><span class="line">            &#x2F;&#x2F;6. 绑定消息接收后的事件委托</span><br><span class="line">            consumer.Received +&#x3D; (model, ea) &#x3D;&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                var message &#x3D; Encoding.UTF8.GetString(ea.Body);</span><br><span class="line">                Console.WriteLine(&quot; [x] Received &#123;0&#125;&quot;, message);</span><br><span class="line">                Thread.Sleep(6000);&#x2F;&#x2F;模拟耗时</span><br><span class="line">                Console.WriteLine (&quot; [x] Done&quot;);</span><br><span class="line">            &#125;;</span><br><span class="line">            &#x2F;&#x2F;7. 启动消费者</span><br><span class="line">            channel.BasicConsume(queue: &quot;hello&quot;, autoAck: true, consumer: consumer);</span><br><span class="line">            Console.WriteLine(&quot; Press [enter] to exit.&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先运行消息接收端，再运行消息发送端，结果如下图。</p>
<p><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-9079418f0a3f1ccd.png" alt="运行结果"></p>
<p>从上面的代码中可以看出，发送端和消费端的代码前4步都是一样的。主要的区别在于发送端调用<code>channel.BasicPublish</code>方法发送消息；而接收端需要实例化一个<code>EventingBasicConsumer</code>实例来进行消息处理逻辑。另外一点需要注意的是：消息接收端和发送端的队列名称（queue）必须保持一致，这里指定的队列名称为hello。</p>
<h2 id="3-2-循环调度"><a href="#3-2-循环调度" class="headerlink" title="3.2. 循环调度"></a>3.2. 循环调度</h2><p>使用工作队列的好处就是它能够并行的处理队列。如果堆积了很多任务，我们只需要添加更多的工作者（workers）就可以了。我们先启动两个接收端，等待消息接收，再启动一个发送端进行消息发送。</p>
<p><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-283ced13913a0aac.png" alt="消息分发"></p>
<p>我们增加运行一个消费端后的运行结果：</p>
<p><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-906a1ab86a7459d8.png" alt="循环调度"></p>
<p>从图中可知，我们循环发送4条信息，两个消息接收端按顺序被循环分配。<br>默认情况下，RabbitMQ将按顺序将每条消息发送给下一个消费者。平均每个消费者将获得相同数量的消息。这种分发消息的方式叫做循环（round-robin）。</p>
<h2 id="3-3-消息确认"><a href="#3-3-消息确认" class="headerlink" title="3.3. 消息确认"></a>3.3. 消息确认</h2><p>按照我们上面的demo，一旦RabbitMQ将消息发送到消费端，消息就会立即从内存中移出，无论消费端是否处理完成。在这种情况下，消息就会丢失。</p>
<p>为了确保一个消息永远不会丢失，RabbitMQ支持<strong>消息确认（message acknowledgments）</strong>。当消费端接收消息并且处理完成后，会发送一个ack（消息确认）信号到RabbitMQ，RabbitMQ接收到这个信号后，就可以删除掉这条已经处理的消息任务。但如果消费端挂掉了（比如，通道关闭、连接丢失等）没有发送ack信号。RabbitMQ就会明白某个消息没有正常处理，RabbitMQ将会重新将消息入队，如果有另外一个消费端在线，就会快速的重新发送到另外一个消费端。</p>
<p>RabbitMQ中没有消息超时的概念，只有当消费端关闭或奔溃时，RabbitMQ才会重新分发消息。</p>
<p>微调下Receive中的代码逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;5. 构造消费者实例</span><br><span class="line">var consumer &#x3D; new EventingBasicConsumer(channel);</span><br><span class="line">&#x2F;&#x2F;6. 绑定消息接收后的事件委托</span><br><span class="line">consumer.Received +&#x3D; (model, ea) &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var message &#x3D; Encoding.UTF8.GetString(ea.Body);</span><br><span class="line">    Console.WriteLine(&quot; [x] Received &#123;0&#125;&quot;, message);</span><br><span class="line">    Thread.Sleep(6000);&#x2F;&#x2F;模拟耗时</span><br><span class="line">    Console.WriteLine(&quot; [x] Done&quot;);</span><br><span class="line">    &#x2F;&#x2F; 7. 发送消息确认信号（手动消息确认）</span><br><span class="line">    channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: false);</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F;8. 启动消费者</span><br><span class="line">&#x2F;&#x2F;autoAck:true；自动进行消息确认，当消费端接收到消息后，就自动发送ack信号，不管消息是否正确处理完毕</span><br><span class="line">&#x2F;&#x2F;autoAck:false；关闭自动消息确认，通过调用BasicAck方法手动进行消息确认</span><br><span class="line">channel.BasicConsume(queue: &quot;hello&quot;, autoAck: false, consumer: consumer);</span><br></pre></td></tr></table></figure>

<p>主要改动的是将 <code>autoAck:true</code>修改为<code>autoAck:fasle</code>，以及在消息处理完毕后手动调用<code>BasicAck</code>方法进行手动消息确认。</p>
<p><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-d781dd054f6d2c77.png" alt=""></p>
<p>从图中可知，消息发送端连续发送4条消息，其中消费端1先被分配处理第一条消息，消费端2被循环分配第二条消息，第三条消息由于没有空闲消费者仍然在队列中。<br>在消费端2未处理完第一条消息之前，手动中断（ctrl+c）。我们可以发现RabbitMQ在下一次分发时，会优先将被中断的消息分发给消费端1处理。</p>
<h2 id="3-4-消息持久化"><a href="#3-4-消息持久化" class="headerlink" title="3.4. 消息持久化"></a>3.4. 消息持久化</h2><p>消息确认确保了即使消费端异常，消息也不会丢失能够被重新分发处理。但是如果RabbitMQ服务端异常，消息依然会丢失。除非我们指定<code>durable:true</code>，否则当RabbitMQ退出或奔溃时，消息将依然会丢失。通过指定<code>durable:true</code>，并指定<code>Persistent=true</code>，来告知RabbitMQ将消息持久化。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;send.cs</span><br><span class="line">&#x2F;&#x2F;4. 申明队列(指定durable:true,告知rabbitmq对消息进行持久化)</span><br><span class="line">channel.QueueDeclare(queue: &quot;hello&quot;, durable: true, exclusive: false, autoDelete: false, arguments</span><br><span class="line">&#x2F;&#x2F;将消息标记为持久性 - 将IBasicProperties.SetPersistent设置为true</span><br><span class="line">var properties &#x3D; channel.CreateBasicProperties();</span><br><span class="line">properties.Persistent &#x3D; true;</span><br><span class="line">&#x2F;&#x2F;5. 构建byte消息数据包</span><br><span class="line">string message &#x3D; args.Length &gt; 0 ? args[0] : &quot;Hello RabbitMQ!&quot;;</span><br><span class="line">var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line">&#x2F;&#x2F;6. 发送数据包(指定basicProperties)</span><br><span class="line">channel.BasicPublish(exchange: &quot;&quot;, routingKey: &quot;hello&quot;, basicProperties: properties, body: body);</span><br></pre></td></tr></table></figure>
<p>将消息标记为持久性不能完全保证消息不会丢失。虽然它告诉RabbitMQ将消息保存到磁盘，但是当RabbitMQ接受消息并且还没有保存时，仍然有一个很短的时间窗口。RabbitMQ 可能只是将消息保存到了缓存中，并没有将其写入到磁盘上。持久化是不能够一定保证的，但是对于一个简单任务队列来说已经足够。如果需要确保消息队列的持久化，可以使用<a href="https://www.rabbitmq.com/confirms.html" target="_blank" rel="noopener">publisher confirms</a>.</p>
<h2 id="3-5-公平分发"><a href="#3-5-公平分发" class="headerlink" title="3.5. 公平分发"></a>3.5. 公平分发</h2><p>RabbitMQ的消息分发默认按照消费端的数量，按顺序循环分发。这样仅是确保了消费端被平均分发消息的数量，但却忽略了消费端的闲忙情况。这就可能出现某个消费端一直处理耗时任务处于阻塞状态，某个消费端一直处理一般任务处于空置状态，而只是它们分配的任务数量一样。</p>
<p><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-d2bb1f2ac63fdb15.png" alt=""></p>
<p>但我们可以通过<code>channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);</code><br>设置<code>prefetchCount : 1</code>来告知RabbitMQ，在未收到消费端的消息确认时，不再分发消息，也就确保了当消费端处于忙碌状态时，不再分配任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Receive.cs</span><br><span class="line">&#x2F;&#x2F;4. 申明队列</span><br><span class="line">channel.QueueDeclare(queue: &quot;hello&quot;, durable: false, exclusive: false, autoDelete: false, arguments: null);</span><br><span class="line">&#x2F;&#x2F;设置prefetchCount : 1来告知RabbitMQ，在未收到消费端的消息确认时，不再分发消息，也就确保了当消费端处于忙碌状态时</span><br><span class="line">channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global: false);</span><br></pre></td></tr></table></figure>

<p>这时你需要注意的是如果所有的消费端都处于忙碌状态，你的队列可能会被塞满。你需要注意这一点，要么添加更多的消费端，要么采取其他策略。</p>
<h1 id="4-Exchange"><a href="#4-Exchange" class="headerlink" title="4. Exchange"></a>4. Exchange</h1><p>细心的你也许发现上面的demo，生产者和消费者直接是通过相同队列名称进行匹配衔接的。消费者订阅某个队列，生产者创建消息发布到队列中，队列再将消息转发到订阅的消费者。这样就会有一个局限性，即消费者一次只能发送消息到某一个队列。</p>
<p>那消费者如何才能发送消息到多个消息队列呢？<br>RabbitMQ提供了<strong>Exchange</strong>，它类似于路由器的功能，它用于对消息进行路由，将消息发送到多个队列上。Exchange一方面从生产者接收消息，另一方面将消息推送到队列。但exchange必须知道如何处理接收到的消息，是将其附加到特定队列还是附加到多个队列，还是直接忽略。而这些规则由exchange type定义，exchange的原理如下图所示。<br><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-0b4fba202e525745.png" alt="Exchange"></p>
<p>常见的exchange type 有以下几种：</p>
<ul>
<li>direct（明确的路由规则：消费端绑定的队列名称必须和消息发布时指定的路由名称一致）</li>
<li>topic （模式匹配的路由规则：支持通配符）</li>
<li>fanout （消息广播，将消息分发到exchange上绑定的所有队列上）</li>
</ul>
<p>下面我们就来一一这介绍它们的用法。</p>
<h2 id="4-1-fanout"><a href="#4-1-fanout" class="headerlink" title="4.1 fanout"></a>4.1 fanout</h2><p>本着先易后难的思想，我们先来了解下<strong>fanout</strong>的广播路由机制。fanout的路由机制如下图，即发送到 fanout 类型exchange的消息都会分发到所有绑定该exchange的队列上去。</p>
<p><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-3afd7b874221a9a2.png" alt="fanout 路由机制"></p>
<p>生产者示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成随机队列名称</span><br><span class="line">var queueName &#x3D; channel.QueueDeclare().QueueName;</span><br><span class="line">&#x2F;&#x2F;使用fanout exchange type，指定exchange名称</span><br><span class="line">channel.ExchangeDeclare(exchange: &quot;fanoutEC&quot;, type: &quot;fanout&quot;);</span><br><span class="line">var message &#x3D; &quot;Hello Rabbit!&quot;;</span><br><span class="line">var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line">&#x2F;&#x2F;发布到指定exchange，fanout类型无需指定routingKey</span><br><span class="line">channel.BasicPublish(exchange: &quot;fanoutEC&quot;, routingKey: &quot;&quot;, basicProperties: null, body: body);</span><br></pre></td></tr></table></figure>
<p>消费者示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;申明fanout类型exchange</span><br><span class="line">channel.ExchangeDeclare (exchange: &quot;fanoutEC&quot;, type: &quot;fanout&quot;);</span><br><span class="line">&#x2F;&#x2F;申明随机队列名称</span><br><span class="line">var queuename &#x3D; channel.QueueDeclare ().QueueName;</span><br><span class="line">&#x2F;&#x2F;绑定队列到指定fanout类型exchange，无需指定路由键</span><br><span class="line">channel.QueueBind (queue : queuename, exchange: &quot;fanoutEC&quot;, routingKey: &quot;&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="4-2-direct"><a href="#4-2-direct" class="headerlink" title="4.2. direct"></a>4.2. direct</h2><p>direct相对于fanout就属于完全匹配、单播的模式，路由机制如下图，即队列名称和消息发送时指定的路由完全匹配时，消息才会发送到指定队列上。<br><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-6c78ab57fe06c6ce.png" alt="direct路由机制"></p>
<p>生产者示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成随机队列名称</span><br><span class="line">var queueName &#x3D; channel.QueueDeclare().QueueName;</span><br><span class="line">&#x2F;&#x2F;使用direct exchange type，指定exchange名称</span><br><span class="line">channel.ExchangeDeclare(exchange: &quot;directEC&quot;, type: &quot;direct&quot;);</span><br><span class="line">var message &#x3D; &quot;Hello Rabbit!&quot;;</span><br><span class="line">var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line">&#x2F;&#x2F;发布到direct类型exchange，必须指定routingKey</span><br><span class="line">channel.BasicPublish(exchange: &quot;directEC&quot;, routingKey: &quot;green&quot;, basicProperties: null, body: body);</span><br></pre></td></tr></table></figure>
<p>消费者示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;申明direct类型exchange</span><br><span class="line">channel.ExchangeDeclare (exchange: &quot;directEC&quot;, type: &quot;direct&quot;);</span><br><span class="line">&#x2F;&#x2F;绑定队列到direct类型exchange，需指定路由键routingKey</span><br><span class="line">channel.QueueBind (queue : green, exchange: &quot;directEC&quot;, routingKey: &quot;green&quot;);</span><br></pre></td></tr></table></figure>

<h2 id="4-3-topic"><a href="#4-3-topic" class="headerlink" title="4.3. topic"></a>4.3. topic</h2><p>topic是direct的升级版，是一种模式匹配的路由机制。它支持使用两种通配符来进行模式匹配：符号<strong><code>#</code></strong>和符号<strong><code>*</code></strong>。其中<strong><code>*</code></strong>匹配一个单词， <strong><code>#</code></strong>则表示匹配0个或多个单词，单词之间用<strong><code>.</code></strong>分割。如下图所示。<br><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-3196a1c3880b3466.png" alt="topic路由机制"></p>
<p>生产者示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 生成随机队列名称</span><br><span class="line">var queueName &#x3D; channel.QueueDeclare().QueueName;</span><br><span class="line">&#x2F;&#x2F;使用topic exchange type，指定exchange名称</span><br><span class="line">channel.ExchangeDeclare(exchange: &quot;topicEC&quot;, type: &quot;topic&quot;);</span><br><span class="line">var message &#x3D; &quot;Hello Rabbit!&quot;;</span><br><span class="line">var body &#x3D; Encoding.UTF8.GetBytes(message);</span><br><span class="line">&#x2F;&#x2F;发布到topic类型exchange，必须指定routingKey</span><br><span class="line">channel.BasicPublish(exchange: &quot;topicEC&quot;, routingKey: &quot;first.green.fast&quot;, basicProperties: null, body: body);</span><br></pre></td></tr></table></figure>
<p>消费者示例代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;申明topic类型exchange</span><br><span class="line">channel.ExchangeDeclare (exchange: &quot;topicEC&quot;, type: &quot;topic&quot;);</span><br><span class="line">&#x2F;&#x2F;申明随机队列名称</span><br><span class="line">var queuename &#x3D; channel.QueueDeclare ().QueueName;</span><br><span class="line">&#x2F;&#x2F;绑定队列到topic类型exchange，需指定路由键routingKey</span><br><span class="line">channel.QueueBind (queue : queuename, exchange: &quot;topicEC&quot;, routingKey: &quot;#.*.fast&quot;);</span><br></pre></td></tr></table></figure>

<h1 id="5-RPC"><a href="#5-RPC" class="headerlink" title="5. RPC"></a>5. RPC</h1><p>RPC——Remote Procedure Call，远程过程调用。<br>那RabbitMQ如何进行远程调用呢？示意图如下：<br><img src="/images/how-much-you-know-about-the-rabbitmq/2799767-121e20f9b512c406.png" alt="RPC机制"><br>第一步，主要是进行远程调用的客户端需要指定接收远程回调的队列，并申明消费者监听此队列。<br>第二步，远程调用的服务端除了要申明消费端接收远程调用请求外，还要将结果发送到客户端用来监听回调结果的队列中去。</p>
<p>远程调用客户端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;申明唯一guid用来标识此次发送的远程调用请求</span><br><span class="line">var correlationId &#x3D; Guid.NewGuid().ToString();</span><br><span class="line">&#x2F;&#x2F;申明需要监听的回调队列</span><br><span class="line">var replyQueue &#x3D; channel.QueueDeclare().QueueName;</span><br><span class="line">var properties &#x3D; channel.CreateBasicProperties();</span><br><span class="line">properties.ReplyTo &#x3D; replyQueue;&#x2F;&#x2F;指定回调队列</span><br><span class="line">properties.CorrelationId &#x3D; correlationId;&#x2F;&#x2F;指定消息唯一标识</span><br><span class="line">string number &#x3D; args.Length &gt; 0 ? args[0] : &quot;30&quot;;</span><br><span class="line">var body &#x3D; Encoding.UTF8.GetBytes(number);</span><br><span class="line">&#x2F;&#x2F;发布消息</span><br><span class="line">channel.BasicPublish(exchange: &quot;&quot;, routingKey: &quot;rpc_queue&quot;, basicProperties: properties, body: body);</span><br><span class="line">Console.WriteLine($&quot;[*] Request fib(&#123;number&#125;)&quot;);</span><br><span class="line">&#x2F;&#x2F; &#x2F;&#x2F;创建消费者用于处理消息回调（远程调用返回结果）</span><br><span class="line">var callbackConsumer &#x3D; new EventingBasicConsumer(channel);</span><br><span class="line">channel.BasicConsume(queue: replyQueue, autoAck: true, consumer: callbackConsumer);</span><br><span class="line">callbackConsumer.Received +&#x3D; (model, ea) &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">     &#x2F;&#x2F;仅当消息回调的ID与发送的ID一致时，说明远程调用结果正确返回。</span><br><span class="line">    if (ea.BasicProperties.CorrelationId &#x3D;&#x3D; correlationId)</span><br><span class="line">    &#123;</span><br><span class="line">        var responseMsg &#x3D; $&quot;Get Response: &#123;Encoding.UTF8.GetString(ea.Body)&#125;&quot;;</span><br><span class="line">        Console.WriteLine($&quot;[x]: &#123;responseMsg&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>远程调用服务端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;申明队列接收远程调用请求</span><br><span class="line">channel.QueueDeclare(queue: &quot;rpc_queue&quot;, durable: false,</span><br><span class="line">    exclusive: false, autoDelete: false, arguments: null);</span><br><span class="line">var consumer &#x3D; new EventingBasicConsumer(channel);</span><br><span class="line">Console.WriteLine(&quot;[*] Waiting for message.&quot;);</span><br><span class="line">&#x2F;&#x2F;请求处理逻辑</span><br><span class="line">consumer.Received +&#x3D; (model, ea) &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var message &#x3D; Encoding.UTF8.GetString(ea.Body);</span><br><span class="line">    int n &#x3D; int.Parse(message);</span><br><span class="line">    Console.WriteLine($&quot;Receive request of Fib(&#123;n&#125;)&quot;);</span><br><span class="line">    int result &#x3D; Fib(n);</span><br><span class="line">    &#x2F;&#x2F;从请求的参数中获取请求的唯一标识，在消息回传时同样绑定</span><br><span class="line">    var properties &#x3D; ea.BasicProperties;</span><br><span class="line">    var replyProerties &#x3D; channel.CreateBasicProperties();</span><br><span class="line">    replyProerties.CorrelationId &#x3D; properties.CorrelationId;</span><br><span class="line">    &#x2F;&#x2F;将远程调用结果发送到客户端监听的队列上</span><br><span class="line">    channel.BasicPublish(exchange: &quot;&quot;, routingKey: properties.ReplyTo,</span><br><span class="line">        basicProperties: replyProerties, body: Encoding.UTF8.GetBytes(result.ToString()));</span><br><span class="line">    &#x2F;&#x2F;手动发回消息确认</span><br><span class="line">    channel.BasicAck(ea.DeliveryTag, false);</span><br><span class="line">    Console.WriteLine($&quot;Return result: Fib(&#123;n&#125;)&#x3D; &#123;result&#125;&quot;);</span><br><span class="line">&#125;;</span><br><span class="line">channel.BasicConsume(queue: &quot;rpc_queue&quot;, autoAck: false, consumer: consumer);</span><br></pre></td></tr></table></figure>

<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h1><p>基于上面的demo和对几种不同exchange路由机制的学习，我们发现RabbitMQ主要是涉及到以下几个核心概念：</p>
<ol>
<li>Publisher：生产者，消息的发送方。</li>
<li>Connection：网络连接。</li>
<li>Channel：信道，多路复用连接中的一条独立的双向数据流通道。</li>
<li>Exchange：交换器（路由器），负责消息的路由到相应队列。</li>
<li>Binding：队列与交换器间的关联绑定。消费者将关注的队列绑定到指定交换器上，以便Exchange能准确分发消息到指定队列。</li>
<li>Queue：队列，消息的缓冲存储区。</li>
<li>Virtual Host：虚拟主机，虚拟主机提供资源的逻辑分组和分离。包含连接，交换，队列，绑定，用户权限，策略等。</li>
<li>Broker：消息队列的服务器实体。</li>
<li>Consumer：消费者，消息的接收方。 </li>
</ol>
<p>这次作为入门就讲到这里，下次我们来讲解下<strong>EventBus + RabbitMQ</strong>如何实现事件的分发。</p>
<blockquote>
<p>参考资料：<br><a href="http://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">RabbitMQ Tutorials</a><br><a href="https://github.com/yanshengjie/RabbitMQ" target="_blank" rel="noopener">Demo路径——RabbitMQ</a></p>
</blockquote>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
        <tag>消息队列</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>反应式编程知多少 | Rx.NET了解下</title>
    <url>/post/how-much-you-know-about-the-reactive-programming-in-dotnet/</url>
    <content><![CDATA[<p><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-54048d974ab3962e.png" alt=""></p>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><blockquote>
<p>An API for asynchronous programming with observable streams.<br>ReactiveX is a combination of the best ideas from the <strong>Observer</strong> pattern, the <strong>Iterator</strong> pattern, and <strong>functional programming</strong>.<br><em>ReactiveX 使用可观察数据流进行异步编程的API。<br>ReactiveX结合了观察者模式、迭代器模式和函数式编程的精华</em>。</p>
</blockquote>
<p>关于Reactive（本文统一译作响应式），有一个<a href="https://www.reactivemanifesto.org/zh-CN" target="_blank" rel="noopener">The Reactive Manifesto</a>【响应式宣言】：<strong>响应式系统（Reactive System）具备以下特质：即时响应性（Responsive）、回弹性（Resilient）、弹性（Elastic）以及消息驱动（Message Driven）。</strong></p>
<p><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-84eafef9e10f402d.png" alt=""></p>
<p>很显然开发一个响应式系统，并不简单。<br>那本文就来讲一讲如何基于Rx.NET进行响应式编程，进而开发更加灵活、松耦合、可伸缩的响应式系统。</p>
<h1 id="2-编程范式"><a href="#2-编程范式" class="headerlink" title="2. 编程范式"></a>2. 编程范式</h1><p>在开始之前呢，我们有必要了解下几种编程范式：命令式编程、声明式编程、函数式编程和响应式编程。</p>
<p><strong>命令式编程</strong>：命令式编程的主要思想是关注计算机执行的步骤，即一步一步告诉计算机先做什么再做什么。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;1. 声明变量</span><br><span class="line">List&lt;int&gt; results &#x3D; new List&lt;int&gt;();</span><br><span class="line">&#x2F;&#x2F;2. 循环变量</span><br><span class="line">foreach(var num in Enumerable.Range(1,10))</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;3. 添加条件</span><br><span class="line">    if (num &gt; 5)</span><br><span class="line">    &#123;  </span><br><span class="line">        &#x2F;&#x2F;4. 添加处理逻辑</span><br><span class="line">        results.Add(num);</span><br><span class="line">        Console.WriteLine(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>声明式编程</strong>：声明式编程是以数据结构的形式来表达程序执行的逻辑。它的主要思想是告诉计算机应该做什么，但不指定具体要怎么做。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var nums &#x3D; from num in Enumerable.Range(1,10) where num &gt; 5 select num</span><br></pre></td></tr></table></figure>
<p><strong>函数式编程</strong>：主要思想是把运算过程尽量写成一系列嵌套的函数调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enumerable.Range(1, 10).Where(num &#x3D;&gt; num &gt; 5).ToList().ForEach(Console.WriteLine);</span><br></pre></td></tr></table></figure>
<p><strong>响应式编程</strong>：响应式编程是一种面向数据流和变化传播的编程范式，旨在简化事件驱动应用的实现。响应式编程专注于如何创建依赖于变更的数据流并对变化做出响应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IObservable&lt;int&gt; nums &#x3D; Enumerable.Range(1, 10).ToObservable();</span><br><span class="line"></span><br><span class="line">IDisposable subscription &#x3D; nums.Where(num &#x3D;&gt; num &gt; 5).Subscribe(Console.WriteLine);</span><br><span class="line"></span><br><span class="line">subscription.Dispose();</span><br></pre></td></tr></table></figure>

<h1 id="3-Hello-Rx-NET"><a href="#3-Hello-Rx-NET" class="headerlink" title="3. Hello Rx.NET"></a>3. Hello Rx.NET</h1><p>从一个简单的Demo开始。<br>假设我们现在模拟电热壶烧水，实时输出当前水温，一般我们会这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enumerable.Range(1, 100).ToList().ForEach(Console.WriteLine);</span><br><span class="line">&#x2F;&#x2F; do something else. 阻塞</span><br></pre></td></tr></table></figure>
<p>假设当前程序是智能家居的中控设备，不仅控制电热壶烧水，还控制其他设备，为了避免阻塞主线程。一般我们会创建一个Thread或Task去做。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Task.Run(() &#x3D;&gt; Enumerable.Range(1, 100).ToList().ForEach(Console.WriteLine));</span><br><span class="line">&#x2F;&#x2F; do something else. 非阻塞</span><br></pre></td></tr></table></figure>
<p>假设现在我们不仅要在控制台输出而且还要实时通过扬声器报警。这时我们应该想到委托和事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Heater</span><br><span class="line">&#123;</span><br><span class="line">    private delegate void TemperatureChanged(int temperature);</span><br><span class="line">    private event TemperatureChanged TemperatureChangedEvent;</span><br><span class="line">    public void BoilWater()</span><br><span class="line">    &#123;</span><br><span class="line">        TemperatureChangedEvent +&#x3D; ShowTemperature;</span><br><span class="line">        TemperatureChangedEvent +&#x3D; MakeAlerm;</span><br><span class="line">        Task.Run(</span><br><span class="line">            () &#x3D;&gt;</span><br><span class="line">        Enumerable.Range(1, 100).ToList().ForEach((temperature) &#x3D;&gt; TemperatureChangedEvent(temperature))</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">    private void ShowTemperature(int temperature)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;当前温度：&#123;temperature&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    private void MakeAlerm(int temperature)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine($&quot;嘟嘟嘟，当前水温&#123;temperature&#125;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class Program</span><br><span class="line">&#123;</span><br><span class="line">    static void Main(string[] args)</span><br><span class="line">    &#123;</span><br><span class="line">        Heater heater &#x3D; new Heater();        </span><br><span class="line">        heater.BoilWater();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>瞬间代码量就上去了。但是借助Rx.NET，我们可以简化成以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var observable &#x3D; Enumerable.Range(1, 100).ToObservable(NewTheadScheduler.Default);&#x2F;&#x2F;申明可观察序列</span><br><span class="line">Subject&lt;int&gt; subject &#x3D; new Subject&lt;int&gt;();&#x2F;&#x2F;申明Subject</span><br><span class="line">subject.Subscribe((temperature) &#x3D;&gt; Console.WriteLine($&quot;当前温度：&#123;temperature&#125;&quot;));&#x2F;&#x2F;订阅subject</span><br><span class="line">subject.Subscribe((temperature) &#x3D;&gt; Console.WriteLine($&quot;嘟嘟嘟，当前水温：&#123;temperature&#125;&quot;));&#x2F;&#x2F;订阅subject</span><br><span class="line">observable.Subscribe(subject);&#x2F;&#x2F;订阅observable</span><br></pre></td></tr></table></figure>
<p>仅仅通过以下三步：</p>
<ol>
<li>调用<code>ToObservable</code>将枚举序列转换为可观察序列。</li>
<li>通过指定<code>NewTheadScheduler.Default</code>来指定在单独的线程进行枚举。</li>
<li>调用<code>Subscribe</code>方法进行事件注册。</li>
<li>借助<code>Subject</code>进行多播传输</li>
</ol>
<p>通过以上我们可以看到Rx.NET大大简化了事件处理的步骤，而这只是Rx的冰山一角。</p>
<h1 id="4-Rx-NET-核心"><a href="#4-Rx-NET-核心" class="headerlink" title="4. Rx.NET 核心"></a>4. Rx.NET 核心</h1><p><a href="https://github.com/dotnet/reactive" target="_blank" rel="noopener">Reactive Extensions</a>（Rx）是一个为.NET应用提供响应式编程模型的库，用来构建异步基于事件流的应用，通过安装<code>System.Reactive</code>Nuget包进行引用。Rx将事件流抽象为Observable sequences（可观察序列）表示异步数据流，使用LINQ运算符查询异步数据流，并使用<code>Scheduler</code>来控制异步数据流中的并发性。简单地说：<strong>Rx = Observables + LINQ + Schedulers。</strong></p>
<p><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-b4a81ae7fbc5526d.png" alt="Rx layer"></p>
<p>在软件系统中，事件是一种消息用于指示发生了某些事情。事件由Event Source（事件源）引发并由Event Handler（事件处理程序）使用。<br>在Rx中，事件源可以由observable表示，事件处理程序可以由observer表示。<br>但是应用程序使用的数据如何表示呢，例如数据库中的数据或从Web服务器获取的数据。而在应用程序中我们一般处理的数据无外乎两种：静态数据和动态数据。 但无论使用何种类型的数据，其都可以作为流来观察。换句话说，数据流本身也是可观察的。也就意味着，我们也可以用observable来表示数据流。</p>
<p><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-093cbaf2aab308e9.png" alt="Everything is stream"></p>
<p>讲到这里，Rx.NET的核心也就一目了然了：</p>
<ol>
<li>一切皆为数据流</li>
<li>Observable 是对数据流的抽象</li>
<li>Observer是对Observable的响应</li>
</ol>
<p>在Rx中，分别使用<code>IObservable&lt;T&gt;</code>和<code>IObserver&lt;T&gt;</code>接口来表示可观察序列和观察者。它们预置在system命名空间下，其定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IObservable&lt;out T&gt;</span><br><span class="line">&#123;</span><br><span class="line">      &#x2F;&#x2F;Notifies the provider that an observer is to receive notifications.</span><br><span class="line">      IDisposable Subscribe(IObserver&lt;T&gt; observer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface IObserver&lt;in T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;Notifies the observer that the provider has finished sending push-based notifications.</span><br><span class="line">    void OnCompleted();</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F;Notifies the observer that the provider has experienced an error condition.</span><br><span class="line">    void OnError(Exception error);</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;Provides the observer with new data.</span><br><span class="line">    void OnNext(T value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-cb04b6cd6fced9ea.png" alt=""></p>
<h1 id="5-创建IObservable"><a href="#5-创建IObservable" class="headerlink" title="5. 创建IObservable"></a>5. 创建IObservable<T></h1><p>创建<code>IObservable&lt;T&gt;</code>主要有以下几种方式：<br><strong>1. 直接实现<code>IObservable&lt;T&gt;</code>接口</strong><br><strong>2. 使用<code>Observable.Create</code>创建</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.Create&lt;int&gt;(observer&#x3D;&gt;&#123;</span><br><span class="line">    for (int i &#x3D; 0; i &lt; 5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        observer.OnNext(i);</span><br><span class="line">    &#125;</span><br><span class="line">    observer.OnCompleted();</span><br><span class="line">    return Disposable.Empty;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>3. 使用<code>Observable.Deffer</code>进行延迟创建（当有观察者订阅时才创建）</strong><br>比如要连接数据库进行查询，如果没有观察者，那么数据库连接会一直被占用，这样会造成资源浪费。使用Deffer可以解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.Defer(() &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var connection &#x3D; Connect(user, password);</span><br><span class="line">    return connection.ToObservable();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>4. 使用<code>Observable.Generate</code>创建迭代类型的可观察序列</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IObservable&lt;int&gt; observable &#x3D;</span><br><span class="line">    Observable.Generate(</span><br><span class="line">        0,              &#x2F;&#x2F;initial state</span><br><span class="line">        i &#x3D;&gt; i &lt; 10,    &#x2F;&#x2F;condition (false means terminate)</span><br><span class="line">        i &#x3D;&gt; i + 1,     &#x2F;&#x2F;next iteration step</span><br><span class="line">        i &#x3D;&gt; i * 2);      &#x2F;&#x2F;the value in each iteration</span><br></pre></td></tr></table></figure>
<p><strong>5. 使用<code>Observable.Range</code>创建指定区间的可观察序列</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IObservable&lt;int&gt; observable &#x3D; Observable.Range (0, 10).Select (i &#x3D;&gt; i * 2);</span><br></pre></td></tr></table></figure>
<p><strong>6. 创建特殊用途的可观察序列</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.Return (&quot;Hello World&quot;);&#x2F;&#x2F;创建单个元素的可观察序列</span><br><span class="line">Observable.Never&lt;string&gt; ();&#x2F;&#x2F;创建一个空的永远不会结束的可观察序列</span><br><span class="line">Observable.Throw&lt;ApplicationException&gt; (</span><br><span class="line">new ApplicationException (&quot;something bad happened&quot;))&#x2F;&#x2F;创建一个抛出指定异常的可观察序列</span><br><span class="line">Observable.Empty&lt;string&gt; ()&#x2F;&#x2F;创建一个空的立即结束的可观察序列</span><br></pre></td></tr></table></figure>
<p><strong>7. 使用<code>ToObservable</code>转换<code>IEnumerate</code>和Task类型</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Enumerable.Range(1, 10).ToObservable();</span><br><span class="line">IObservable&lt;IEnumerable&lt;string&gt;&gt; resultsA &#x3D; searchEngineA.SearchAsync(term).ToObservable();</span><br></pre></td></tr></table></figure>
<p><strong>8. 使用<code>Observable.FromEventPattern&lt;T&gt;</code>和<code>Observable.FromEvent&lt;TDelegate, TEventArgs&gt;</code></strong>进行事件的转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public delegate void RoutedEventHandler(object sender,</span><br><span class="line"> System.Windows.RoutedEventArgs e)</span><br><span class="line">IObservable&lt;EventPattern&lt;RoutedEventArgs&gt;&gt; clicks &#x3D;</span><br><span class="line">                Observable.FromEventPattern&lt;RoutedEventHandler, RoutedEventArgs&gt;(</span><br><span class="line">                    h &#x3D;&gt; theButton.Click +&#x3D; h,</span><br><span class="line">                    h &#x3D;&gt; theButton.Click -&#x3D; h);</span><br><span class="line">clicks.Subscribe(eventPattern &#x3D;&gt; output.Text +&#x3D; &quot;button clicked&quot; + Environment.NewLine);</span><br></pre></td></tr></table></figure>

<p><strong>9. 使用<code>Observable.Using</code>进行资源释放</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IObservable&lt;string&gt; lines &#x3D;</span><br><span class="line">    Observable.Using (</span><br><span class="line">        () &#x3D;&gt; File.OpenText (&quot;TextFile.txt&quot;), &#x2F;&#x2F; opens the file and returns the stream we work with</span><br><span class="line">        stream &#x3D;&gt;</span><br><span class="line">        Observable.Generate (</span><br><span class="line">            stream, &#x2F;&#x2F;initial state</span><br><span class="line">            s &#x3D;&gt; !s.EndOfStream, &#x2F;&#x2F;we continue until we reach the end of the file</span><br><span class="line">            s &#x3D;&gt; s, &#x2F;&#x2F;the stream is our state, it holds the position in the file </span><br><span class="line">            s &#x3D;&gt; s.ReadLine ()) &#x2F;&#x2F;each iteration will emit the current line (and moves to the next)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p><strong>10. 使用<code>Observable.Interval</code>创建指定间隔可观察序列</strong><br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-fbc5816e51fb2b45.png" alt=""></p>
<p><strong>11. 使用<code>Observable.Timer</code>创建可观察的计时器</strong><br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-9295db8a2f4e08e4.png" alt=""></p>
<h1 id="6-RX-操作符"><a href="#6-RX-操作符" class="headerlink" title="6. RX 操作符"></a>6. RX 操作符</h1><p>创建完IObservable<T>后，我们可以对其应用系列Linq操作符，对其进行查询、过滤、聚合等等。Rx内置了以下系列操作符：<br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-54a9467df0b603fa.png" alt="Rx 操作符"><br>下面通过图示来解释常用操作符的作用：<br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-a865665f963a58d8.png" alt="操作符解释"></p>
<h1 id="7-多播传输靠：Subject"><a href="#7-多播传输靠：Subject" class="headerlink" title="7. 多播传输靠：Subject"></a>7. 多播传输靠：Subject</h1><p>基于以上示例，我们了解到，借助Rx可以简化事件模型的实现，而其实质上就是对观察者模式的扩展。提到观察者模式，我们知道一个Subject可以被多个观察者订阅，从而完成消息的多播。同样，在Rx中，也引入了Subject用于多播消息传输，不过Rx中的Subject具有双重身份——即是观察者也是被观察者。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface ISubject&lt;in TSource, out TResult&gt; : IObserver&lt;TSource&gt;,IObservable&lt;TResult&gt;</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rx中默认提供了以下四种实现：</p>
<ul>
<li><p>Subject<T>  - 向所有观察者广播每个通知<br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-81a5de33fcef3ea5.png" alt=""></p>
</li>
<li><p>AsyncSubject<T>  - 当可观察序列完成后有且仅发送一个通知<br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-0961c4adefb27d9a.png" alt=""></p>
</li>
<li><p>ReplaySubject<T>  - 缓存指定通知以对后续订阅的观察者进行重放<br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-f661dc814a8ac625.png" alt=""></p>
</li>
<li><p>BehaviorSubject<T>  - 推送默认值或最新值给观察者<br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-c72dc53ff1f6368d.png" alt=""></p>
</li>
</ul>
<p>但对于第一种<code>Subject&lt;T&gt;</code>有一点需要指出，当其有多个观察者序列时，一旦其中一个停止发送消息，则Subject就停止广播所有其他序列后续发送的任何消息。<br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-c6fedeb092186767.png" alt=""></p>
<h1 id="8-有温度的可观察者序列"><a href="#8-有温度的可观察者序列" class="headerlink" title="8. 有温度的可观察者序列"></a>8. 有温度的可观察者序列</h1><p>对于Observable，它们是有温度的，有冷热之分。它们的区别如下图所示：<br><img src="/images/how-much-you-know-about-the-reactive-programming-in-dotnet/2799767-c4204f808d9849ed.png" alt="冷热观察者序列的区别"></p>
<p><strong>Cold Observable</strong>：有且仅当有观察者订阅时才发送通知，且每个观察者独享一份完整的观察者序列。<br><strong>Hot Observable</strong>：不管有无观察者订阅都会发送通知，且所有观察者共享同一份观察者序列。</p>
<h1 id="9-一切皆在掌控：Scheduler"><a href="#9-一切皆在掌控：Scheduler" class="headerlink" title="9. 一切皆在掌控：Scheduler"></a>9. 一切皆在掌控：Scheduler</h1><p>在Rx中，使用Scheduler来控制并发。而对于Scheduler我们可以理解为程序调度，通过Scheduler来规定在什么时间什么地点执行什么事情。Rx提供了以下几种Scheduler：</p>
<ol>
<li>NewThreadScheduler：即在新线程上执行</li>
<li>ThreadPoolScheduler：即在线程池中执行</li>
<li>TaskPoolScheduler：与ThreadPoolScheduler类似</li>
<li>CurrentThreadScheduler：在当前线程执行</li>
<li>ImmediateScheduler：在当前线程立即执行</li>
<li>EventLoopScheduler：创建一个后台线程按序执行所有操作</li>
</ol>
<p>举例而言：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.Return(&quot;Hello&quot;,NewThreadScheduler.Default)</span><br><span class="line">.Subscribe(str&#x3D;&gt;Console.WriteLine($&quot;&#123;str&#125; on ThreadId：&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;)</span><br><span class="line">);</span><br><span class="line">Console.WriteLine($&quot;Current ThreadId：&#123;Thread.CurrentThread.ManagedThreadId&#125;&quot;);</span><br><span class="line"></span><br><span class="line">以上输出：</span><br><span class="line">Current ThreadId：1</span><br><span class="line">Hello on ThreadId：4</span><br></pre></td></tr></table></figure>
<h1 id="10-最后"><a href="#10-最后" class="headerlink" title="10. 最后"></a>10. 最后</h1><p>罗里吧嗦的总算把《Rx.NET In Action》这本书的内容大致梳理了一遍，对Rx也有了一个更深的认识，Rx扩展了观察者模式用于支持数据和事件序列，内置系列操作符允许我们以声明式的方式组合这些序列，且无需关注底层的实现进行事件驱动开发：如线程、同步、线程安全、并发数据结构和非阻塞IO。</p>
<p>但事无巨细，难免疏漏。对响应式编程有兴趣的不妨拜读下此书，相信对你会大有裨益。</p>
<blockquote>
<p>参考资料：<br><a href="http://dl1.rapidhosting.info/files/1Y6LHgXt/c14bde04cda2eb9b3c3f1da09dc6987b/Rx.Net.Action.Examples.Tamir.Dresher.31.pdf" target="_blank" rel="noopener">Rx.NET in Action.pdf</a><br><a href="http://reactivex.io/" target="_blank" rel="noopener">ReactiveX</a><br><a href="https://www.cnblogs.com/richieyang/p/4974630.html" target="_blank" rel="noopener">.Net中的反应式编程(Reactive Programming)</a></p>
</blockquote>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
        <tag>Rx.NET</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL递归查询知多少</title>
    <url>/post/how-much-you-know-about-the-recursive-query-in-sqlserver-and-oracle/</url>
    <content><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>最近工作中遇到了一个问题，需要根据保存的流程数据，构建流程图。数据库中保存的流程数据是树形结构的，表结构及数据如下图：</p>
<p><img src="/images/how-much-you-know-about-the-recursive-query-in-sqlserver-and-oracle/2799767-438a0621acbccd40.png" alt="流程表结构数据举例"></p>
<p>仔细观察表结构，会发现其树形结构的特点：</p>
<ul>
<li>FFIRSTNODE：标记是否为根节点</li>
<li>FSTABLENAME：标记来源单据名称</li>
<li>FSID：标记来源单据分录ID</li>
<li>FTTABLENAME ：标记目标单据名称</li>
<li>FTID：标记目标单据分录ID</li>
</ul>
<p>图中的流程为：<br><strong>销售合同–&gt;销售订单–&gt;发货通知单–&gt;销售出库单</strong></p>
<p>首先想到的办法就是把流程数据取回来，然后代码构造流程图。<br>第一个思路：根据根节点循环往下找，吭呲半天，发现没那么简单。<br>因为任何一个源头单据都可以多次下推目标单据：<br>第二个思路：先找到终极节点，在从终极节点往上找只至根节点为0。<br>这个思路实现起来也没有那么复杂，逻辑理清，循环遍历，最终也能实现结果。（但在大数据量情况下，易导致性能瓶颈。）</p>
<p>这一次我们换一个思路，让SQL来替我们做这一复杂的递归查询。</p>
<h1 id="SqlServer-递归查询"><a href="#SqlServer-递归查询" class="headerlink" title="SqlServer 递归查询"></a>SqlServer 递归查询</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote>
<p>公用表表达式 (CTE) 可以认为是在单个 SELECT、INSERT、UPDATE、DELETE 或 CREATE VIEW 语句的执行范围内定义的临时结果集。公用表表达式可以包括对自身的引用，这种表达式称为递归公用表表达式。</p>
</blockquote>
<ul>
<li>创建递归查询。有关详细信息，请参阅<a href="https://technet.microsoft.com/zh-cn/library/ms186243(v=sql.105).aspx" target="_blank" rel="noopener">使用公用表表达式的递归查询</a>。</li>
<li>在不需要常规使用视图时替换视图，也就是说，不必将定义存储在元数据中。</li>
<li>启用按从标量嵌套 select 语句派生的列进行分组，或者按不确定性函数或有外部访问的函数进行分组。</li>
<li>在同一语句中多次引用生成的表。</li>
</ul>
<p><a href="https://msdn.microsoft.com/zh-cn/library/ms175972.aspx" target="_blank" rel="noopener">MSDN上对CTE的介绍</a><br><a href="http://www.cnblogs.com/CareySon/archive/2011/12/12/2284740.html" target="_blank" rel="noopener">T-SQL查询进阶–详解公用表表达式(CTE)</a></p>
<p>CTE 的基本语法结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WITH expression_name [ ( column_name [,...n] ) ]</span><br><span class="line">AS</span><br><span class="line">( CTE_query_definition )</span><br><span class="line">--只有在查询定义中为所有结果列都提供了不同的名称时，列名称列表才是可选的。</span><br><span class="line">--运行 CTE 的语句为：</span><br><span class="line">SELECT &lt;column_list&gt; FROM expression_name;</span><br></pre></td></tr></table></figure>
<p>即三个部分：</p>
<ol>
<li>公用表表达式的名字（在WITH关键字之后）</li>
<li>查询的列名（可选）</li>
<li>紧跟AS之后的SELECT语句（<em>如果AS之后有多个对公用表的查询，则只有第一个查询有效</em>）</li>
</ol>
<h2 id="动手实践"><a href="#动手实践" class="headerlink" title="动手实践"></a>动手实践</h2><p>根据官网示例我们很简单就可以写出CTE语句应用于我们的应用场景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WITH TEST_CTE </span><br><span class="line">AS</span><br><span class="line">(</span><br><span class="line">SELECT TBIE.FSTABLENAME,TBIE.FSID,TBIE.FTTABLENAME,TBIE.FTID,TBIE.FROUTEID FROM T_BF_INSTANCEENTRY TBIE</span><br><span class="line">WHERE TBIE.FTTABLENAME &#x3D; &#39;T_SAL_ORDERENTRY&#39; AND TBIE.FTID &#x3D; 121625</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT CTBIE.FSTABLENAME,CTBIE.FSID,CTBIE.FTTABLENAME,CTBIE.FTID,CTBIE.FROUTEID  FROM T_BF_INSTANCEENTRY CTBIE</span><br><span class="line">INNER JOIN TEST_CTE CTE ON CTBIE.FSID&#x3D;CTE.FTID AND CTBIE.FSTABLENAME &#x3D; CTE.FTTABLENAME</span><br><span class="line">)</span><br><span class="line">SELECT * FROM TEST_CTE  </span><br><span class="line">--限制递归次数</span><br><span class="line">OPTION(MAXRECURSION 10)</span><br></pre></td></tr></table></figure>

<p>在查询中我们指定条件参数<code>WHERE TBIE.FTTABLENAME = &#39;T_SAL_ORDERENTRY&#39; AND TBIE.FTID = 121625</code>，即可查询到指定节点的完整流程数据。<br><em>其中在与公用表<code>TEST_CTE</code>进行关联时，我指定了两个条件<code>CTBIE.FSID=CTE.FTID AND CTBIE.FSTABLENAME = CTE.FTTABLENAME</code>，因为不同类型的单据各有一套自增的ID，直接用ID进行关联迭代不可行。</em></p>
<p><img src="/images/how-much-you-know-about-the-recursive-query-in-sqlserver-and-oracle/2799767-7ecb5971eca7ad7a.png" alt="查询结果"></p>
<p>需要注意的是<strong><code>OPTION(MAXRECURSION 10)</code></strong>是用来限制递归次数，以避免无限递归导致数据库性能消耗严重。</p>
<h2 id="扩展：构造递归路径"><a href="#扩展：构造递归路径" class="headerlink" title="扩展：构造递归路径"></a>扩展：构造递归路径</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WITH TEST_CTE </span><br><span class="line">AS</span><br><span class="line">(</span><br><span class="line">SELECT TBIE.FSTABLENAME,TBIE.FSID,TBIE.FTTABLENAME,TBIE.FTID,TBIE.FROUTEID,Cast(TBIE.FTID as nvarchar(4000)) AS PATH</span><br><span class="line">FROM T_BF_INSTANCEENTRY TBIE</span><br><span class="line">WHERE TBIE.FTTABLENAME &#x3D; &#39;T_SAL_ORDERENTRY&#39; AND TBIE.FTID &#x3D; 121625</span><br><span class="line">UNION ALL</span><br><span class="line">SELECT CTBIE.FSTABLENAME,CTBIE.FSID,CTBIE.FTTABLENAME,CTBIE.FTID,CTBIE.FROUTEID,CTE.PATH+&#39;-&gt;&#39;+Cast(CTBIE.FTID as nvarchar(4000)) PATH  </span><br><span class="line">FROM T_BF_INSTANCEENTRY CTBIE</span><br><span class="line">INNER JOIN TEST_CTE CTE ON CTBIE.FSID&#x3D;CTE.FTID AND CTBIE.FSTABLENAME &#x3D; CTE.FTTABLENAME</span><br><span class="line">)</span><br><span class="line">SELECT * FROM TEST_CTE  </span><br><span class="line">--限制递归次数</span><br><span class="line">OPTION(MAXRECURSION 10)</span><br></pre></td></tr></table></figure>

<p>基于上一个查询，增加一列手动拼接递归路径。注意sql中将PATH设置的类型为navarchar(4000)，在union中，两边的表结构类型必须保持一致，否则会报错<code>定位点类型和递归部分的类型不匹配</code>。可参考此篇博文<br><a href="http://www.cnblogs.com/ccding13/p/3515393.html" target="_blank" rel="noopener">解决CTE定位点类型和递归部分的类型不匹配</a>。</p>
<p><img src="/images/how-much-you-know-about-the-recursive-query-in-sqlserver-and-oracle/2799767-82fc5de8bb634c3a.png" alt="递归路径查询结果"></p>
<h1 id="Oracle-递归查询"><a href="#Oracle-递归查询" class="headerlink" title="Oracle 递归查询"></a>Oracle 递归查询</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>Oracle中的递归查询语句为<code>start with…connect by prior</code>，为中序遍历算法。<br>可参考<a href="http://www.cnblogs.com/yingsong/p/5035907.html" target="_blank" rel="noopener">Oracle 树操作、递归查询(select…start with…connect by…prior)</a>了解更多。</p>
<p><img src="/images/how-much-you-know-about-the-recursive-query-in-sqlserver-and-oracle/2799767-7a6a047617d286e4.png" alt="查询顺序"></p>
<p>其基本语法是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select colname from tablename</span><br><span class="line">start with 条件1</span><br><span class="line">connect by 条件2</span><br><span class="line">where 条件3;</span><br></pre></td></tr></table></figure>

<ul>
<li>条件1： 是根结点的限定语句，当然可以放宽限定条件，以遍历多个根结点，实际就是多棵树。</li>
<li>条件2：是连接条件，其中用<strong>PRIOR</strong>表示上一条记录。<br>比如<code>CONNECT BY PRIOR Id = Parent_Id</code>就是说<strong>上一条记录的Id 是本条记录的Parent_Id</strong>。</li>
<li>条件3：过滤返回的结果集。</li>
</ul>
<p><strong>PRIOR关键字</strong></p>
<p>运算符PRIOR被放置于等号前后的位置，决定着查询时的检索顺序。</p>
<ul>
<li>PRIOR被置于CONNECT BY子句中<strong>等号的前面</strong>时，则强制从根节点到叶节点的顺序检索，为<strong>自顶向下</strong>查找。<br>如：<code>CONNECT BY PRIOR Id=Parent_Id</code></li>
<li>PIROR运算符被置于CONNECT BY 子句中<strong>等号的后面</strong>时，则强制从叶节点到根节点的顺序检索，为<strong>自底向上的</strong>查找。<br>如：<code>CONNECT BY Id=PRIOR Parent_Id</code></li>
</ul>
<p><strong>PS：当CONNECT BY后指定多个连接条件时，每个条件都应指定<code>PRIOR</code>关键字</strong></p>
<h2 id="动手实践-1"><a href="#动手实践-1" class="headerlink" title="动手实践"></a>动手实践</h2><p>理清了用法，我们用Oracle来对查询一下业务流程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM T_BF_INSTANCEENTRY </span><br><span class="line">START WITH (FTID&#x3D;100501 AND FTTABLENAME &#x3D; &#39;T_SAL_ORDERENTRY&#39;)</span><br><span class="line">CONNECT BY  FSID&#x3D; PRIOR FTID AND FSTABLENAME &#x3D;PRIOR FTTABLENAME</span><br></pre></td></tr></table></figure>
<p><img src="/images/how-much-you-know-about-the-recursive-query-in-sqlserver-and-oracle/2799767-c1c7a780cbb60575.png" alt="查询结果"></p>
<p>该流程为：<strong>销售订单–&gt;发货通知单–&gt;销售出库单–&gt;退货通知单–&gt;销售退货单</strong><br><em>其中在指定连接条件时，我指定了两个条件<code>FSID= PRIOR FTID AND FSTABLENAME =PRIOR FTTABLENAME</code>，因为不同类型的单据各有一套自增的ID，直接用ID进行关联迭代不可行。</em></p>
<h2 id="扩展：构造递归路径-1"><a href="#扩展：构造递归路径-1" class="headerlink" title="扩展：构造递归路径"></a>扩展：构造递归路径</h2><p>Oracle中提供了<code>SYS_CONNECT_BY_PATH</code>函数用来进行连接路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT TBIE.*, SUBSTR(SYS_CONNECT_BY_PATH(FTID,&#39;-&gt;&#39;),3)  NAME_PATH FROM T_BF_INSTANCEENTRY TBIE</span><br><span class="line">START WITH (FTID&#x3D;100501 AND FTTABLENAME &#x3D; &#39;T_SAL_ORDERENTRY&#39;)</span><br><span class="line">CONNECT BY  FSID&#x3D; PRIOR FTID AND FSTABLENAME &#x3D;PRIOR FTTABLENAME</span><br></pre></td></tr></table></figure>
<p>基于上个查询，增加了一列<code>SUBSTR(SYS_CONNECT_BY_PATH(FTID,&#39;-&gt;&#39;),3)  NAME_PATH</code>用来拼接递归路径。</p>
<p><img src="/images/how-much-you-know-about-the-recursive-query-in-sqlserver-and-oracle/2799767-a2159ee0b27a72c7.png" alt="递归路径查询结果"></p>
<h2 id="显示当前节点的根节点"><a href="#显示当前节点的根节点" class="headerlink" title="显示当前节点的根节点"></a>显示当前节点的根节点</h2><p>这个时候我们要用到<code>connect_by_root</code>函数，用来记录当前节点的根节点信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT TBIE.*, SUBSTR(SYS_CONNECT_BY_PATH(FTID,&#39;-&gt;&#39;),3)NAME_PATH, (connect_by_root FTID) ROOT  FROM T_BF_INSTANCEENTRY TBIE</span><br><span class="line">START WITH (FTID&#x3D;100501 AND FTTABLENAME &#x3D; &#39;T_SAL_ORDERENTRY&#39;)</span><br><span class="line">CONNECT BY  FSID&#x3D; PRIOR FTID AND FSTABLENAME &#x3D;PRIOR FTTABLENAME</span><br></pre></td></tr></table></figure>

<p><img src="/images/how-much-you-know-about-the-recursive-query-in-sqlserver-and-oracle/2799767-1ed0676674ecdc51.png" alt="当前节点的根节点的查询结果"></p>
<h2 id="Oracle中的with…as语句"><a href="#Oracle中的with…as语句" class="headerlink" title="Oracle中的with…as语句"></a>Oracle中的with…as语句</h2><p>Oracle也有with..as 查询语法，一般用来进行子查询，提高查询效率。<br>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with tempTableName as ( select * from table1 )</span><br><span class="line">select * from tempTableName</span><br></pre></td></tr></table></figure>
<p>拿我们的案例举例就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with flow_temp as (</span><br><span class="line">SELECT TBIE.*, SUBSTR(SYS_CONNECT_BY_PATH(FTID,&#39;-&gt;&#39;),3)NAME_PATH, (connect_by_root FTID) ROOT  FROM T_BF_INSTANCEENTRY TBIE</span><br><span class="line">START WITH (FTID&#x3D;100501 AND FTTABLENAME &#x3D; &#39;T_SAL_ORDERENTRY&#39;)</span><br><span class="line">CONNECT BY  FSID&#x3D; PRIOR FTID AND FSTABLENAME &#x3D;PRIOR FTTABLENAME</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">select * from flow_temp</span><br></pre></td></tr></table></figure>

<p>为啥要讲这个呢，我们可以在oracle递归查询后进行筛选啊。</p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>UnitOfWork 知多少</title>
    <url>/post/how-much-you-know-about-the-unit-of-work/</url>
    <content><![CDATA[<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. 引言</h1><blockquote>
<p>Maintains a list of objects affected by a business transaction and coordinates the writing out of changes and the resolution of concurrency problems.<br> <em><a href="https://martinfowler.com/eaaCatalog/unitOfWork.html" target="_blank" rel="noopener">Unit of Work</a> –Martin Fowler</em></p>
</blockquote>
<p>Unit Of Work模式，由马丁大叔提出，是一种数据访问模式。UOW模式的作用是在业务用例的操作中跟踪对象的所有更改（增加、删除和更新），并将所有更改的对象保存在其维护的列表中。在业务用例的终点，通过事务，<strong>一次性提交所有更改</strong>，以确保数据的完整性和有效性。总而言之，UOW协调这些对象的持久化及并发问题。</p>
<h1 id="2-UOW的本质"><a href="#2-UOW的本质" class="headerlink" title="2. UOW的本质"></a>2. UOW的本质</h1><p>通过以上的介绍，我们可以总结出实现UOW的几个要点：</p>
<ol>
<li>UOW跟踪变化</li>
<li>UOW维护了一个变更列表</li>
<li>UOW将跟踪到的已变更的对象保存到变更列表中</li>
<li>UOW借助事务一次性提交变更列表中的所有更改</li>
<li>UOW处理并发</li>
</ol>
<p>而对于这些要点，EF中的DBContext已经实现了。</p>
<h1 id="3-EF中的UOW"><a href="#3-EF中的UOW" class="headerlink" title="3. EF中的UOW"></a>3. EF中的UOW</h1><p>每个<code>DbContext</code>类型实例都有一个<code>ChangeTracker</code>用来跟踪记录实体的变化。当调用<code>SaveChanges</code>时，所有的更改将通过事务一次性提交到数据库。</p>
<p>我们直接看个EF Core的测试用例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ApplicationDbContext InMemorySqliteTestDbContext</span><br><span class="line">&#123;</span><br><span class="line">    get</span><br><span class="line">    &#123;</span><br><span class="line">        &#x2F;&#x2F; In-memory database only exists while the connection is open</span><br><span class="line">        var connection &#x3D; new SqliteConnection(&quot;DataSource&#x3D;:memory:&quot;);</span><br><span class="line">        connection.Open();</span><br><span class="line"></span><br><span class="line">        var options &#x3D; new DbContextOptionsBuilder&lt;ApplicationDbContext&gt;()</span><br><span class="line">            .UseSqlite(connection)</span><br><span class="line">            .Options;</span><br><span class="line"></span><br><span class="line">        var context &#x3D; new ApplicationDbContext(options);</span><br><span class="line">        context.Database.EnsureCreated();</span><br><span class="line">        return context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[Fact]</span><br><span class="line">public void Test_Ef_Implemented_Uow()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;新增用户</span><br><span class="line">    var user &#x3D; new ApplicationUser()</span><br><span class="line">    &#123;</span><br><span class="line">        UserName &#x3D; &quot;shengjie&quot;,</span><br><span class="line">        Email &#x3D; &quot;ysjshengjie@qq.com&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    InMemorySqliteTestDbContext.Users.Add(user);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;创建用户对应客户</span><br><span class="line">    var customer &#x3D; new Customer()</span><br><span class="line">    &#123;</span><br><span class="line">        ApplicationUser &#x3D; user,</span><br><span class="line">        NickName &#x3D; &quot;圣杰&quot;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    InMemorySqliteTestDbContext.Customers.Add(customer);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;添加地址</span><br><span class="line">    var address &#x3D; new Address(&quot;广东省&quot;, &quot;深圳市&quot;, &quot;福田区&quot;, &quot;下沙街道&quot;, &quot;圣杰&quot;, &quot;135****9309&quot;);</span><br><span class="line"></span><br><span class="line">    InMemorySqliteTestDbContext.Addresses.Add(address);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;修改客户对象的派送地址</span><br><span class="line">    customer.AddShippingAddress(address);</span><br><span class="line"></span><br><span class="line">    InMemoryTestDbContext.Entry(customer).State &#x3D; EntityState.Modified;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;保存</span><br><span class="line">    var changes &#x3D; InMemorySqliteTestDbContext.SaveChanges();</span><br><span class="line"></span><br><span class="line">    Assert.Equal(3, changes);</span><br><span class="line"></span><br><span class="line">    var savedCustomer &#x3D; InMemorySqliteTestDbContext.Customers</span><br><span class="line">        .FirstOrDefault(c &#x3D;&gt; c.NickName &#x3D;&#x3D; &quot;圣杰&quot;);</span><br><span class="line"></span><br><span class="line">    Assert.Equal(&quot;shengjie&quot;, savedCustomer.ApplicationUser.UserName);</span><br><span class="line"></span><br><span class="line">    Assert.Equal(customer.ApplicationUserId, savedCustomer.ApplicationUserId);</span><br><span class="line"></span><br><span class="line">    Assert.Equal(1, savedCustomer.ShippingAddresses.Count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先这个用例是绿色通过的。该测试用例中我们添加了一个User，并为User创建对应的Customer，同时为Customer添加一条Address。从代码中我们可以看出仅做了一次保存，新增加的User、Customer、Address对象都成功持久化到了内存数据库中。从而证明EF Core是实现了Uow模式的。但很显然应用程序与基础设施层高度耦合，那如何解耦呢？继续往下看。</p>
<h1 id="4-DDD中的UOW"><a href="#4-DDD中的UOW" class="headerlink" title="4. DDD中的UOW"></a>4. DDD中的UOW</h1><p>那既然EF Core已经实现了Uow模式，我们还有必要自行实现一套Uow模式吗？这就视具体情况而定了，如果你的项目简单的增删改查就搞定了的，就不用折腾了。</p>
<p>在DDD中，我们会借助仓储模式来实现领域对象的持久化。仓储只关注于单一聚合的持久化，而业务用例却常常会涉及多个聚合的更改，为了确保业务用例的一致型，我们需要引入事务管理，而事务管理是应用服务层的关注点。我们如何在应用服务层来管理事务呢？借助UOW。这样就形成了一条链：Uow-&gt;仓储–&gt;聚合–&gt;实体和值对象。即Uow负责管理仓储处理事务，仓储管理单一聚合，聚合又由实体和值对象组成。</p>
<p>下面我们就先来定义实体和值对象，这里我们使用层超类型。</p>
<h2 id="4-1-定义实体"><a href="#4-1-定义实体" class="headerlink" title="4.1. 定义实体"></a>4.1. 定义实体</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; A shortcut of &lt;see cref&#x3D;&quot;IEntity&#123;TPrimaryKey&#125;&quot;&#x2F;&gt; for most used primary key type (&lt;see cref&#x3D;&quot;int&quot;&#x2F;&gt;).</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">public interface IEntity : IEntity&lt;int&gt;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; Defines interface for base entity type. All entities in the system must implement this interface.</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">&#x2F;&#x2F;&#x2F; &lt;typeparam name&#x3D;&quot;TPrimaryKey&quot;&gt;Type of the primary key of the entity&lt;&#x2F;typeparam&gt;</span><br><span class="line">public interface IEntity&lt;TPrimaryKey&gt;</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;summary&gt;</span><br><span class="line">    &#x2F;&#x2F;&#x2F; Unique identifier for this entity.</span><br><span class="line">    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;</span><br><span class="line">    TPrimaryKey Id &#123; get; set; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-2-定义聚合"><a href="#4-2-定义聚合" class="headerlink" title="4.2. 定义聚合"></a>4.2. 定义聚合</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace UnitOfWork</span><br><span class="line">&#123;</span><br><span class="line">    public interface IAggregateRoot : IAggregateRoot&lt;int&gt;, IEntity</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public interface IAggregateRoot&lt;TPrimaryKey&gt; : IEntity&lt;TPrimaryKey&gt;</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-定义泛型仓储"><a href="#4-3-定义泛型仓储" class="headerlink" title="4.3. 定义泛型仓储"></a>4.3. 定义泛型仓储</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace UnitOfWork</span><br><span class="line">&#123;</span><br><span class="line">    public interface IRepository&lt;TEntity&gt; : IRepository&lt;TEntity, int&gt;</span><br><span class="line">        where TEntity : class, IEntity, IAggregateRoot</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public interface IRepository&lt;TEntity, TPrimaryKey&gt;</span><br><span class="line">        where TEntity : class, IEntity&lt;TPrimaryKey&gt;, IAggregateRoot&lt;TPrimaryKey&gt;</span><br><span class="line">    &#123;        </span><br><span class="line">        IQueryable&lt;TEntity&gt; GetAll();</span><br><span class="line"></span><br><span class="line">        TEntity Get(TPrimaryKey id);</span><br><span class="line"></span><br><span class="line">        TEntity FirstOrDefault(TPrimaryKey id);</span><br><span class="line"></span><br><span class="line">        TEntity Insert(TEntity entity);</span><br><span class="line">        </span><br><span class="line">        TEntity Update(TEntity entity);</span><br><span class="line"></span><br><span class="line">        void Delete(TEntity entity);</span><br><span class="line"></span><br><span class="line">        void Delete(TPrimaryKey id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为仓储是管理聚合的，所以我们需要限制泛型参数为实现<code>IAggregateRoot</code>的类。</p>
<h2 id="4-4-实现泛型仓储"><a href="#4-4-实现泛型仓储" class="headerlink" title="4.4. 实现泛型仓储"></a>4.4. 实现泛型仓储</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">amespace UnitOfWork.Repositories</span><br><span class="line">&#123;</span><br><span class="line">    public class EfCoreRepository&lt;TEntity&gt;</span><br><span class="line">        : EfCoreRepository&lt;TEntity, int&gt;, IRepository&lt;TEntity&gt;</span><br><span class="line">        where TEntity : class, IEntity, IAggregateRoot</span><br><span class="line">    &#123;</span><br><span class="line">        public EfCoreRepository(UnitOfWorkDbContext dbDbContext) : base(dbDbContext)</span><br><span class="line">        &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public class EfCoreRepository&lt;TEntity, TPrimaryKey&gt;</span><br><span class="line">        : IRepository&lt;TEntity, TPrimaryKey&gt;</span><br><span class="line">        where TEntity : class, IEntity&lt;TPrimaryKey&gt;, IAggregateRoot&lt;TPrimaryKey&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly UnitOfWorkDbContext _dbContext;</span><br><span class="line"></span><br><span class="line">        public virtual DbSet&lt;TEntity&gt; Table &#x3D;&gt; _dbContext.Set&lt;TEntity&gt;();</span><br><span class="line"></span><br><span class="line">        public EfCoreRepository(UnitOfWorkDbContext dbDbContext)</span><br><span class="line">        &#123;</span><br><span class="line">            _dbContext &#x3D; dbDbContext;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public IQueryable&lt;TEntity&gt; GetAll()</span><br><span class="line">        &#123;</span><br><span class="line">            return Table.AsQueryable();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public TEntity Insert(TEntity entity)</span><br><span class="line">        &#123;</span><br><span class="line">            var newEntity &#x3D; Table.Add(entity).Entity;</span><br><span class="line">            _dbContext.SaveChanges();</span><br><span class="line">            return newEntity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public TEntity Update(TEntity entity)</span><br><span class="line">        &#123;</span><br><span class="line">            AttachIfNot(entity);</span><br><span class="line">            _dbContext.Entry(entity).State &#x3D; EntityState.Modified;</span><br><span class="line"></span><br><span class="line">            _dbContext.SaveChanges();</span><br><span class="line"></span><br><span class="line">            return entity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Delete(TEntity entity)</span><br><span class="line">        &#123;</span><br><span class="line">            AttachIfNot(entity);</span><br><span class="line">            Table.Remove(entity);</span><br><span class="line"></span><br><span class="line">           _dbContext.SaveChanges();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void Delete(TPrimaryKey id)</span><br><span class="line">        &#123;</span><br><span class="line">            var entity &#x3D; GetFromChangeTrackerOrNull(id);</span><br><span class="line">            if (entity !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                Delete(entity);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            entity &#x3D; FirstOrDefault(id);</span><br><span class="line">            if (entity !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                Delete(entity);</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        protected virtual void AttachIfNot(TEntity entity)</span><br><span class="line">        &#123;</span><br><span class="line">            var entry &#x3D; _dbContext.ChangeTracker.Entries().FirstOrDefault(ent &#x3D;&gt; ent.Entity &#x3D;&#x3D; entity);</span><br><span class="line">            if (entry !&#x3D; null)</span><br><span class="line">            &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Table.Attach(entity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        private TEntity GetFromChangeTrackerOrNull(TPrimaryKey id)</span><br><span class="line">        &#123;</span><br><span class="line">            var entry &#x3D; _dbContext.ChangeTracker.Entries()</span><br><span class="line">                .FirstOrDefault(</span><br><span class="line">                    ent &#x3D;&gt;</span><br><span class="line">                        ent.Entity is TEntity &amp;&amp;</span><br><span class="line">                        EqualityComparer&lt;TPrimaryKey&gt;.Default.Equals(id, ((TEntity)ent.Entity).Id)</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">            return entry?.Entity as TEntity;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们直接使用EF Core进行持久化，所以我们直接通过构造函数初始化DbContex实例。同时，我们注意到<code>Insert、Update、Delete</code>方法都显式的调用了<code>SaveChanges</code>方法。</p>
<p>至此，我们完成了从实体到聚合再到仓储的定义和实现，万事俱备，只欠Uow。</p>
<h2 id="4-5-实现UOW"><a href="#4-5-实现UOW" class="headerlink" title="4.5. 实现UOW"></a>4.5. 实现UOW</h2><p>通过第3节的说明我们已经知道，EF Core已经实现了UOW模式。而为了确保领域层透明的进行持久化，我们对其进行了更高一层的抽象，实现了仓储模式。但这似乎引入了另外一个问题，因为仓储是管理单一聚合的，每次做增删改时都显式的提交了更改（调用了SaveChanges），在处理多个聚合时，就无法利用DbContext进行批量提交了。那该如何是好？一不做二不休，我们再对其进行一层抽象，抽离保存接口，这也就是Uow的核心接口方法。<br>我们抽离<code>SaveChanges</code>方法，定义<code>IUnitOfWork</code>接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace UnitOfWork</span><br><span class="line">&#123;</span><br><span class="line">    public interface IUnitOfWork</span><br><span class="line">    &#123;</span><br><span class="line">        int SaveChanges();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我们是基于EFCore实现Uow的，所以我们只需要依赖DbContex，就可以实现批量提交。实现也很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace UnitOfWork</span><br><span class="line">&#123;</span><br><span class="line">    public class UnitOfWork&lt;TDbContext&gt; : IUnitOfWork where TDbContext : DbContext</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly TDbContext _dbContext;</span><br><span class="line"></span><br><span class="line">        public UnitOfWork(TDbContext context)</span><br><span class="line">        &#123;</span><br><span class="line">            _dbContext &#x3D; context ?? throw new ArgumentNullException(nameof(context));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public int SaveChanges()</span><br><span class="line">        &#123;</span><br><span class="line">            return _dbContext.SaveChanges();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然Uow接手保存操作，自然我们需要：<strong>注释掉EfCoreRepository中Insert、Update、Delete方法中的显式保存调用<code>_dbContext.SaveChanges();</code></strong>。</p>
<p>那如何确保操作多个仓储时，最终能够一次性提交所有呢？</p>
<p><strong>确保Uow和仓储共用同一个DbContex即可</strong>。这个时候我们就可以借助依赖注入。</p>
<h2 id="4-6-依赖注入"><a href="#4-6-依赖注入" class="headerlink" title="4.6. 依赖注入"></a>4.6. 依赖注入</h2><p>我们直接使用.net core 提供的依赖注入，依次注入DbContext、UnitOfWork和Repository。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;注入DbContext</span><br><span class="line">services.AddDbContext&lt;UnitOfWorkDbContext&gt;(</span><br><span class="line">    options &#x3D;&gt;options.UseSqlServer(</span><br><span class="line">    Configuration.GetConnectionString(&quot;DefaultConnection&quot;)));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注入Uow依赖</span><br><span class="line">services.AddScoped&lt;IUnitOfWork, UnitOfWork&lt;UnitOfWorkDbContext&gt;&gt;();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;注入泛型仓储</span><br><span class="line">services.AddTransient(typeof(IRepository&lt;&gt;), typeof(EfCoreRepository&lt;&gt;));</span><br><span class="line">services.AddTransient(typeof(IRepository&lt;,&gt;), typeof(EfCoreRepository&lt;,&gt;));</span><br></pre></td></tr></table></figure>
<p>这里我们限定了DbContext和UnitOfWork的生命周期为<code>Scoped</code>，从而确保每次请求共用同一个对象。如何理解呢？就是<strong>整个调用链</strong>上的需要注入的同类型对象，使用是同一个类型实例。</p>
<h2 id="4-7-使用UOW"><a href="#4-7-使用UOW" class="headerlink" title="4.7. 使用UOW"></a>4.7. 使用UOW</h2><p>下面我们就来实际看一看如何使用UOW，我们定义一个应用服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">namespace UnitOfWork.Customer</span><br><span class="line">&#123;</span><br><span class="line">    public class CustomerAppService : ICustomerAppService</span><br><span class="line">    &#123;</span><br><span class="line">        private readonly IUnitOfWork _unitOfWork;</span><br><span class="line">        private readonly IRepository&lt;Customer&gt; _customerRepository;</span><br><span class="line">        private readonly IRepository&lt;ShoppingCart.ShoppingCart&gt; _shoppingCartRepository;</span><br><span class="line"></span><br><span class="line">        public CustomerAppService(IRepository&lt;ShoppingCart&gt; shoppingCartRepository, </span><br><span class="line">            IRepository&lt;Customer&gt; customerRepository, IUnitOfWork unitOfWork)</span><br><span class="line">        &#123;</span><br><span class="line">            _shoppingCartRepository &#x3D; shoppingCartRepository;</span><br><span class="line">            _customerRepository &#x3D; customerRepository;</span><br><span class="line">            _unitOfWork &#x3D; unitOfWork;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void CreateCustomer(Customer customer)</span><br><span class="line">        &#123;</span><br><span class="line">            _customerRepository.Insert(customer);&#x2F;&#x2F;创建客户</span><br><span class="line"></span><br><span class="line">            var cart &#x3D; new ShoppingCart.ShoppingCart() &#123;CustomerId &#x3D; customer.Id&#125;;</span><br><span class="line">            _shoppingCartRepository.Insert(cart);&#x2F;&#x2F;创建购物车</span><br><span class="line">            _unitOfWork.SaveChanges();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上案例，我们可以看出，我们只需要通过构造函数依赖注入需要的仓储和Uow即可完成对多个仓储的持久化操作。</p>
<h1 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h1><p>对于Uow模式，有很多种实现方式，大多过于复杂抽象。EF和EF Core本身已经实现了Uow模式，所以在实现时，我们应避免不必要的抽象来降低系统的复杂度。</p>
<p>最后，重申一下：<br><strong>Uow模式是用来管理仓储处理事务的，仓储用来解耦的（领域层与基础设施层）。而基于EF实现Uow模式的关键：确保Uow和Reopository之间共享同一个DbContext实例。</strong></p>
<p>最后附上基于.Net Core和EF Core实现的源码： <a href="https://github.com/yanshengjie/UnitOfWork" target="_blank" rel="noopener">GitHub–UnitOfWork</a></p>
]]></content>
      <categories>
        <category>知多少</category>
      </categories>
      <tags>
        <tag>.NET Core</tag>
        <tag>UOW</tag>
      </tags>
  </entry>
  <entry>
    <title>WinDbg分析高内存占用问题</title>
    <url>/post/use-windbg-to-analyze-high-memory-issue/</url>
    <content><![CDATA[<p><img src="/images/use-windbg-to-analyze-high-memory-issue/2799767-0f1cf31d06374907.png" alt=""></p>
<h1 id="1-问题简介"><a href="#1-问题简介" class="headerlink" title="1. 问题简介"></a>1. 问题简介</h1><p>最近产品发布大版本补丁更新，一商超客户升级后，反馈系统经常奔溃，导致超市的收银系统无法正常收银，现场排队付款的顾客更是抱怨声声。为了缓解现场的情况， 客户都是手动回收IIS应用程序池才能解决。<br><img src="/images/use-windbg-to-analyze-high-memory-issue/2799767-fc4cfcbf08a0df04.png" alt="现场排队情况"></p>
<p>这样的后果是很严重的，接到反馈，第一时间想到的是加内存吧，这样最快。但是客户从8G–&gt;16G–&gt;32G，只是延长了每次奔溃的时间，但是并没有解决系统卡顿的问题。到这里，也基本猜测了问题所在了，肯定是什么东西一直在吃内存且得不到释放。这种问题，也就只能打Dump分析了。</p>
<h1 id="2-打Dump"><a href="#2-打Dump" class="headerlink" title="2. 打Dump"></a>2. 打Dump</h1><p>远程客户应用服务器，32G内存占用已经消耗了78%，而现场已经反馈收银系统接近奔溃了，要求先强制回收内存。反正也要奔溃了，先打Dump再说吧。<br>（PS：打Dump会挂起进程，导致应用无法响应！而打Dump的耗时，也是根据当时进程的内存占用有关，内存占用越大，耗时越久。）<br>打开任务管理器，选择对应的IIS进程，右键创建转储文件（Dump）。<br><img src="/images/use-windbg-to-analyze-high-memory-issue/2799767-fe85d20242c6f435.png" alt="打Dump"></p>
<p>结果，Dump文件是生成的，结果当分析的时候，发现Windbg提示Dump无效。说明Dump文件创建的有问题。观察任务管理器，发现内存占用一下就降下来了，原来是之前的进程直接奔溃了，重启了一个W3WP进程。</p>
<p>既然直接从任务管理器无法创建，就使用第三方工具收集Dump吧。经过Goggle，找到一款很好用的Dump收集工具<a href="https://docs.microsoft.com/zh-cn/sysinternals/downloads/procdump" target="_blank" rel="noopener">ProcDump</a>，是一个命令行应用，其主要用途是监视应用程序的CPU或内存峰值并在峰值期间生成Dump。</p>
<p>因为是高内存占用问题，我们使用以下命令来抓取dump：<br>（PS：可以使用进程名称，也可以使用进程ID来指定要创建Dump的进程。当有多个相同名称的进程时，必须使用进程ID来指定！）</p>
<blockquote>
<p>procdump w3wp -m 20480 -o D:\Dumps （当内存超过20G时抓取一个w3wp进程的MiniDump）</p>
</blockquote>
<p>上面就是我踩得第一个坑，因为默认抓取的是MiniDump，很快就抓下来，文件也很小，正在我得意的时候，Windbg加载Dump分析的时候，发现包含的信息很少，根本无法进行进一步的分析。</p>
<p>调整创建Dump的命令，添加<code>-ma</code>参数即可创建完整Dump。</p>
<blockquote>
<p>procdump w3wp -ma -m 20480 -o D:\Dumps （当内存超过20G时抓取一个w3wp进程的完整Dump）</p>
</blockquote>
<p>结果再一次，当内存占用到达20G，占比80%的时候，Dump再次创建失败，提示：<code>Procdump Error writing dump file</code>。再一次感觉到绝望。不过至少有错误提示，Google一把，果然存在天涯沦落人。<a href="https://stackoverflow.com/questions/39936971/procdump-error-writing-dump-file-0x80070005-error-0x80070005-2147024891-acc" target="_blank" rel="noopener">Procdump Error writing dump file: 0x80070005 Error 0x80070005 (-2147024891): Access is denied</a>。大致的意思是说，当90S内Dump文件没有成功创建的话（也就意味着w3wp进程被挂起了90s），IIS检测到w3wp进程挂起超过90s没有响应就会终止进程，重新创建一个新的进程。好嘛，真是处处是坑。</p>
<p>这个坑，也让我开始真正停下来思考问题。<strong>罗马不是一日建成的，内存也不是一下撑爆的。</strong>我干嘛死脑筋非要到内存占用超过80%才去打Dump呢呢呢？？？！</p>
<p>焕然大悟，如醍醐灌顶。</p>
<blockquote>
<p>procdump w3wp -ma -m 8000 -o D:\Dumps （当内存超过8000M时抓取一个w3wp进程的完整Dump，并输出到D:\Dumps文件夹）</p>
</blockquote>
<p>此时内存占用在40%左右，这次Dump终于成功创建了。</p>
<h1 id="3-分析Dump"><a href="#3-分析Dump" class="headerlink" title="3.分析Dump"></a>3.分析Dump</h1><p>分析Dump，上WinDbg。如果对WinDbg不理解，可以看我这篇<a href="https://www.jianshu.com/p/57f0ab8702b5" target="_blank" rel="noopener">WinDbg学习笔记</a>。</p>
<p>接下来就是一通命令乱敲，我尽量解释清晰。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !dumpheap -stat &#x2F;&#x2F;检查当前所有托管类型的统计信息</span><br><span class="line">....</span><br><span class="line">00007ffdb9387a98   777101     69462436 System.Char[]</span><br><span class="line">00007ffdb938c988   588917    115563505 System.Byte[]</span><br><span class="line">00007ffdb9389220  1026406    119828936 System.Int32[]</span><br><span class="line">00007ffdb93516a8   663559    128819040 System.Collections.Generic.Dictionary&#96;2+Entry[[System.String, mscorlib],[System.Object, mscorlib]][]</span><br><span class="line">00000218c6c30a80  6436865    197832116      Free</span><br><span class="line">00007ffdae9cc240    23171    273333144 System.Collections.Generic.HashSet&#96;1+Slot[[System.String, mscorlib]][]</span><br><span class="line">00007ffdb9391f28 13885170    333244080 System.Boolean</span><br><span class="line">00007ffd5c24a068 14003455    560138200 Kingdee.BOS.JSON.JSONArray</span><br><span class="line">00007ffdb9386fc0 14373648   1393615400 System.Object[]</span><br><span class="line">00007ffdb9386948 76146065   4000287202 System.String</span><br><span class="line">Total 138435970 objects</span><br></pre></td></tr></table></figure>
<p>使用<code>dumpheap -stat</code>命令查看当前所有托管类型的统计信息。从输出的结果来看：</p>
<ol>
<li>其中占用内存最多当属<code>System.String</code>类型，接近4G的大小（是不是很吃惊？!）。</li>
<li>其次<code>System.Object[]</code>类型占有1.3G大小。</li>
<li><code>Kingdee.BOS.JSON.JSONArray</code>类型也大概占用了560M。</li>
</ol>
<p>我们首先来分析占用最多的<code>System.String</code>类型，看看有什么发现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !dumpheap -mt 00007ffdb9386948 -min 200 &#x2F;&#x2F;查看200byte以上的string</span><br><span class="line">Address               MT     Size</span><br><span class="line">...</span><br><span class="line">0000021bcbaf5158 00007ffdb9386948     1140</span><br><span class="line">0000021d375d1038 00007ffdb9386948   149698     </span><br><span class="line">0000021d375f5920 00007ffdb9386948   149698     </span><br><span class="line">0000021d3765b138 00007ffdb9386948   149706     </span><br><span class="line">0000021d37f739c8 00007ffdb9386948   217120     </span><br><span class="line">0000021d37fa8a08 00007ffdb9386948   190162     </span><br><span class="line">0000021d38047330 00007ffdb9386948  1224698     </span><br><span class="line">0000021d3829d348 00007ffdb9386948  1224698     </span><br><span class="line">0000021d386bd678 00007ffdb9386948  2610994     </span><br><span class="line">0000021d38bb8500 00007ffdb9386948  2610994     </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Statistics:</span><br><span class="line">              MT    Count    TotalSize Class Name</span><br><span class="line">00007ffdb9386948    10991     76632628 System.String</span><br><span class="line">Total 10991 objects</span><br></pre></td></tr></table></figure>
<p>从上面的输出可以发现：</p>
<ol>
<li>单个<code>System.String</code>类型最大占用2M以上。</li>
<li>超过200byte的字节的大小的<code>System.String</code>总大小也不过76M。（所以我们也不必深究大的String对象。）</li>
</ol>
<p>那我们索性挑一个小点的对象来看看存储的是什么字符串，来满足一下我们的好奇心。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.000&gt; !do 0000021bcbaf5158 &#x2F;&#x2F;使用!do命令查看一个对象的内容</span><br><span class="line">Name:        System.String</span><br><span class="line">MethodTable: 00007ffdb9386948</span><br><span class="line">EEClass:     00007ffdb8c850e0</span><br><span class="line">Size:        1140(0x474) bytes</span><br><span class="line">File:        C:\Windows\Microsoft.Net\assembly\GAC_64\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll</span><br><span class="line">String:      5b13710029d012False2052_T_BD_MATERIAL_MATERIAL.FAuxPropertyIdFBaseUnitIdFCategoryIDFChargeIDFCheckIncomingFDefaultVendorFErpClsIDFInvPtyIdFIsAffectPlanFIsAffectPlan1FIsBatchManageFIsComControlFIsEnableFIsEnable1FIsExpParToFlotFIsInventoryFIsPRFIsReturnMaterialFIsSourceControlFIsVmiBusinessFNameFNumberFPlanModeFPurchasePriceUnitIdFPurchaseUnitIdFPurPriceURNomFPurPriceURNumFPurURNomFPurURNumFReceiveAdvanceDaysFReceiveDelayDaysFReceiveMaxScaleFReceiveMinScaleFSalePriceUnitIdFSaleUnitIdFSpecificationFStockIdFStockPlaceIdFStoreUnitIDFTaxTypeFUseOrgId111193</span><br><span class="line">Fields:</span><br><span class="line">              MT    Field   Offset                 Type VT     Attr            Value Name</span><br><span class="line">00007ffdb9389288  400026f        8         System.Int32  1 instance              557 m_stringLength</span><br><span class="line">00007ffdb9387b00  4000270        c          System.Char  1 instance               35 m_firstChar</span><br><span class="line">00007ffdb9386948  4000274       90        System.String  0   shared           static Empty</span><br><span class="line">                                 &gt;&gt; Domain:Value  00000218c6c4d220:NotInit  0000021d52d81840:NotInit  &lt;&lt;</span><br></pre></td></tr></table></figure>
<p>似乎是基础资料字段信息。那接下来使用<code>!gcroot</code>命令查看其对应的GC根，看看到底是什么对象持有其引用，导致占用内存得不到释放。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !gcroot 0000021bcbaf5158 &#x2F;&#x2F;使用!gcroot 查看一个对象的gc根</span><br><span class="line">HandleTable:</span><br><span class="line">    00000218c6ff15e8 (pinned handle)</span><br><span class="line">    -&gt; 0000021cc75ebe68 System.Object[]</span><br><span class="line">    -&gt; 0000021bc7629a10 Kingdee.BOS.Cache.KCacheManagerFactory</span><br><span class="line">    -&gt; 0000021bc7629ab8 System.Collections.Generic.Dictionary&#96;2[[System.String, mscorlib],[Kingdee.BOS.Cache.AbstractKCacheManager, Kingdee.BOS]]</span><br><span class="line">    -&gt; 0000021c4da6fa48 System.Collections.Generic.Dictionary&#96;2+Entry[[System.String, mscorlib],[Kingdee.BOS.Cache.AbstractKCacheManager, Kingdee.BOS]][]</span><br><span class="line">    -&gt; 00000218c83861b8 Kingdee.BOS.Cache.KCacheManager</span><br><span class="line">    -&gt; 00000218c8386630 Kingdee.BOS.Cache.ECache.ECacheManager</span><br><span class="line">    -&gt; 00000218c83866e8 System.Collections.Concurrent.ConcurrentDictionary&#96;2[[System.String, mscorlib],[System.Collections.Generic.HashSet&#96;1[[System.String, mscorlib]], System.Core]]</span><br><span class="line">    -&gt; 0000021bcbae0c70 System.Collections.Concurrent.ConcurrentDictionary&#96;2+Tables[[System.String, mscorlib],[System.Collections.Generic.HashSet&#96;1[[System.String, mscorlib]], System.Core]]</span><br><span class="line">    -&gt; 0000021bcbad0128 System.Collections.Concurrent.ConcurrentDictionary&#96;2+Node[[System.String, mscorlib],[System.Collections.Generic.HashSet&#96;1[[System.String, mscorlib]], System.Core]][]</span><br><span class="line">    -&gt; 0000021bcbb34bf8 System.Collections.Concurrent.ConcurrentDictionary&#96;2+Node[[System.String, mscorlib],[System.Collections.Generic.HashSet&#96;1[[System.String, mscorlib]], System.Core]]</span><br><span class="line">    -&gt; 0000021bcbada790 System.Collections.Concurrent.ConcurrentDictionary&#96;2+Node[[System.String, mscorlib],[System.Collections.Generic.HashSet&#96;1[[System.String, mscorlib]], System.Core]]</span><br><span class="line">    -&gt; 0000021a49766460 System.Collections.Generic.HashSet&#96;1[[System.String, mscorlib]]</span><br><span class="line">    -&gt; 00000219540976b0 System.Collections.Generic.HashSet&#96;1+Slot[[System.String, mscorlib]][]</span><br><span class="line">    -&gt; 0000021bcbaf5158 System.String</span><br><span class="line"></span><br><span class="line">Found 1 unique roots (run &#39;!GCRoot -all&#39; to see all roots).</span><br></pre></td></tr></table></figure>

<p>从以上输出可以看出：</p>
<ol>
<li>该String类型被一个Hashset所持有。</li>
<li>从<code>Cache</code>关键字可以看出该String类型是被<strong>缓存</strong>所持有。</li>
</ol>
<p>分析到这里，我们大致可以得出一个结论：</p>
<blockquote>
<p>String类型占用4G内存，绝大多数是由缓存所占用，才导致String类型得不到释放。</p>
</blockquote>
<p>那我们是不是可以猜测<strong>内存占用持续走高是不是被缓存撑爆的呢？</strong>。</p>
<p>带着这个疑问我们来继续分析下<code>Kingdee.BOS.JSON.JSONArray</code>类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !dumpheap -mt 00007ffd5c24a068 &#x2F;&#x2F;输出托管堆上的所有JSONArray对象</span><br><span class="line">         Address               MT     Size</span><br><span class="line">....</span><br><span class="line">0000021975972b48 00007ffd5c24a068       40     </span><br><span class="line">00000218c933f060 00007ffd5c24a068       40     </span><br><span class="line">00000218c7605990 00007ffd5c24a068       40     </span><br><span class="line">00000218c7605af0 00007ffd5c24a068       40     </span><br><span class="line">00000218c7605c50 00007ffd5c24a068       40     </span><br><span class="line">00000218c7605e18 00007ffd5c24a068       40     </span><br><span class="line">00000218c7605fa0 00007ffd5c24a068       40     </span><br><span class="line">00000218c7606198 00007ffd5c24a068       40     </span><br><span class="line">00000218c7606338 00007ffd5c24a068       40     </span><br><span class="line">00000218c76064b0 00007ffd5c24a068       40     </span><br><span class="line">User interrupt.</span><br></pre></td></tr></table></figure>
<p>从输出结果来看：</p>
<ol>
<li>满屏都是40byte的JSONArray。只能使用<code>Ctrl+Break</code>命令中止输出。</li>
</ol>
<p>但为了保险期间，我们来验证下有没有100byte以上的<code>JSONArray</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !dumpheap -mt 00007ffd5c24a068 -min 100</span><br><span class="line">         Address               MT     Size</span><br><span class="line"></span><br><span class="line">Statistics:</span><br><span class="line">              MT    Count    TotalSize Class Name</span><br><span class="line">Total 0 objects</span><br></pre></td></tr></table></figure>
<p>这时我们可以大胆猜测所有的<code>JSONArray</code>对象都是40byte。从而可以得出另一个猜测<strong>占用560M内存的JSONArray，都具有相似的对象结构。</strong>接下来我们来验证这个猜测。随机选择几个对象，看看其内容具体是什么。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !DumpObj &#x2F;d 0000021975972b48  &#x2F;&#x2F;查看第一个JSONArray</span><br><span class="line">Name:        System.Object[]</span><br><span class="line">MethodTable: 00007ffdb9386fc0</span><br><span class="line">EEClass:     00007ffdb8d4aa00</span><br><span class="line">Size:        88(0x58) bytes</span><br><span class="line">Array:       Rank 1, Number of elements 8, Type CLASS (Print Array)</span><br><span class="line">Fields:</span><br><span class="line">None</span><br></pre></td></tr></table></figure>
<p>从输出可以看出：</p>
<ol>
<li>JSONArray实质是<code>System.Object[]</code>类型。</li>
<li>对应的<code>MethodTable: 00007ffdb9386fc0</code>。</li>
</ol>
<p>如果你记性好的话，我们应当还记得占用内存第二多的就是这个<code>System.Object[]</code>类型，占用1.3G。翻到上面，你可以发现其MethodTable和上面的统计信息是一致的。<br>（PS：到这里我们是不是可以猜测：<strong><code>System.Object[]</code>占用的内存无法释放，就是由于被<code>JSONArray</code>持有引用导致的呢？</strong>）</p>
<p>既然是数组，就使用<code>!DumpArray</code> 命令来解开数组的面纱。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !DumpArray &#x2F;d 0000021975972b48 </span><br><span class="line">Name:        System.Object[]</span><br><span class="line">MethodTable: 00007ffdb9386fc0</span><br><span class="line">EEClass:     00007ffdb8d4aa00</span><br><span class="line">Size:        88(0x58) bytes</span><br><span class="line">Array:       Rank 1, Number of elements 8, Type CLASS</span><br><span class="line">Element Methodtable: 00007ffdb9386f28</span><br><span class="line">[0] 0000021975972a08</span><br><span class="line">[1] 0000021975972a70</span><br><span class="line">[2] 0000021975972a40</span><br><span class="line">[3] 0000021ac75e87b8</span><br><span class="line">[4] 0000021975972b10</span><br><span class="line">[5] 0000021975972ba0</span><br><span class="line">[6] null</span><br><span class="line">[7] null</span><br><span class="line">0:000&gt; !DumpObj &#x2F;d 0000021975972a08</span><br><span class="line">Name:        System.String</span><br><span class="line">MethodTable: 00007ffdb9386948</span><br><span class="line">EEClass:     00007ffdb8c850e0</span><br><span class="line">Size:        54(0x36) bytes</span><br><span class="line">File:        C:\Windows\Microsoft.Net\assembly\GAC_64\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll</span><br><span class="line">String:      555d8ca25a6261</span><br><span class="line">Fields:7</span><br><span class="line">              MT    Field   Offset                 Type VT     Attr            Value Name</span><br><span class="line">00007ffdb9389288  400026f        8         System.Int32  1 instance               14 m_stringLength</span><br><span class="line">00007ffdb9387b00  4000270        c          System.Char  1 instance               35 m_firstChar</span><br><span class="line">00007ffdb9386948  4000274       90        System.String  0   shared           static Empty</span><br><span class="line">                                 &gt;&gt; Domain:Value  00000218c6c4d220:NotInit  0000021d52d81840:NotInit  &lt;&lt;</span><br></pre></td></tr></table></figure>
<p>从以上输出可以看出，其共有8个子项，我们再随机挑几个子项看看是什么内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; !DumpObj &#x2F;d 0000021975972a70</span><br><span class="line">Name:        System.String</span><br><span class="line">MethodTable: 00007ffdb9386948</span><br><span class="line">EEClass:     00007ffdb8c850e0</span><br><span class="line">Size:        42(0x2a) bytes</span><br><span class="line">File:        C:\Windows\Microsoft.Net\assembly\GAC_64\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll</span><br><span class="line">String:      FHTZDLB</span><br><span class="line">Fields:</span><br><span class="line">              MT    Field   Offset                 Type VT     Attr            Value Name</span><br><span class="line">00007ffdb9389288  400026f        8         System.Int32  1 instance                8 m_stringLength</span><br><span class="line">00007ffdb9387b00  4000270        c          System.Char  1 instance               50 m_firstChar</span><br><span class="line">00007ffdb9386948  4000274       90        System.String  0   shared           static Empty</span><br><span class="line">                                 &gt;&gt; Domain:Value  00000218c6c4d220:NotInit  0000021d52d81840:NotInit  &lt;&lt;</span><br><span class="line">0:000&gt; !DumpObj &#x2F;d 0000021975972a40</span><br><span class="line">Name:        System.String</span><br><span class="line">MethodTable: 00007ffdb9386948</span><br><span class="line">EEClass:     00007ffdb8c850e0</span><br><span class="line">Size:        42(0x2a) bytes</span><br><span class="line">File:        C:\Windows\Microsoft.Net\assembly\GAC_64\mscorlib\v4.0_4.0.0.0__b77a5c561934e089\mscorlib.dll</span><br><span class="line">String:      发货通知单列表</span><br><span class="line">Fields:</span><br><span class="line">              MT    Field   Offset                 Type VT     Attr            Value Name</span><br><span class="line">00007ffdb9389288  400026f        8         System.Int32  1 instance                8 m_stringLength</span><br><span class="line">00007ffdb9387b00  4000270        c          System.Char  1 instance             6279 m_firstChar</span><br><span class="line">00007ffdb9386948  4000274       90        System.String  0   shared           static Empty</span><br><span class="line">                                 &gt;&gt; Domain:Value  00000218c6c4d220:NotInit  0000021d52d81840:NotInit  &lt;&lt;</span><br></pre></td></tr></table></figure>
<p>我们可以看到一个字符串内容是<code>FHTZDLB</code>，另一个是<code>发货通知单列表</code>。看到这，我立马就条件反射的想到，这不就是我们的菜单信息嘛。为了验证我的想法，连续查看几个<code>JSONArray</code>，都是相似的内容。</p>
<p>这时，我们继续发扬敢猜敢做的精神。<strong>是不是内存被菜单缓存撑爆的？！</strong></p>
<p>为了验证这一猜测，我们继续从Dump中寻找佐证。使用<code>~* e!clrstack</code>来看看所有线程的调用堆栈吧。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0:000&gt; ~* e!clrstack</span><br><span class="line">OS Thread Id: 0x11dc (0)</span><br><span class="line">Unable to walk the managed stack. The current thread is likely not a </span><br><span class="line">managed thread. You can run !threads to get a list of managed threads in</span><br><span class="line">the process</span><br><span class="line">Failed to start stack walk: 80070057</span><br><span class="line">OS Thread Id: 0x2b2c (28)</span><br><span class="line">        Child SP               IP Call Site</span><br><span class="line">00000076cff7ecc8 00007ffdca2e6bf4 [HelperMethodFrame_1OBJ: 00000076cff7ecc8] System.Threading.WaitHandle.WaitMultiple(System.Threading.WaitHandle[], Int32, Boolean, Boolean)</span><br><span class="line">00000076cff7ee00 00007ffdb91af67c System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[], Int32, Boolean) [f:\dd\ndp\clr\src\BCL\system\threading\waithandle.cs @ 454]</span><br><span class="line">00000076cff7ee60 00007ffdb201b2fb System.Net.TimerThread.ThreadProc()</span><br><span class="line">00000076cff7ef10 00007ffdb915ca72 System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean) [f:\dd\ndp\clr\src\BCL\system\threading\executioncontext.cs @ 954]</span><br><span class="line">00000076cff7efe0 00007ffdb915c904 System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean) [f:\dd\ndp\clr\src\BCL\system\threading\executioncontext.cs @ 902]</span><br><span class="line">00000076cff7f010 00007ffdb915c8c2 System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object) [f:\dd\ndp\clr\src\BCL\system\threading\executioncontext.cs @ 891]</span><br><span class="line">00000076cff7f060 00007ffdb9196472 System.Threading.ThreadHelper.ThreadStart() [f:\dd\ndp\clr\src\BCL\system\threading\thread.cs @ 111]</span><br><span class="line">00000076cff7f2b8 00007ffdbb4f6793 [GCFrame: 00000076cff7f2b8] </span><br><span class="line">00000076cff7f608 00007ffdbb4f6793 [DebuggerU2MCatchHandlerFrame: 00000076cff7f608] </span><br><span class="line">00000076cff7f798 00007ffdbb4f6793 [ContextTransitionFrame: 00000076cff7f798] </span><br><span class="line">00000076cff7f9c8 00007ffdbb4f6793 [DebuggerU2MCatchHandlerFrame: 00000076cff7f9c8] </span><br><span class="line"></span><br><span class="line">OS Thread Id: 0x1bd4 (133)</span><br><span class="line">        Child SP               IP Call Site</span><br><span class="line">GetFrameContext failed: 1</span><br><span class="line">0000000000000000 0000000000000000 </span><br><span class="line">OS Thread Id: 0x1a98 (134)</span><br><span class="line">        Child SP               IP Call Site</span><br><span class="line">00000076dbdbcc88 00007ffdca2e6124 [InlinedCallFrame: 00000076dbdbcc88] .SNIReadSyncOverAsync(SNI_ConnWrapper*, SNI_Packet**, Int32)</span><br><span class="line">00000076dbdbcc88 00007ffdaaaf5dd4 [InlinedCallFrame: 00000076dbdbcc88] .SNIReadSyncOverAsync(SNI_ConnWrapper*, SNI_Packet**, Int32)</span><br><span class="line">00000076dbdbcc60 00007ffdaaaf5dd4 DomainNeutralILStubClass.IL_STUB_PInvoke(SNI_ConnWrapper*, SNI_Packet**, Int32)</span><br><span class="line">00000076dbdbcd10 00007ffdaab08fe3 SNINativeMethodWrapper.SNIReadSyncOverAsync(System.Runtime.InteropServices.SafeHandle, IntPtr ByRef, Int32)</span><br><span class="line">00000076dbdbcd70 00007ffdaabe0ae0 System.Data.SqlClient.TdsParserStateObject.ReadSniSyncOverAsync()</span><br><span class="line">00000076dbdbcdd0 00007ffdaabe09dd System.Data.SqlClient.TdsParserStateObject.TryReadNetworkPacket()</span><br><span class="line">00000076dbdbce10 00007ffdaabdf7f5 System.Data.SqlClient.TdsParserStateObject.TryPrepareBuffer()</span><br><span class="line">00000076dbdbce50 00007ffdaabdfa0e System.Data.SqlClient.TdsParserStateObject.TryReadByte(Byte ByRef)</span><br><span class="line">00000076dbdbce90 00007ffdaabc7daa System.Data.SqlClient.TdsParser.TryRun(System.Data.SqlClient.RunBehavior, System.Data.SqlClient.SqlCommand, System.Data.SqlClient.SqlDataReader, System.Data.SqlClient.BulkCopySimpleResultSet, System.Data.SqlClient.TdsParserStateObject, Boolean ByRef)</span><br><span class="line">00000076dbdbcff0 00007ffdaabbb3c7 System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()</span><br><span class="line">00000076dbdbd050 00007ffdaabb8325 System.Data.SqlClient.SqlDataReader.get_MetaData()</span><br><span class="line">00000076dbdbd0a0 00007ffdaab3be73 System.Data.SqlClient.SqlCommand.FinishExecuteReader(System.Data.SqlClient.SqlDataReader, System.Data.SqlClient.RunBehavior, System.String, Boolean, Boolean)</span><br><span class="line">00000076dbdbd110 00007ffdaab3b75f System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(System.Data.CommandBehavior, System.Data.SqlClient.RunBehavior, Boolean, Boolean, Int32, System.Threading.Tasks.Task ByRef, Boolean, Boolean, System.Data.SqlClient.SqlDataReader, Boolean)</span><br><span class="line">00000076dbdbd1f0 00007ffdaab3a763 System.Data.SqlClient.SqlCommand.RunExecuteReader(System.Data.CommandBehavior, System.Data.SqlClient.RunBehavior, Boolean, System.String, System.Threading.Tasks.TaskCompletionSource&#96;1, Int32, System.Threading.Tasks.Task ByRef, Boolean ByRef, Boolean, Boolean)</span><br><span class="line">00000076dbdbd2c0 00007ffdaab3a49b System.Data.SqlClient.SqlCommand.RunExecuteReader(System.Data.CommandBehavior, System.Data.SqlClient.RunBehavior, Boolean, System.String)</span><br><span class="line">00000076dbdbd360 00007ffdaab35cc6 System.Data.SqlClient.SqlCommand.ExecuteReader(System.Data.CommandBehavior, System.String)</span><br><span class="line">00000076dbdbd3f0 00007ffd5c517ead Kingdee.BOS.App.Data.AbstractDatabase.DoExecuteReader(System.Data.Common.DbCommand, System.Data.CommandBehavior)</span><br><span class="line">00000076dbdbd450 00007ffd5c515ebb Kingdee.BOS.App.Data.AbstractDatabase.ExecuteReader(System.Data.Common.DbCommand, System.Collections.Generic.IEnumerable&#96;1, System.Data.CommandBehavior, Boolean)</span><br><span class="line">00000076dbdbd4d0 00007ffd5c4fd6f2 Kingdee.BOS.App.Data.AbstractDatabase.ExecuteReader(System.Data.Common.DbCommand, System.Collections.Generic.IEnumerable&#96;1, System.Data.CommandBehavior)</span><br><span class="line">00000076dbdbd500 00007ffd5c4e31b1 Kingdee.BOS.App.Data.DBUtils.ExecuteReader(Kingdee.BOS.Context, System.String, System.Collections.Generic.IEnumerable&#96;1, System.Data.CommandType, System.Data.CommandBehavior, Boolean)</span><br><span class="line">00000076dbdbd570 00007ffd5c51d2a7 Kingdee.BOS.App.Data.DBUtils.ExecuteReader(Kingdee.BOS.Context, System.String, System.Collections.Generic.IEnumerable&#96;1, System.Data.CommandType, Boolean)</span><br><span class="line">00000076dbdbd5b0 00007ffd5c51d2fc Kingdee.BOS.App.Data.DBUtils.ExecuteReader(Kingdee.BOS.Context, System.String, System.Data.CommandType, Boolean)</span><br><span class="line">00000076dbdbd5e0 00007ffd5c51d341 Kingdee.BOS.App.Data.DBUtils.ExecuteReader(Kingdee.BOS.Context, System.String)</span><br><span class="line">00000076dbdbd610 00007ffd5ca5a5d4 Kingdee.BOS.App.Core.MainConsole.MainConsoleServer.GetSearchMenuData(Kingdee.BOS.Context, System.String, System.Collections.Generic.HashSet&#96;1 ByRef, System.Collections.Generic.HashSet&#96;1 ByRef)</span><br><span class="line">00000076dbdbd7d0 00007ffd5ca58164 Kingdee.BOS.App.Core.MainConsole.MainConsoleServer.GetMenuArrayForCache(Kingdee.BOS.Context)</span><br><span class="line">00000076dbdbda78 00007ffdbb4f6793 [DebuggerU2MCatchHandlerFrame: 00000076dbdbda78] </span><br><span class="line">00000076dbdbddb8 00007ffdbb4f6793 [HelperMethodFrame_PROTECTOBJ: 00000076dbdbddb8] System.RuntimeMethodHandle.InvokeMethod(System.Object, System.Object[], System.Signature, Boolean)</span><br><span class="line">00000076dbdbdf30 00007ffdb914b690 System.Reflection.RuntimeMethodInfo.UnsafeInvokeInternal(System.Object, System.Object[], System.Object[]) [f:\dd\ndp\clr\src\BCL\system\reflection\methodinfo.cs @ 761]</span><br><span class="line">00000076dbdbdfa0 00007ffdb9142922 System.Reflection.RuntimeMethodInfo.Invoke(System.Object, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo) [f:\dd\ndp\clr\src\BCL\system\reflection\methodinfo.cs @ 735]</span><br><span class="line">00000076dbdbe020 00007ffdb9143f22 System.Reflection.MethodBase.Invoke(System.Object, System.Object[]) [f:\dd\ndp\clr\src\BCL\system\reflection\methodbase.cs @ 211]</span><br><span class="line">00000076dbdbe060 00007ffd5c61990c Microsoft.Practices.Unity.InterceptionExtension.InterceptingRealProxy+c__DisplayClass1.b__0(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextInterceptionBehaviorDelegate)</span><br><span class="line">00000076dbdbe160 00007ffd5c619477 Microsoft.Practices.Unity.InterceptionExtension.PolicyInjectionBehavior+c__DisplayClass1.b__0(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbdbe200 00007ffd5c61cbc4 Kingdee.BOS.Cache.KCacheMethodCallHandler.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbdbe350 00007ffd5c61b10b Kingdee.BOS.Performance.Publisher.PerformanceCallHandler.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbdbe3e0 00007ffd5c61b10b Kingdee.BOS.Performance.Publisher.PerformanceCallHandler.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbdbe470 00007ffd5c61b10b Kingdee.BOS.Performance.Publisher.PerformanceCallHandler.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbdbe500 00007ffd5c61936d Microsoft.Practices.Unity.InterceptionExtension.HandlerPipeline.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.InvokeHandlerDelegate)</span><br><span class="line">00000076dbdbe590 00007ffd5c618999 Microsoft.Practices.Unity.InterceptionExtension.PolicyInjectionBehavior.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextInterceptionBehaviorDelegate)</span><br><span class="line">00000076dbdbe620 00007ffd5c61845d Microsoft.Practices.Unity.InterceptionExtension.InterceptionBehaviorPipeline.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.InvokeInterceptionBehaviorDelegate)</span><br><span class="line">00000076dbdbe6b0 00007ffd5c617002 Microsoft.Practices.Unity.InterceptionExtension.InterceptingRealProxy.Invoke(System.Runtime.Remoting.Messaging.IMessage)</span><br><span class="line">00000076dbdbe790 00007ffdb911190c System.Runtime.Remoting.Proxies.RealProxy.PrivateInvoke(System.Runtime.Remoting.Proxies.MessageData ByRef, Int32) [f:\dd\ndp\clr\src\BCL\system\runtime\remoting\realproxy.cs @ 823]</span><br><span class="line">00000076dbdbe980 00007ffdbb4f4a02 [TPMethodFrame: 00000076dbdbe980] Kingdee.BOS.Contracts.IMainConsoleServer.GetMenuArrayForCache(Kingdee.BOS.Context)</span><br><span class="line">00000076dbdbec00 00007ffdb91ad436 System.Threading.Tasks.Task.Execute() [f:\dd\ndp\clr\src\BCL\system\threading\Tasks\Task.cs @ 2498]</span><br><span class="line">00000076dbdbec40 00007ffdb915ca72 System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean) [f:\dd\ndp\clr\src\BCL\system\threading\executioncontext.cs @ 954]</span><br><span class="line">00000076dbdbed10 00007ffdb915c904 System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object, Boolean) [f:\dd\ndp\clr\src\BCL\system\threading\executioncontext.cs @ 902]</span><br><span class="line">00000076dbdbed40 00007ffdb91ad6dc System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef) [f:\dd\ndp\clr\src\BCL\system\threading\Tasks\Task.cs @ 2827]</span><br><span class="line">00000076dbdbedf0 00007ffdb91acdf3 System.Threading.Tasks.Task.ExecuteEntry(Boolean) [f:\dd\ndp\clr\src\BCL\system\threading\Tasks\Task.cs @ 2767]</span><br><span class="line">00000076dbdbee30 00007ffdb9194882 System.Threading.ThreadPoolWorkQueue.Dispatch() [f:\dd\ndp\clr\src\BCL\system\threading\threadpool.cs @ 820]</span><br><span class="line">00000076dbdbf2c8 00007ffdbb4f6793 [DebuggerU2MCatchHandlerFrame: 00000076dbdbf2c8] </span><br><span class="line">00000076dbdbf458 00007ffdbb4f6793 [ContextTransitionFrame: 00000076dbdbf458] </span><br><span class="line">00000076dbdbf688 00007ffdbb4f6793 [DebuggerU2MCatchHandlerFrame: 00000076dbdbf688] </span><br><span class="line">OS Thread Id: 0x153c (135)</span><br><span class="line">        Child SP               IP Call Site</span><br><span class="line">GetFrameContext failed: 1</span><br><span class="line">0000000000000000 0000000000000000 </span><br><span class="line">OS Thread Id: 0x242c (136)</span><br><span class="line">        Child SP               IP Call Site</span><br><span class="line">GetFrameContext failed: 1</span><br><span class="line">0000000000000000 0000000000000000 </span><br><span class="line">OS Thread Id: 0x153c (135)</span><br><span class="line">        Child SP               IP Call Site</span><br><span class="line">GetFrameContext failed: 1</span><br><span class="line">0000000000000000 0000000000000000 </span><br><span class="line">OS Thread Id: 0x242c (136)</span><br><span class="line">        Child SP               IP Call Site</span><br><span class="line">GetFrameContext failed: 1</span><br><span class="line">0000000000000000 0000000000000000 </span><br><span class="line">OS Thread Id: 0x2a04 (137)</span><br><span class="line">        Child SP               IP Call Site</span><br><span class="line">00000076dbf7af08 00007ffdca2e6124 [InlinedCallFrame: 00000076dbf7af08] .SNIReadSyncOverAsync(SNI_ConnWrapper*, SNI_Packet**, Int32)</span><br><span class="line">00000076dbf7af08 00007ffdaaaf5dd4 [InlinedCallFrame: 00000076dbf7af08] .SNIReadSyncOverAsync(SNI_ConnWrapper*, SNI_Packet**, Int32)</span><br><span class="line">00000076dbf7aee0 00007ffdaaaf5dd4 DomainNeutralILStubClass.IL_STUB_PInvoke(SNI_ConnWrapper*, SNI_Packet**, Int32)</span><br><span class="line">00000076dbf7af90 00007ffdaab08fe3 SNINativeMethodWrapper.SNIReadSyncOverAsync(System.Runtime.InteropServices.SafeHandle, IntPtr ByRef, Int32)</span><br><span class="line">00000076dbf7aff0 00007ffdaabe0ae0 System.Data.SqlClient.TdsParserStateObject.ReadSniSyncOverAsync()</span><br><span class="line">00000076dbf7b050 00007ffdaabe09dd System.Data.SqlClient.TdsParserStateObject.TryReadNetworkPacket()</span><br><span class="line">00000076dbf7b090 00007ffdaabdf7f5 System.Data.SqlClient.TdsParserStateObject.TryPrepareBuffer()</span><br><span class="line">00000076dbf7b0d0 00007ffdaabdfa0e System.Data.SqlClient.TdsParserStateObject.TryReadByte(Byte ByRef)</span><br><span class="line">00000076dbf7b110 00007ffdaabc7daa System.Data.SqlClient.TdsParser.TryRun(System.Data.SqlClient.RunBehavior, System.Data.SqlClient.SqlCommand, System.Data.SqlClient.SqlDataReader, System.Data.SqlClient.BulkCopySimpleResultSet, System.Data.SqlClient.TdsParserStateObject, Boolean ByRef)</span><br><span class="line">00000076dbf7b270 00007ffdaabbb3c7 System.Data.SqlClient.SqlDataReader.TryConsumeMetaData()</span><br><span class="line">00000076dbf7b2d0 00007ffdaabb8325 System.Data.SqlClient.SqlDataReader.get_MetaData()</span><br><span class="line">00000076dbf7b320 00007ffdaab3be73 System.Data.SqlClient.SqlCommand.FinishExecuteReader(System.Data.SqlClient.SqlDataReader, System.Data.SqlClient.RunBehavior, System.String, Boolean, Boolean)</span><br><span class="line">00000076dbf7b390 00007ffdaab3b75f System.Data.SqlClient.SqlCommand.RunExecuteReaderTds(System.Data.CommandBehavior, System.Data.SqlClient.RunBehavior, Boolean, Boolean, Int32, System.Threading.Tasks.Task ByRef, Boolean, Boolean, System.Data.SqlClient.SqlDataReader, Boolean)</span><br><span class="line">00000076dbf7b470 00007ffdaab3a763 System.Data.SqlClient.SqlCommand.RunExecuteReader(System.Data.CommandBehavior, System.Data.SqlClient.RunBehavior, Boolean, System.String, System.Threading.Tasks.TaskCompletionSource&#96;1, Int32, System.Threading.Tasks.Task ByRef, Boolean ByRef, Boolean, Boolean)</span><br><span class="line">00000076dbf7b540 00007ffdaab3a49b System.Data.SqlClient.SqlCommand.RunExecuteReader(System.Data.CommandBehavior, System.Data.SqlClient.RunBehavior, Boolean, System.String)</span><br><span class="line">00000076dbf7b5e0 00007ffdaab35cc6 System.Data.SqlClient.SqlCommand.ExecuteReader(System.Data.CommandBehavior, System.String)</span><br><span class="line">00000076dbf7b670 00007ffd5c517ead Kingdee.BOS.App.Data.AbstractDatabase.DoExecuteReader(System.Data.Common.DbCommand, System.Data.CommandBehavior)</span><br><span class="line">00000076dbf7b6d0 00007ffd5c515ebb Kingdee.BOS.App.Data.AbstractDatabase.ExecuteReader(System.Data.Common.DbCommand, System.Collections.Generic.IEnumerable&#96;1, System.Data.CommandBehavior, Boolean)</span><br><span class="line">00000076dbf7b750 00007ffd5c4fd6f2 Kingdee.BOS.App.Data.AbstractDatabase.ExecuteReader(System.Data.Common.DbCommand, System.Collections.Generic.IEnumerable&#96;1, System.Data.CommandBehavior)</span><br><span class="line">00000076dbf7b780 00007ffd5c4e31b1 Kingdee.BOS.App.Data.DBUtils.ExecuteReader(Kingdee.BOS.Context, System.String, System.Collections.Generic.IEnumerable&#96;1, System.Data.CommandType, System.Data.CommandBehavior, Boolean)</span><br><span class="line">00000076dbf7b7f0 00007ffd5c51d2a7 Kingdee.BOS.App.Data.DBUtils.ExecuteReader(Kingdee.BOS.Context, System.String, System.Collections.Generic.IEnumerable&#96;1, System.Data.CommandType, Boolean)</span><br><span class="line">00000076dbf7b830 00007ffd5c61737a Kingdee.BOS.App.Data.DBUtils.ExecuteReader(Kingdee.BOS.Context, System.String, System.Collections.Generic.List&#96;1)</span><br><span class="line">00000076dbf7b860 00007ffd5c8d2bd7 Kingdee.BOS.App.Core.UserParameterService.GetParamter(Kingdee.BOS.Context, Int64, System.String, System.String)</span><br><span class="line">00000076dbf7bb68 00007ffdbb4f6793 [DebuggerU2MCatchHandlerFrame: 00000076dbf7bb68] </span><br><span class="line">00000076dbf7bea8 00007ffdbb4f6793 [HelperMethodFrame_PROTECTOBJ: 00000076dbf7bea8] System.RuntimeMethodHandle.InvokeMethod(System.Object, System.Object[], System.Signature, Boolean)</span><br><span class="line">00000076dbf7c020 00007ffdb914b690 System.Reflection.RuntimeMethodInfo.UnsafeInvokeInternal(System.Object, System.Object[], System.Object[]) [f:\dd\ndp\clr\src\BCL\system\reflection\methodinfo.cs @ 761]</span><br><span class="line">00000076dbf7c090 00007ffdb9142922 System.Reflection.RuntimeMethodInfo.Invoke(System.Object, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo) [f:\dd\ndp\clr\src\BCL\system\reflection\methodinfo.cs @ 735]</span><br><span class="line">00000076dbf7c110 00007ffdb9143f22 System.Reflection.MethodBase.Invoke(System.Object, System.Object[]) [f:\dd\ndp\clr\src\BCL\system\reflection\methodbase.cs @ 211]</span><br><span class="line">00000076dbf7c150 00007ffd5c61990c Microsoft.Practices.Unity.InterceptionExtension.InterceptingRealProxy+c__DisplayClass1.b__0(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextInterceptionBehaviorDelegate)</span><br><span class="line">00000076dbf7c250 00007ffd5c619477 Microsoft.Practices.Unity.InterceptionExtension.PolicyInjectionBehavior+c__DisplayClass1.b__0(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbf7c2f0 00007ffd5c61cbc4 Kingdee.BOS.Cache.KCacheMethodCallHandler.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbf7c440 00007ffd5c61b10b Kingdee.BOS.Performance.Publisher.PerformanceCallHandler.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbf7c4d0 00007ffd5c61b10b Kingdee.BOS.Performance.Publisher.PerformanceCallHandler.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbf7c560 00007ffd5c61b10b Kingdee.BOS.Performance.Publisher.PerformanceCallHandler.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextHandlerDelegate)</span><br><span class="line">00000076dbf7c5f0 00007ffd5c61936d Microsoft.Practices.Unity.InterceptionExtension.HandlerPipeline.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.InvokeHandlerDelegate)</span><br><span class="line">00000076dbf7c680 00007ffd5c618999 Microsoft.Practices.Unity.InterceptionExtension.PolicyInjectionBehavior.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.GetNextInterceptionBehaviorDelegate)</span><br><span class="line">00000076dbf7c710 00007ffd5c61845d Microsoft.Practices.Unity.InterceptionExtension.InterceptionBehaviorPipeline.Invoke(Microsoft.Practices.Unity.InterceptionExtension.IMethodInvocation, Microsoft.Practices.Unity.InterceptionExtension.InvokeInterceptionBehaviorDelegate)</span><br><span class="line">00000076dbf7c7a0 00007ffd5c617002 Microsoft.Practices.Unity.InterceptionExtension.InterceptingRealProxy.Invoke(System.Runtime.Remoting.Messaging.IMessage)</span><br><span class="line">00000076dbf7c880 00007ffdb911190c System.Runtime.Remoting.Proxies.RealProxy.PrivateInvoke(System.Runtime.Remoting.Proxies.MessageData ByRef, Int32) [f:\dd\ndp\clr\src\BCL\system\runtime\remoting\realproxy.cs @ 823]</span><br><span class="line">00000076dbf7ca70 00007ffdbb4f4a02 [TPMethodFrame: 00000076dbf7ca70] Kingdee.BOS.Contracts.IUserParameterService.GetParamter(Kingdee.BOS.Context, Int64, System.String, System.String)</span><br><span class="line">00000076dbf7ccf0 00007ffd5c8d28c5 Kingdee.BOS.App.Security.K3CloudLoginService.SetRegionInfo(Kingdee.BOS.Context, Kingdee.BOS.Contracts.IUserParameterService, Kingdee.BOS.Orm.DataEntity.DynamicObject)</span><br><span class="line">00000076dbf7cd70 00007ffd5c22b2e2 Kingdee.BOS.App.Security.K3DataCenterService.GetDataCenterContextByID(System.String)</span><br><span class="line">00000076dbf7cdc0 00007ffd5c227d97 Kingdee.BOS.App.Security.K3CloudLoginService+c__DisplayClass8.b__3(System.String)</span><br><span class="line">00000076dbf7cdf0 00007ffd5c228471 Kingdee.BOS.Core.Authentication.AbstractAuthService.LoadContext(Kingdee.BOS.Core.Authentication.LoadContextArg)</span><br><span class="line">00000076dbf7ce50 00007ffd5c226ed8 Kingdee.BOS.App.Security.K3CloudLoginService.Login(Kingdee.BOS.Performance.Common.PerformanceContext, Kingdee.BOS.Authentication.LoginInfo)</span><br><span class="line">00000076dbf7ced0 00007ffd5c20b5a9 Kingdee.BOS.ServiceHelper.LoginServiceHelper.Login(Kingdee.BOS.Performance.Common.PerformanceContext, System.String, Kingdee.BOS.Authentication.LoginInfo)</span><br><span class="line">00000076dbf7cf30 00007ffd5c20960f Kingdee.BOS.WebApi.ServicesStub.AuthService.ValidateLoginInfo(System.String, Kingdee.BOS.Authentication.LoginInfo)</span><br><span class="line">00000076dbf7d080 00007ffd5c20783c Kingdee.BOS.WebApi.ServicesStub.AuthService.ValidateUser(System.String, System.String, System.String, Int32)</span><br><span class="line">00000076dbf7d318 00007ffdbb4f6793 [DebuggerU2MCatchHandlerFrame: 00000076dbf7d318] </span><br><span class="line">00000076dbf7d658 00007ffdbb4f6793 [HelperMethodFrame_PROTECTOBJ: 00000076dbf7d658] System.RuntimeMethodHandle.InvokeMethod(System.Object, System.Object[], System.Signature, Boolean)</span><br><span class="line">00000076dbf7d7d0 00007ffdb914b690 System.Reflection.RuntimeMethodInfo.UnsafeInvokeInternal(System.Object, System.Object[], System.Object[]) [f:\dd\ndp\clr\src\BCL\system\reflection\methodinfo.cs @ 761]</span><br><span class="line">00000076dbf7d840 00007ffdb9142922 System.Reflection.RuntimeMethodInfo.Invoke(System.Object, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo) [f:\dd\ndp\clr\src\BCL\system\reflection\methodinfo.cs @ 735]</span><br><span class="line">00000076dbf7d8c0 00007ffd5c206201 Kingdee.BOS.ServiceFacade.KDServiceFx.ServiceExecutor.Execute(Kingdee.BOS.ServiceFacade.KDServiceFx.KDServiceContext, Kingdee.BOS.ServiceFacade.KDServiceFx.ServiceType, System.String[], Kingdee.BOS.ServiceFacade.SerializerProxy, Kingdee.BOS.ServiceFacade.KDServiceFx.ServiceType)</span><br><span class="line">00000076dbf7d960 00007ffd5c203ea9 Kingdee.BOS.ServiceFacade.KDServiceFx.ExecuteServiceModule.OnProcess(Kingdee.BOS.ServiceFacade.KDServiceFx.KDServiceContext)</span><br><span class="line">00000076dbf7da00 00007ffd5c203ab8 Kingdee.BOS.ServiceFacade.KDServiceFx.ModulePipeline.ExcuteRequest(Kingdee.BOS.ServiceFacade.KDServiceFx.KDServiceContext)</span><br><span class="line">00000076dbf7da50 00007ffd5c20123e Kingdee.BOS.ServiceFacade.KDServiceFx.RequestExcuteRuntime.StartRequest(Kingdee.BOS.ServiceFacade.KDServiceFx.RequestExtractor, Kingdee.BOS.ServiceFacade.KDServiceFx.WebContext)</span><br><span class="line">00000076dbf7daa0 00007ffd5c200f00 Kingdee.BOS.ServiceFacade.KDServiceFx.KDSVCHandler.ExecuteRequest(Kingdee.BOS.ServiceFacade.KDServiceFx.WebContext, Kingdee.BOS.ServiceFacade.KDServiceFx.RequestExtractor)</span><br><span class="line">00000076dbf7dae0 00007ffd5c200d45 Kingdee.BOS.ServiceFacade.KDServiceFx.KDSVCHandler.ProcessRequestInternal(Kingdee.BOS.ServiceFacade.KDServiceFx.WebContext, Kingdee.BOS.ServiceFacade.KDServiceFx.RequestExtractor)</span><br><span class="line">00000076dbf7db30 00007ffdac1a373e *** WARNING: Unable to verify checksum for System.Web.ni.dll</span><br><span class="line">System.Web.HttpApplication+CallHandlerExecutionStep.System.Web.HttpApplication.IExecutionStep.Execute()</span><br><span class="line">00000076dbf7dbc0 00007ffdac1633fb System.Web.HttpApplication.ExecuteStep(IExecutionStep, Boolean ByRef)</span><br><span class="line">00000076dbf7dc10 00007ffdac178220 System.Web.HttpApplication+PipelineStepManager.ResumeSteps(System.Exception)</span><br><span class="line">00000076dbf7dd70 00007ffdac163f79 System.Web.HttpApplication.BeginProcessRequestNotification(System.Web.HttpContext, System.AsyncCallback)</span><br><span class="line">00000076dbf7ddc0 00007ffdac1766c3 System.Web.HttpRuntime.ProcessRequestNotificationPrivate(System.Web.Hosting.IIS7WorkerRequest, System.Web.HttpContext)</span><br><span class="line">00000076dbf7de40 00007ffdac165398 System.Web.Hosting.PipelineRuntime.ProcessRequestNotificationHelper(IntPtr, IntPtr, IntPtr, Int32)</span><br><span class="line">00000076dbf7e000 00007ffdac164f63 System.Web.Hosting.PipelineRuntime.ProcessRequestNotification(IntPtr, IntPtr, IntPtr, Int32)</span><br><span class="line">00000076dbf7e040 00007ffdac8646ba DomainNeutralILStubClass.IL_STUB_ReversePInvoke(Int64, Int64, Int64, Int32)</span><br><span class="line">00000076dbf7e8b0 00007ffdbb4f21fe [InlinedCallFrame: 00000076dbf7e8b0] System.Web.Hosting.UnsafeIISMethods.MgdIndicateCompletion(IntPtr, System.Web.RequestNotificationStatus ByRef)</span><br><span class="line">00000076dbf7e8b0 00007ffdac1d2dde [InlinedCallFrame: 00000076dbf7e8b0] System.Web.Hosting.UnsafeIISMethods.MgdIndicateCompletion(IntPtr, System.Web.RequestNotificationStatus ByRef)</span><br><span class="line">00000076dbf7e880 00007ffdac1d2dde DomainNeutralILStubClass.IL_STUB_PInvoke(IntPtr, System.Web.RequestNotificationStatus ByRef)</span><br><span class="line">00000076dbf7e940 00007ffdac16556f System.Web.Hosting.PipelineRuntime.ProcessRequestNotificationHelper(IntPtr, IntPtr, IntPtr, Int32)</span><br><span class="line">00000076dbf7eb00 00007ffdac164f63 System.Web.Hosting.PipelineRuntime.ProcessRequestNotification(IntPtr, IntPtr, IntPtr, Int32)</span><br><span class="line">00000076dbf7eb40 00007ffdac8646ba DomainNeutralILStubClass.IL_STUB_ReversePInvoke(Int64, Int64, Int64, Int32)</span><br><span class="line">00000076dbf7ed18 00007ffdbb4f2453 [ContextTransitionFrame: 00000076dbf7ed18]</span><br></pre></td></tr></table></figure>
<p>通过仔细比对发现这么一条<code>Kingdee.BOS.App.Core.MainConsole.MainConsoleServer.GetMenuArrayForCache(Kingdee.BOS.Context)</code>调用堆栈。从方法命名来看，像是用来获取菜单数组并缓存。结合前后堆栈的联系，我们可以大致得出这样一个线索：<strong>用户使用WebApi登录后会缓存一份独立的菜单供用户使用</strong>。</p>
<p>有了代码堆栈，接下来知道怎么干了吧？当然是核实源代码确定问题啊。</p>
<h1 id="4-分析源码验证问题"><a href="#4-分析源码验证问题" class="headerlink" title="4. 分析源码验证问题"></a>4. 分析源码验证问题</h1><p><code>Kingdee.BOS.App.Core.MainConsole.MainConsoleServer.GetMenuArrayForCache(Kingdee.BOS.Context)</code>方法源代码如下：<br><img src="/images/use-windbg-to-analyze-high-memory-issue/2799767-6b4c4abbb111e312.png" alt="GetMenuArrayForCache"></p>
<p>我们发现它是用的<code>UserToken</code>来缓存用户菜单。看到<code>Token</code>，你可能就会条件反射的想到其生命周期。是的，聪明贤惠如你，Token是有生命周期的。也就意味着Token过期后，下次登录还会再次缓存一份菜单。你可能会问Token过期后没有去清对应的菜单缓存吗？是的，并没有。</p>
<p>严谨的你，可能又会问Token多久过期？20mins。你眼珠子一转，接着问，满打满算，一个用户1个小时也就申请3次Token，24小时，也就申请72个Token，一个菜单缓存也就顶多1K，所以一个用户一天也就最多占用72K。你的网站得有多少并发，才能被这么多菜单缓存撑爆啊？！</p>
<p>Good Question！！！</p>
<p>是的，客户的应用场景的并发也就顶多几百而已。那到底是什么导致如此多的菜单缓存呢？</p>
<p>原因是，客户的第三方客户端使用WebApi与我们的系统对接。而每次调用WebApi时都会先去调用登录接口，但却未保存会话信息。也就是说，客户第三方客户端每次的WebApi调用都会产生一个新的Token。那如果有成千上万的WebApi请求，也就意味着成千上万的菜单缓存啊。</p>
<p>好了，点到为止。至此，已经基本定位到问题的根源了。</p>
<h1 id="5-最后"><a href="#5-最后" class="headerlink" title="5. 最后"></a>5. 最后</h1><p>也许很多同学没有接触过WinDbg，觉得其是一个复杂的工具。其实通过本文的案例讲解，其无非是通过一系列常见的命令来进行问题跟踪来定位问题。</p>
<p>最后来简单总结下，Windbg分析问题的步骤：</p>
<ol>
<li>创建完整Dump文件</li>
<li>Windbg加载Dump文件</li>
<li>根据不同问题类型，使用相关的命令进行分析</li>
<li>耐心分析，抽丝剥茧</li>
<li>边分析边猜测边验证</li>
<li>结合源码验证猜想</li>
<li>修复验证</li>
</ol>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>WinDbg</tag>
      </tags>
  </entry>
</search>
